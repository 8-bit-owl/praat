# 1 "VowelEditor.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "VowelEditor.cpp"
# 46 "VowelEditor.cpp"
# 1 "../fon/FormantGrid.h" 1
# 21 "../fon/FormantGrid.h"
# 1 "../fon/RealTier.h" 1
# 21 "../fon/RealTier.h"
# 1 "../fon/AnyTier.h" 1
# 21 "../fon/AnyTier.h"
# 1 "../sys/Collection.h" 1
# 25 "../sys/Collection.h"
# 1 "../sys/Simple.h" 1
# 21 "../sys/Simple.h"
# 1 "../sys/Data.h" 1
# 23 "../sys/Data.h"
# 1 "../sys/Thing.h" 1
# 24 "../sys/Thing.h"
# 1 "../melder/melder.h" 1
# 21 "../melder/melder.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4


# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 36 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 38 "/usr/include/stdio.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 22 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4




typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 524 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
}
# 42 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 57 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef _G_fpos_t fpos_t;




typedef _G_fpos64_t fpos64_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();







extern FILE *tmpfile (void) ;
# 169 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 213 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 223 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 232 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 256 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 506 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 868 "/usr/include/stdio.h" 3 4
}
# 22 "../melder/melder.h" 2
# 1 "/usr/include/c++/9/stdlib.h" 1 3
# 36 "/usr/include/c++/9/stdlib.h" 3
# 1 "/usr/include/c++/9/cstdlib" 1 3
# 39 "/usr/include/c++/9/cstdlib" 3
       
# 40 "/usr/include/c++/9/cstdlib" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 1 3
# 252 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 274 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 524 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/os_defines.h" 1 3
# 525 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/cpu_defines.h" 1 3
# 528 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 2 3
# 42 "/usr/include/c++/9/cstdlib" 2 3
# 75 "/usr/include/c++/9/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 87 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 207 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 244 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 261 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 278 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 272 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 273 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 128 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 157 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 195 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4







struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 198 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sysmacros.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 2 3 4
# 71 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

extern unsigned int gnu_dev_major (__dev_t __dev) throw () __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) throw () __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () __attribute__ ((__const__));
# 85 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 206 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4






typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 246 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;
 




  short __spins; short __elision;
  __pthread_list_t __list;
# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
 
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 255 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 607 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 739 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 771 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/9/cstdlib" 2 3

# 1 "/usr/include/c++/9/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/9/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/9/bits/std_abs.h" 3
# 46 "/usr/include/c++/9/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/9/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 101 "/usr/include/c++/9/bits/std_abs.h" 3
  inline constexpr
  __float128
  abs(__float128 __x)
  { return __x < 0 ? -__x : __x; }



}
}
# 78 "/usr/include/c++/9/cstdlib" 2 3
# 121 "/usr/include/c++/9/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/9/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/9/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/9/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 23 "../melder/melder.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 88 "/usr/include/string.h" 3 4
}
# 98 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 203 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 223 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 250 "/usr/include/string.h" 3 4
}
# 260 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 300 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 327 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 368 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 420 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 498 "/usr/include/string.h" 3 4
}
# 24 "../melder/melder.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 25 "../melder/melder.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 26 "../melder/melder.h" 2
# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 41 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4





typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 337 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 727 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 782 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 808 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 818 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 857 "/usr/include/wchar.h" 3 4
}
# 27 "../melder/melder.h" 2
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();






extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();







extern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     throw ();






extern wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) throw ();



}
# 28 "../melder/melder.h" 2




# 1 "/usr/include/c++/9/functional" 1 3
# 46 "/usr/include/c++/9/functional" 3
       
# 47 "/usr/include/c++/9/functional" 3


# 1 "/usr/include/c++/9/bits/stl_function.h" 1 3
# 60 "/usr/include/c++/9/bits/stl_function.h" 3
# 1 "/usr/include/c++/9/bits/move.h" 1 3
# 34 "/usr/include/c++/9/bits/move.h" 3
# 1 "/usr/include/c++/9/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/9/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/9/bits/concept_check.h" 3
# 35 "/usr/include/c++/9/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}

# 1 "/usr/include/c++/9/type_traits" 1 3
# 32 "/usr/include/c++/9/type_traits" 3
       
# 33 "/usr/include/c++/9/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/usr/include/c++/9/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 185 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 243 "/usr/include/c++/9/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 323 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 758 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public is_constructible<_Tp>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __bool_constant<__is_assignable(_Tp, _Up)>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<is_default_constructible<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };

  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };

  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };

  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    { };



  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };

  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };
# 1380 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1593 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<typename remove_cv<_Tp>::type>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1669 "/usr/include/c++/9/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1747 "/usr/include/c++/9/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<typename remove_cv<_Tp>::type>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1795 "/usr/include/c++/9/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1930 "/usr/include/c++/9/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 1969 "/usr/include/c++/9/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<>
    struct common_type<>
    { };

  template<typename _Tp>
    struct common_type<_Tp>
    : common_type<_Tp, _Tp>
    { };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };


  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;



  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<typename...> using __void_t = void;




  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2461 "/usr/include/c++/9/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };



  template<typename _Tp>
    constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;







  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 3097 "/usr/include/c++/9/type_traits" 3

}
# 56 "/usr/include/c++/9/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 72 "/usr/include/c++/9/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 116 "/usr/include/c++/9/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 136 "/usr/include/c++/9/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 176 "/usr/include/c++/9/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 61 "/usr/include/c++/9/bits/stl_function.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/include/c++/9/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/usr/include/c++/9/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/usr/include/c++/9/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x > __y;

 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x < __y;

 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x >= __y;

 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x <= __y;

 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };
# 774 "/usr/include/c++/9/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 1002 "/usr/include/c++/9/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1079 "/usr/include/c++/9/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1202 "/usr/include/c++/9/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/9/backward/binders.h" 1 3
# 60 "/usr/include/c++/9/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/9/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1393 "/usr/include/c++/9/bits/stl_function.h" 2 3
# 50 "/usr/include/c++/9/functional" 2 3



# 1 "/usr/include/c++/9/new" 1 3
# 37 "/usr/include/c++/9/new" 3
       
# 38 "/usr/include/c++/9/new" 3


# 1 "/usr/include/c++/9/exception" 1 3
# 33 "/usr/include/c++/9/exception" 3
       
# 34 "/usr/include/c++/9/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/9/bits/exception.h" 1 3
# 34 "/usr/include/c++/9/bits/exception.h" 3
       
# 35 "/usr/include/c++/9/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/9/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/9/exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 101 "/usr/include/c++/9/exception" 3
 
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 133 "/usr/include/c++/9/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/9/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/9/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/9/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/9/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 39 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/9/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/9/typeinfo" 1 3
# 32 "/usr/include/c++/9/typeinfo" 3
       
# 33 "/usr/include/c++/9/typeinfo" 3



# 1 "/usr/include/c++/9/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/9/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/9/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/9/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/9/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/9/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/include/c++/9/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/9/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/9/new" 1 3
# 41 "/usr/include/c++/9/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "/usr/include/c++/9/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "/usr/include/c++/9/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(__ex)),
   __exception_ptr::__dest_thunk<_Ex>);
      try
 {
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 208 "/usr/include/c++/9/bits/exception_ptr.h" 3
    }


}

}

#pragma GCC visibility pop
# 144 "/usr/include/c++/9/exception" 2 3
# 1 "/usr/include/c++/9/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/9/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 42 "/usr/include/c++/9/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 145 "/usr/include/c++/9/exception" 2 3
# 41 "/usr/include/c++/9/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 125 "/usr/include/c++/9/new" 3
 void* operator new(std::size_t)
  __attribute__((__externally_visible__));
 void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

 void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
 void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 173 "/usr/include/c++/9/new" 3
 inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
 inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 226 "/usr/include/c++/9/new" 3
#pragma GCC visibility pop
# 54 "/usr/include/c++/9/functional" 2 3
# 1 "/usr/include/c++/9/tuple" 1 3
# 32 "/usr/include/c++/9/tuple" 3
       
# 33 "/usr/include/c++/9/tuple" 3





# 1 "/usr/include/c++/9/utility" 1 3
# 58 "/usr/include/c++/9/utility" 3
       
# 59 "/usr/include/c++/9/utility" 3
# 69 "/usr/include/c++/9/utility" 3
# 1 "/usr/include/c++/9/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/9/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/usr/include/c++/9/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/9/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/9/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/9/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/usr/include/c++/9/utility" 2 3
# 1 "/usr/include/c++/9/bits/stl_pair.h" 1 3
# 65 "/usr/include/c++/9/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/usr/include/c++/9/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };







  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 252 "/usr/include/c++/9/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 280 "/usr/include/c++/9/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };






  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 521 "/usr/include/c++/9/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 540 "/usr/include/c++/9/bits/stl_pair.h" 3

}
# 71 "/usr/include/c++/9/utility" 2 3





# 1 "/usr/include/c++/9/initializer_list" 1 3
# 33 "/usr/include/c++/9/initializer_list" 3
       
# 34 "/usr/include/c++/9/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 77 "/usr/include/c++/9/utility" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };







  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };
# 301 "/usr/include/c++/9/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {






      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;





  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 396 "/usr/include/c++/9/utility" 3

}
# 39 "/usr/include/c++/9/tuple" 2 3
# 1 "/usr/include/c++/9/array" 1 3
# 32 "/usr/include/c++/9/array" 3
       
# 33 "/usr/include/c++/9/array" 3






# 1 "/usr/include/c++/9/stdexcept" 1 3
# 36 "/usr/include/c++/9/stdexcept" 3
       
# 37 "/usr/include/c++/9/stdexcept" 3


# 1 "/usr/include/c++/9/string" 1 3
# 36 "/usr/include/c++/9/string" 3
       
# 37 "/usr/include/c++/9/string" 3


# 1 "/usr/include/c++/9/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/9/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/9/bits/stringfwd.h" 3


# 1 "/usr/include/c++/9/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/9/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/9/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/9/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;



  template<typename, typename>
    struct uses_allocator;





}
# 41 "/usr/include/c++/9/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;







  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

}


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;
# 93 "/usr/include/c++/9/bits/stringfwd.h" 3
  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "/usr/include/c++/9/string" 2 3
# 1 "/usr/include/c++/9/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/9/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/9/bits/char_traits.h" 3

# 1 "/usr/include/c++/9/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/9/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/9/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/9/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__));


  void
  __throw_system_error(int) __attribute__((__noreturn__));


  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/9/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/9/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 184 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 270 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 287 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 417 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "/usr/include/c++/9/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/9/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/9/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/9/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "/usr/include/c++/9/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/9/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/9/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/9/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/9/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/9/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/9/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 231 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/usr/include/c++/9/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/include/c++/9/debug/assertions.h" 1 3
# 66 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/9/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/9/bits/stl_iterator.h" 1 3
# 66 "/usr/include/c++/9/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/9/bits/ptr_traits.h" 1 3
# 37 "/usr/include/c++/9/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 198 "/usr/include/c++/9/bits/ptr_traits.h" 3

}
# 67 "/usr/include/c++/9/bits/stl_iterator.h" 2 3
# 76 "/usr/include/c++/9/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 130 "/usr/include/c++/9/bits/stl_iterator.h" 3
     
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




     
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 176 "/usr/include/c++/9/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }

    private:
      template<typename _Tp>
 static _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 323 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 413 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 477 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 512 "/usr/include/c++/9/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 554 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 569 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 603 "/usr/include/c++/9/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 645 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 664 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 715 "/usr/include/c++/9/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 760 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 784 "/usr/include/c++/9/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 884 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1030 "/usr/include/c++/9/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

     
      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 1295 "/usr/include/c++/9/bits/stl_iterator.h" 3

}
# 68 "/usr/include/c++/9/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/9/debug/debug.h" 1 3
# 48 "/usr/include/c++/9/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "/usr/include/c++/9/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/9/bits/predefined_ops.h" 1 3
# 33 "/usr/include/c++/9/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/9/bits/stl_algobase.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 121 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 151 "/usr/include/c++/9/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 167 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 195 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 219 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 243 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 265 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }




  template<typename _From, typename _To>
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (__res - std::__niter_base(__from)); }


  template<typename _Iterator>
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivially_copyable(_ValueTypeI)
        && __is_pointer<_II>::__value
        && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
         _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a<_IsMove>(std::__niter_base(__first),
         std::__niter_base(__last),
         std::__niter_base(__result)));
    }
# 463 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 495 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivially_copyable(_ValueType1)
        && __is_pointer<_BI1>::__value
        && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 639 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 674 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 740 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 800 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     
      ;

      return std::__niter_wrap(__first,
  std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __is_pointer<_II1>::__value
        && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1002 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }


# 1057 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1089 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1176 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1208 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1239 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1275 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1318 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1351 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1398 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1433 "/usr/include/c++/9/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }




}
# 40 "/usr/include/c++/9/bits/char_traits.h" 2 3
# 1 "/usr/include/c++/9/bits/postypes.h" 1 3
# 38 "/usr/include/c++/9/bits/postypes.h" 3
       
# 39 "/usr/include/c++/9/bits/postypes.h" 3

# 1 "/usr/include/c++/9/cwchar" 1 3
# 39 "/usr/include/c++/9/cwchar" 3
       
# 40 "/usr/include/c++/9/cwchar" 3
# 62 "/usr/include/c++/9/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/9/cwchar" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/usr/include/c++/9/cwchar" 3

}
}







namespace __gnu_cxx
{





  using ::wcstold;
# 260 "/usr/include/c++/9/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 280 "/usr/include/c++/9/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/9/bits/postypes.h" 2 3
# 68 "/usr/include/c++/9/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/9/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/9/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/9/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/9/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      fpos(const fpos&) = default;
      fpos& operator=(const fpos&) = default;
      ~fpos() = default;



      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 245 "/usr/include/c++/9/bits/postypes.h" 3
  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/include/c++/9/bits/char_traits.h" 2 3
# 1 "/usr/include/c++/9/cwchar" 1 3
# 39 "/usr/include/c++/9/cwchar" 3
       
# 40 "/usr/include/c++/9/cwchar" 3
# 42 "/usr/include/c++/9/bits/char_traits.h" 2 3





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 61 "/usr/include/c++/9/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/usr/include/c++/9/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr std::size_t
      length(const char_type* __s);

      static constexpr const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    constexpr int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    constexpr std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    constexpr const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 283 "/usr/include/c++/9/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;






 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return __builtin_strlen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;






 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;






 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return wcslen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;






 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
# 616 "/usr/include/c++/9/bits/char_traits.h" 3

}



# 1 "/usr/include/c++/9/cstdint" 1 3
# 32 "/usr/include/c++/9/cstdint" 3
       
# 33 "/usr/include/c++/9/cstdint" 3
# 41 "/usr/include/c++/9/cstdint" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 97 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 2 3 4
# 42 "/usr/include/c++/9/cstdint" 2 3


namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;





}
# 622 "/usr/include/c++/9/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;

      typedef uint_least16_t int_type;





      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;

      typedef uint_least32_t int_type;





      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/usr/include/c++/9/string" 2 3
# 1 "/usr/include/c++/9/bits/allocator.h" 1 3
# 46 "/usr/include/c++/9/bits/allocator.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h" 1 3
# 33 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h" 3
# 1 "/usr/include/c++/9/ext/new_allocator.h" 1 3
# 40 "/usr/include/c++/9/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/include/c++/9/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


     
      new_allocator() noexcept { }

     
      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>

 new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();
# 114 "/usr/include/c++/9/ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      {







 ::operator delete(__p);
      }

      size_type
      max_size() const noexcept
      {

 return size_t(0x7fffffffffffffffL) / sizeof(_Tp);



      }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 noexcept(noexcept(::new((void *)__p)
       _Up(std::forward<_Args>(__args)...)))
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p)
 noexcept(noexcept( __p->~_Up()))
 { __p->~_Up(); }
# 165 "/usr/include/c++/9/ext/new_allocator.h" 3
      template<typename _Up>
 friend bool
 operator==(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return true; }

      template<typename _Up>
 friend bool
 operator!=(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return false; }
    };


}
# 34 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/9/bits/allocator.h" 2 3
# 57 "/usr/include/c++/9/bits/allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 noexcept(noexcept(::new((void *)__p)
       _Up(std::forward<_Args>(__args)...)))
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p)
 noexcept(noexcept(__p->~_Up()))
 { __p->~_Up(); }

    };
# 111 "/usr/include/c++/9/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;




     
      allocator() noexcept { }

     
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>

 allocator(const allocator<_Tp1>&) noexcept { }

      ~allocator() noexcept { }

      friend bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }

      friend bool
      operator!=(const allocator&, const allocator&) noexcept
      { return false; }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }



  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/usr/include/c++/9/string" 2 3

# 1 "/usr/include/c++/9/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/9/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/9/bits/localefwd.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++locale.h" 1 3
# 39 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++locale.h" 3
       
# 40 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++locale.h" 3

# 1 "/usr/include/c++/9/clocale" 1 3
# 39 "/usr/include/c++/9/clocale" 3
       
# 40 "/usr/include/c++/9/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) throw ();
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) throw ();



extern void freelocale (locale_t __dataset) throw ();






extern locale_t uselocale (locale_t __dataset) throw ();







}
# 43 "/usr/include/c++/9/clocale" 2 3
# 51 "/usr/include/c++/9/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/9/bits/localefwd.h" 2 3
# 1 "/usr/include/c++/9/iosfwd" 1 3
# 36 "/usr/include/c++/9/iosfwd" 3
       
# 37 "/usr/include/c++/9/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/9/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 42 "/usr/include/c++/9/bits/localefwd.h" 2 3
# 1 "/usr/include/c++/9/cctype" 1 3
# 39 "/usr/include/c++/9/cctype" 3
       
# 40 "/usr/include/c++/9/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/9/cctype" 2 3
# 62 "/usr/include/c++/9/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/include/c++/9/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/9/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;


  template<> class codecvt<char16_t, char, mbstate_t>;
  template<> class codecvt<char32_t, char, mbstate_t>;





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 44 "/usr/include/c++/9/string" 2 3
# 1 "/usr/include/c++/9/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/9/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/9/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/9/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/9/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/9/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/9/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/9/string" 2 3
# 54 "/usr/include/c++/9/string" 3
# 1 "/usr/include/c++/9/bits/range_access.h" 1 3
# 33 "/usr/include/c++/9/bits/range_access.h" 3
       
# 34 "/usr/include/c++/9/bits/range_access.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 323 "/usr/include/c++/9/bits/range_access.h" 3

}
# 55 "/usr/include/c++/9/string" 2 3
# 1 "/usr/include/c++/9/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/9/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/9/bits/basic_string.h" 3

# 1 "/usr/include/c++/9/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/9/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/9/ext/atomicity.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr.h" 1 3
# 30 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 1 3
# 35 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
{
  int sched_priority;
};

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 196 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 280 "/usr/include/time.h" 3 4
extern int getdate_err;
# 289 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 303 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 25 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 156 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 191 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 229 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 495 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 507 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 541 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 743 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 807 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 889 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1001 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1045 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1112 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1146 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1160 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 2 3
# 47 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 102 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once"), __copy__ (pthread_once)));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific"), __copy__ (pthread_getspecific)));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific"), __copy__ (pthread_setspecific)));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create"), __copy__ (pthread_create)));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join"), __copy__ (pthread_join)));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal"), __copy__ (pthread_equal)));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self"), __copy__ (pthread_self)));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach"), __copy__ (pthread_detach)));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel"), __copy__ (pthread_cancel)));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield"), __copy__ (sched_yield)));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock"), __copy__ (pthread_mutex_lock)));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock"), __copy__ (pthread_mutex_trylock)));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock"), __copy__ (pthread_mutex_timedlock)));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock"), __copy__ (pthread_mutex_unlock)));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init"), __copy__ (pthread_mutex_init)));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy"), __copy__ (pthread_mutex_destroy)));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init"), __copy__ (pthread_cond_init)));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast"), __copy__ (pthread_cond_broadcast)));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal"), __copy__ (pthread_cond_signal)));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait"), __copy__ (pthread_cond_wait)));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait"), __copy__ (pthread_cond_timedwait)));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy"), __copy__ (pthread_cond_destroy)));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create"), __copy__ (pthread_key_create)));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete"), __copy__ (pthread_key_delete)));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init"), __copy__ (pthread_mutexattr_init)));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype"), __copy__ (pthread_mutexattr_settype)));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy"), __copy__ (pthread_mutexattr_destroy)));
# 237 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create"), __copy__ (pthread_key_create)));
# 247 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 659 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 808 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 850 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/9/ext/atomicity.h" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/atomic_word.h" 1 3
# 32 "/usr/include/x86_64-linux-gnu/c++/9/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/9/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/include/c++/9/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/include/c++/9/bits/basic_string.h" 2 3
# 1 "/usr/include/c++/9/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/9/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/9/ext/alloc_traits.h" 3



# 1 "/usr/include/c++/9/bits/alloc_traits.h" 1 3
# 41 "/usr/include/c++/9/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(::new((void*)__p)
     _Tp(std::forward<_Args>(__args)...)))
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(noexcept(__p->~_Tp()))
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 304 "/usr/include/c++/9/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 319 "/usr/include/c++/9/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 331 "/usr/include/c++/9/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 346 "/usr/include/c++/9/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 361 "/usr/include/c++/9/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 374 "/usr/include/c++/9/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 385 "/usr/include/c++/9/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 442 "/usr/include/c++/9/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 456 "/usr/include/c++/9/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 468 "/usr/include/c++/9/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 480 "/usr/include/c++/9/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 493 "/usr/include/c++/9/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 noexcept(noexcept(__a.destroy(__p)))
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };




  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };


  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };


  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;


}
# 37 "/usr/include/c++/9/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 161 "/usr/include/c++/9/ext/alloc_traits.h" 3
  };


}
# 41 "/usr/include/c++/9/bits/basic_string.h" 2 3
# 52 "/usr/include/c++/9/bits/basic_string.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 76 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    protected:




      typedef const_iterator __const_iterator;


    private:
# 150 "/usr/include/c++/9/bits/basic_string.h" 3
      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 309 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 461 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 492 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 510 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }
# 525 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
# 540 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 552 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 620 "/usr/include/c++/9/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 657 "/usr/include/c++/9/bits/basic_string.h" 3
      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 714 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 731 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
# 825 "/usr/include/c++/9/bits/basic_string.h" 3
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 954 "/usr/include/c++/9/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 967 "/usr/include/c++/9/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 1016 "/usr/include/c++/9/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1045 "/usr/include/c++/9/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 1062 "/usr/include/c++/9/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 1083 "/usr/include/c++/9/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1104 "/usr/include/c++/9/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1167 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1220 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1237 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1279 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1303 "/usr/include/c++/9/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }
# 1348 "/usr/include/c++/9/bits/basic_string.h" 3
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1379 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1402 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1418 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1434 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1451 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1464 "/usr/include/c++/9/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1533 "/usr/include/c++/9/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1575 "/usr/include/c++/9/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1611 "/usr/include/c++/9/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, initializer_list<_CharT> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1638 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1661 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1684 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1703 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1727 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1745 "/usr/include/c++/9/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1806 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1825 "/usr/include/c++/9/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1844 "/usr/include/c++/9/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1888 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1910 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1935 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1960 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1984 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 2002 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2022 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2044 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2065 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2090 "/usr/include/c++/9/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2122 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2181 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2241 "/usr/include/c++/9/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2279 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2289 "/usr/include/c++/9/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2299 "/usr/include/c++/9/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2311 "/usr/include/c++/9/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2330 "/usr/include/c++/9/bits/basic_string.h" 3
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2346 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2360 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2392 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2409 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2422 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2456 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2470 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2487 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2501 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2536 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2550 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2570 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2585 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2620 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2634 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2654 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2668 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2703 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2717 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2735 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2750 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2785 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2799 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2817 "/usr/include/c++/9/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2833 "/usr/include/c++/9/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2852 "/usr/include/c++/9/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2945 "/usr/include/c++/9/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2971 "/usr/include/c++/9/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2989 "/usr/include/c++/9/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 3013 "/usr/include/c++/9/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3040 "/usr/include/c++/9/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
# 3071 "/usr/include/c++/9/bits/basic_string.h" 3
      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 6018 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6139 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6186 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6224 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6262 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6300 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6338 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6376 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6396 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6414 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6437 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6454 "/usr/include/c++/9/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/usr/include/c++/9/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/9/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/9/ext/string_conversions.h" 3
# 41 "/usr/include/c++/9/ext/string_conversions.h" 3
# 1 "/usr/include/c++/9/cstdlib" 1 3
# 39 "/usr/include/c++/9/cstdlib" 3
       
# 40 "/usr/include/c++/9/cstdlib" 3
# 42 "/usr/include/c++/9/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/9/cwchar" 1 3
# 39 "/usr/include/c++/9/cwchar" 3
       
# 40 "/usr/include/c++/9/cwchar" 3
# 43 "/usr/include/c++/9/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/9/cstdio" 1 3
# 39 "/usr/include/c++/9/cstdio" 3
       
# 40 "/usr/include/c++/9/cstdio" 3
# 96 "/usr/include/c++/9/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/include/c++/9/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/include/c++/9/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/include/c++/9/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/9/cerrno" 1 3
# 39 "/usr/include/c++/9/cerrno" 3
       
# 40 "/usr/include/c++/9/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;





typedef int error_t;




}
# 43 "/usr/include/c++/9/cerrno" 2 3
# 45 "/usr/include/c++/9/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6494 "/usr/include/c++/9/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}





# 1 "/usr/include/c++/9/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/9/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/9/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/9/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type ;
      typedef _Arg argument_type ;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/usr/include/c++/9/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };







  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 192 "/usr/include/c++/9/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };
# 278 "/usr/include/c++/9/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 6720 "/usr/include/c++/9/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };
# 6778 "/usr/include/c++/9/bits/basic_string.h" 3
  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };





  inline namespace literals
  {
  inline namespace string_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }
# 6836 "/usr/include/c++/9/bits/basic_string.h" 3
    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }

#pragma GCC diagnostic pop
  }
  }
# 6868 "/usr/include/c++/9/bits/basic_string.h" 3

}
# 56 "/usr/include/c++/9/string" 2 3
# 1 "/usr/include/c++/9/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/9/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/9/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1156 "/usr/include/c++/9/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1608 "/usr/include/c++/9/bits/basic_string.tcc" 3
  extern template class basic_string<char>;







  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);



  extern template class basic_string<wchar_t>;





  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 57 "/usr/include/c++/9/string" 2 3
# 40 "/usr/include/c++/9/stdexcept" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/include/c++/9/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;

    logic_error(logic_error&&) noexcept;
    logic_error& operator=(logic_error&&) noexcept;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;





    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;
    domain_error(const domain_error&) = default;
    domain_error& operator=(const domain_error&) = default;
    domain_error(domain_error&&) = default;
    domain_error& operator=(domain_error&&) = default;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;
    invalid_argument(const invalid_argument&) = default;
    invalid_argument& operator=(const invalid_argument&) = default;
    invalid_argument(invalid_argument&&) = default;
    invalid_argument& operator=(invalid_argument&&) = default;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;
    length_error(const length_error&) = default;
    length_error& operator=(const length_error&) = default;
    length_error(length_error&&) = default;
    length_error& operator=(length_error&&) = default;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;
    out_of_range(const out_of_range&) = default;
    out_of_range& operator=(const out_of_range&) = default;
    out_of_range(out_of_range&&) = default;
    out_of_range& operator=(out_of_range&&) = default;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;

    runtime_error(runtime_error&&) noexcept;
    runtime_error& operator=(runtime_error&&) noexcept;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;





    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;
    range_error(const range_error&) = default;
    range_error& operator=(const range_error&) = default;
    range_error(range_error&&) = default;
    range_error& operator=(range_error&&) = default;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;
    overflow_error(const overflow_error&) = default;
    overflow_error& operator=(const overflow_error&) = default;
    overflow_error(overflow_error&&) = default;
    overflow_error& operator=(overflow_error&&) = default;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;
    underflow_error(const underflow_error&) = default;
    underflow_error& operator=(const underflow_error&) = default;
    underflow_error(underflow_error&&) = default;
    underflow_error& operator=(underflow_error&&) = default;

    virtual ~underflow_error() noexcept;
  };




}
# 40 "/usr/include/c++/9/array" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/usr/include/c++/9/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "/usr/include/c++/9/array" 3
  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline


    typename enable_if<
      std::__array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/include/c++/9/tuple" 2 3
# 1 "/usr/include/c++/9/bits/uses_allocator.h" 1 3
# 35 "/usr/include/c++/9/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }


}
# 41 "/usr/include/c++/9/tuple" 2 3
# 1 "/usr/include/c++/9/bits/invoke.h" 1 3
# 33 "/usr/include/c++/9/bits/invoke.h" 3
       
# 34 "/usr/include/c++/9/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/9/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


}
# 42 "/usr/include/c++/9/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 176 "/usr/include/c++/9/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename... _UElements>
        void
        _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>
        void
        _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _UHead>
        void
        _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>
        void
        _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
        __remove_cvref_t<_SrcTuple>>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }

    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        __remove_cvref_t<_UElements>...>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }

    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

      template<typename... _UElements>
 static constexpr
 __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>
 __assignable()
 { return __and_<is_assignable<_Elements&, _UElements>...>::value; }

      template<typename... _UElements>
 static constexpr bool __nothrow_assignable()
 {
   return
     __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;
 }

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && (_TC<(sizeof...(_UElements)==1), _Elements...>::
     template _NotSameTuple<_UElements...>()),
                      _Elements...>;



      template<typename... _UElements> using _TMCT =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements))
        && !is_same<tuple<_Elements...>,
      tuple<_UElements...>>::value,
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename _Dummy = void,
        typename... _UElements, typename
        enable_if<_TMCT<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMCT<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }



      tuple&
      operator=(typename conditional<__assignable<const _Elements&...>(),
         const tuple&,
         const __nonesuch_no_braces&>::type __in)
      noexcept(__nothrow_assignable<const _Elements&...>())
      {
 this->_M_assign(__in);
 return *this;
      }

      tuple&
      operator=(typename conditional<__assignable<_Elements...>(),
         tuple&&,
         __nonesuch_no_braces&&>::type __in)
      noexcept(__nothrow_assignable<_Elements...>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename... _UElements>
 __enable_if_t<__assignable<const _UElements&...>(), tuple&>
 operator=(const tuple<_UElements...>& __in)
 noexcept(__nothrow_assignable<const _UElements&...>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename... _UElements>
 __enable_if_t<__assignable<_UElements...>(), tuple&>
 operator=(tuple<_UElements...>&& __in)
 noexcept(__nothrow_assignable<_UElements...>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }


      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
    };
# 875 "/usr/include/c++/9/tuple" 3
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&) { }
      template<typename _Alloc>
 tuple(allocator_arg_t, const _Alloc&, const tuple&) { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

      template<typename _U1, typename _U2>
 static constexpr bool __assignable()
 {
   return __and_<is_assignable<_T1&, _U1>,
   is_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_assignable()
 {
   return __and_<is_nothrow_assignable<_T1&, _U1>,
   is_nothrow_assignable<_T2&, _U2>>::value;
 }

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>
 constexpr tuple()
 : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>
 explicit constexpr tuple()
 : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>()
           && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),
         const tuple&,
         const __nonesuch_no_braces&>::type __in)
      noexcept(__nothrow_assignable<const _T1&, const _T2&>())
      {
 this->_M_assign(__in);
 return *this;
      }

      tuple&
      operator=(typename conditional<__assignable<_T1, _T2>(),
         tuple&&,
         __nonesuch_no_braces&&>::type __in)
      noexcept(__nothrow_assignable<_T1, _T2>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename _U1, typename _U2>
 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }

      template<typename _U1, typename _U2>
 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1284 "/usr/include/c++/9/tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template <typename _Tp, typename... _Types>
    constexpr const _Tp&&
    get(const tuple<_Types...>&& __t) noexcept
    { return std::forward<const _Tp&&>(std::__get_helper2<_Tp>(__t)); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1718 "/usr/include/c++/9/tuple" 3

}
# 55 "/usr/include/c++/9/functional" 2 3



# 1 "/usr/include/c++/9/bits/refwrap.h" 1 3
# 33 "/usr/include/c++/9/bits/refwrap.h" 3
       
# 34 "/usr/include/c++/9/bits/refwrap.h" 3
# 43 "/usr/include/c++/9/bits/refwrap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 97 "/usr/include/c++/9/bits/refwrap.h" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
# 111 "/usr/include/c++/9/bits/refwrap.h" 3
  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(_ArgTypes...) >
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(_ArgTypes......) >
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) >
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes >
    struct
    _Weak_result_type_impl<_Res(*)(_ArgTypes......) >
    { typedef _Res result_type; };


  template<typename _Functor,
    bool = is_member_function_pointer<_Functor>::value>
    struct _Weak_result_type_memfun
    : _Weak_result_type_impl<_Functor>
    { };


  template<typename _MemFunPtr>
    struct _Weak_result_type_memfun<_MemFunPtr, true>
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };


  template<typename _Func, typename _Class>
    struct _Weak_result_type_memfun<_Func _Class::*, false>
    { };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_memfun<typename remove_cv<_Functor>::type>
    { };



  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg1
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg1<_Tp,
         __void_t<typename _Tp::argument_type>>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg2
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg2<_Tp,
         __void_t<typename _Tp::first_argument_type,
           typename _Tp::second_argument_type>>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res(_T1) >
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res(_T1, _T2) >
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res(*)(_T1) >
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2) >
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Tp, bool = is_member_function_pointer<_Tp>::value>
    struct _Reference_wrapper_base_memfun
    : _Reference_wrapper_base<_Tp>
    { };

  template<typename _MemFunPtr>
    struct _Reference_wrapper_base_memfun<_MemFunPtr, true>
    : _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };







  template<typename _Tp>
    class reference_wrapper



    : public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type>

    {
      _Tp* _M_data;

      static _Tp* _S_fun(_Tp& __r) noexcept { return std::__addressof(__r); }
      static void _S_fun(_Tp&&) = delete;

      template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
 using __not_same
   = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

    public:
      typedef _Tp type;




      template<typename _Up, typename = __not_same<_Up>, typename
  = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>
 reference_wrapper(_Up&& __uref)
 noexcept(noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
 : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref)))
 { }

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {



   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };







  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return __t; }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return { __t.get() }; }




}
# 59 "/usr/include/c++/9/functional" 2 3
# 1 "/usr/include/c++/9/bits/std_function.h" 1 3
# 33 "/usr/include/c++/9/bits/std_function.h" 3
       
# 34 "/usr/include/c++/9/bits/std_function.h" 3
# 47 "/usr/include/c++/9/bits/std_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union [[gnu::may_alias]] _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const size_t _M_max_size = sizeof(_Nocopy_types);
    static const size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   if (__stored_locally)
     {
       const _Functor& __f = __source._M_access<_Functor>();
       return const_cast<_Functor*>(std::__addressof(__f));
     }
   else
     return __source._M_access<_Functor*>();
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<const _Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { ::new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }

    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__invoke(_Base::_M_get_pointer(__functor)->__value,
        std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::__invoke(_Base::_M_get_pointer(__functor)->__value,
        std::forward<_ArgTypes>(__args)...);
      }
    };







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      template<typename _Func,
        typename _Res2 = __invoke_result<_Func&, _ArgTypes...>>
 struct _Callable
 : __is_invocable_impl<_Res2, _Res>::type
 { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 414 "/usr/include/c++/9/bits/std_function.h" 3
      function(const function& __x);
# 423 "/usr/include/c++/9/bits/std_function.h" 3
      function(function&& __x) noexcept : _Function_base()
      {
 __x.swap(*this);
      }
# 444 "/usr/include/c++/9/bits/std_function.h" 3
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 461 "/usr/include/c++/9/bits/std_function.h" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 479 "/usr/include/c++/9/bits/std_function.h" 3
      function&
      operator=(function&& __x) noexcept
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 493 "/usr/include/c++/9/bits/std_function.h" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
# 521 "/usr/include/c++/9/bits/std_function.h" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 547 "/usr/include/c++/9/bits/std_function.h" 3
      void swap(function& __x) noexcept
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 564 "/usr/include/c++/9/bits/std_function.h" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 577 "/usr/include/c++/9/bits/std_function.h" 3
      _Res operator()(_ArgTypes... __args) const;
# 590 "/usr/include/c++/9/bits/std_function.h" 3
      const type_info& target_type() const noexcept;
# 603 "/usr/include/c++/9/bits/std_function.h" 3
      template<typename _Functor> _Functor* target() noexcept;

      template<typename _Functor> const _Functor* target() const noexcept;



    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };
# 652 "/usr/include/c++/9/bits/std_function.h" 3
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 const function* __const_this = this;
 const _Functor* __func = __const_this->template target<_Functor>();
 return const_cast<_Functor*>(__func);
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return nullptr;
      }
# 744 "/usr/include/c++/9/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 762 "/usr/include/c++/9/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 783 "/usr/include/c++/9/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept
    { __x.swap(__y); }
# 802 "/usr/include/c++/9/bits/std_function.h" 3

}
# 60 "/usr/include/c++/9/functional" 2 3
# 68 "/usr/include/c++/9/functional" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 86 "/usr/include/c++/9/functional" 3
  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>
 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>
 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _MemberPointer>
    struct _Mem_fn;

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
# 158 "/usr/include/c++/9/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
# 173 "/usr/include/c++/9/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
# 184 "/usr/include/c++/9/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };
# 199 "/usr/include/c++/9/functional" 3
  template<int _Num> struct _Placeholder { };





  namespace placeholders
  {




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
  }






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



  template<std::size_t __i, typename _Tuple>
    using _Safe_tuple_element_t
      = typename enable_if<(__i < tuple_size<_Tuple>::value),
      tuple_element<__i, _Tuple>>::type::type;
# 275 "/usr/include/c++/9/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::get<_Indexes>(std::move(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return
     ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }

      template<typename _BoundArg, typename _CallArgs>
 using _Mu_type = decltype(
     _Mu<typename remove_cv<_BoundArg>::type>()(
       std::declval<_BoundArg&>(), std::declval<_CallArgs&>()) );

      template<typename _Fn, typename _CallArgs, typename... _BArgs>
 using _Res_type_impl
   = typename result_of< _Fn&(_Mu_type<_BArgs, _CallArgs>&&...) >::type;

      template<typename _CallArgs>
 using _Res_type = _Res_type_impl<_Functor, _CallArgs, _Bound_args...>;

      template<typename _CallArgs>
 using __dependent = typename
   enable_if<bool(tuple_size<_CallArgs>::value+1), _Functor>::type;

      template<typename _CallArgs, template<class> class __cv_quals>
 using _Res_type_cv = _Res_type_impl<
   typename __cv_quals<__dependent<_CallArgs>>::type,
   _CallArgs,
   typename __cv_quals<_Bound_args>::type...>;

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args,
        typename _Result = _Res_type<tuple<_Args...>>>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_const>>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
# 505 "/usr/include/c++/9/functional" 3
      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_volatile>>

 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_cv>>

 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 using __enable_if_void
   = typename enable_if<is_void<_Res>{}>::type;

      template<typename _Res>
 using __disable_if_void
   = typename enable_if<!is_void<_Res>{}, _Result>::type;


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __disable_if_void<_Res>
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 __enable_if_void<_Res>
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   std::__invoke(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>

 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>

 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };






  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }
# 941 "/usr/include/c++/9/functional" 3
  template<typename _Fn>
    class _Not_fn
    {
      template<typename _Fn2, typename... _Args>
 using __inv_res_t = typename __invoke_result<_Fn2, _Args...>::type;

      template<typename _Tp>
 static decltype(!std::declval<_Tp>())
 _S_not() noexcept(noexcept(!std::declval<_Tp>()));

    public:
      template<typename _Fn2>
 _Not_fn(_Fn2&& __fn, int)
 : _M_fn(std::forward<_Fn2>(__fn)) { }

      _Not_fn(const _Not_fn& __fn) = default;
      _Not_fn(_Not_fn&& __fn) = default;
      ~_Not_fn() = default;
# 973 "/usr/include/c++/9/functional" 3
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &, _Args...>>()) operator()(_Args&&... __args) & noexcept(__is_nothrow_invocable<_Fn &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &, _Args...>>())) { return !std::__invoke(std::forward< _Fn & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &, _Args...>>()) operator()(_Args&&... __args) const & noexcept(__is_nothrow_invocable<_Fn const &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &, _Args...>>())) { return !std::__invoke(std::forward< _Fn const & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn &&, _Args...>>()) operator()(_Args&&... __args) && noexcept(__is_nothrow_invocable<_Fn &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn && >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> decltype(_S_not<__inv_res_t<_Fn const &&, _Args...>>()) operator()(_Args&&... __args) const && noexcept(__is_nothrow_invocable<_Fn const &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn const && >(_M_fn), std::forward<_Args>(__args)...); }


    private:
      _Fn _M_fn;
    };

  template<typename _Tp, typename _Pred>
    struct __is_byte_like : false_type { };

  template<typename _Tp>
    struct __is_byte_like<_Tp, equal_to<_Tp>>
    : __bool_constant<sizeof(_Tp) == 1 && is_integral<_Tp>::value> { };

  template<typename _Tp>
    struct __is_byte_like<_Tp, equal_to<void>>
    : __bool_constant<sizeof(_Tp) == 1 && is_integral<_Tp>::value> { };
# 1293 "/usr/include/c++/9/functional" 3

}
# 33 "../melder/melder.h" 2
# 1 "/usr/include/c++/9/memory" 1 3
# 46 "/usr/include/c++/9/memory" 3
       
# 47 "/usr/include/c++/9/memory" 3
# 64 "/usr/include/c++/9/memory" 3
# 1 "/usr/include/c++/9/bits/stl_construct.h" 1 3
# 63 "/usr/include/c++/9/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 87 "/usr/include/c++/9/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }
# 232 "/usr/include/c++/9/bits/stl_construct.h" 3

}
# 65 "/usr/include/c++/9/memory" 2 3
# 1 "/usr/include/c++/9/bits/stl_uninitialized.h" 1 3
# 67 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 113 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;





      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
   "result type must be constructible from value type of input range");

      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;


      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 185 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 254 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 396 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 828 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }

  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 903 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
  template<typename _Tp, typename _Up, typename _Allocator>
    inline void
    __relocate_object_a(_Tp* __dest, _Up* __orig, _Allocator& __alloc)
    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
    __dest, std::move(*__orig)))
      && noexcept(std::allocator_traits<_Allocator>::destroy(
       __alloc, std::__addressof(*__orig))))
    {
      typedef std::allocator_traits<_Allocator> __traits;
      __traits::construct(__alloc, __dest, std::move(*__orig));
      __traits::destroy(__alloc, std::__addressof(*__orig));
    }



  template<typename _Tp, typename = void>
    struct __is_bitwise_relocatable
    : is_trivial<_Tp> { };

  template <typename _Tp, typename _Up>
    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
    __relocate_a_1(_Tp* __first, _Tp* __last,
     _Tp* __result, allocator<_Up>&) noexcept
    {
      ptrdiff_t __count = __last - __first;
      if (__count > 0)
 __builtin_memmove(__result, __first, __count * sizeof(_Tp));
      return __result + __count;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
     _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
            std::addressof(*__first),
            __alloc)))
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;
      static_assert(std::is_same<_ValueType, _ValueType2>::value,
   "relocation is only possible for values of the same type");
      _ForwardIterator __cur = __result;
      for (; __first != __last; ++__first, (void)++__cur)
 std::__relocate_object_a(std::__addressof(*__cur),
     std::__addressof(*__first), __alloc);
      return __cur;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a(_InputIterator __first, _InputIterator __last,
   _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
         std::__niter_base(__last),
         std::__niter_base(__result), __alloc)))
    {
      return __relocate_a_1(std::__niter_base(__first),
       std::__niter_base(__last),
       std::__niter_base(__result), __alloc);
    }



}
# 66 "/usr/include/c++/9/memory" 2 3
# 1 "/usr/include/c++/9/bits/stl_tempbuf.h" 1 3
# 62 "/usr/include/c++/9/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 83 "/usr/include/c++/9/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/include/c++/9/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __seed, size_type __original_len);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "/usr/include/c++/9/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __seed, size_type __original_len)
    : _M_original_len(__original_len), _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __seed);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 67 "/usr/include/c++/9/memory" 2 3
# 1 "/usr/include/c++/9/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/include/c++/9/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }




      raw_storage_iterator&
      operator=(_Tp&& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), std::move(__element));
 return *this;
      }


      raw_storage_iterator&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator
      operator++(int)
      {
 raw_storage_iterator __tmp = *this;
 ++_M_iter;
 return __tmp;
      }



      _OutputIterator base() const { return _M_iter; }
    };


}
# 68 "/usr/include/c++/9/memory" 2 3






# 1 "/usr/include/c++/9/ext/concurrence.h" 1 3
# 32 "/usr/include/c++/9/ext/concurrence.h" 3
       
# 33 "/usr/include/c++/9/ext/concurrence.h" 3







namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;






  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
# 144 "/usr/include/c++/9/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
# 199 "/usr/include/c++/9/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } };




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
# 277 "/usr/include/c++/9/ext/concurrence.h" 3
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}
# 75 "/usr/include/c++/9/memory" 2 3





# 1 "/usr/include/c++/9/bits/unique_ptr.h" 1 3
# 41 "/usr/include/c++/9/bits/unique_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 104 "/usr/include/c++/9/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };

  template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
      template <typename _Up, typename _Ep, typename = void>
 struct _Ptr
 {
   using type = _Up*;
 };

      template <typename _Up, typename _Ep>
 struct
 _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
 {
   using type = typename remove_reference<_Ep>::type::pointer;
 };

    public:
      using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>,
        is_default_constructible<_Dp>>::value>;

      using pointer = typename _Ptr<_Tp, _Dp>::type;

      static_assert( !is_rvalue_reference<_Dp>::value,
       "unique_ptr's deleter type must be a function object type"
       " or an lvalue reference type" );

      __uniq_ptr_impl() = default;
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

      template<typename _Del>
      __uniq_ptr_impl(pointer __p, _Del&& __d)
 : _M_t(__p, std::forward<_Del>(__d)) { }

      pointer& _M_ptr() { return std::get<0>(_M_t); }
      pointer _M_ptr() const { return std::get<0>(_M_t); }
      _Dp& _M_deleter() { return std::get<1>(_M_t); }
      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }

    private:
      tuple<pointer, _Dp> _M_t;
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      template <typename _Up>
 using _DeleterConstraint =
   typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_impl<_Tp, _Dp> _M_t;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;

    private:


      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
        >;

    public:



      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }







      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 explicit
 unique_ptr(pointer __p) noexcept
 : _M_t(__p)
        { }
# 214 "/usr/include/c++/9/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_copy_constructible<_Del>>>
 unique_ptr(pointer __p, const deleter_type& __d) noexcept
 : _M_t(__p, __d) { }
# 226 "/usr/include/c++/9/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_move_constructible<_Del>>>
 unique_ptr(pointer __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(__p, std::move(__d))
 { }

      template<typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type>
 unique_ptr(pointer,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
 { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;
#pragma GCC diagnostic pop



      ~unique_ptr() noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(std::move(__ptr));
 __ptr = pointer();
      }
# 296 "/usr/include/c++/9/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 311 "/usr/include/c++/9/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 _M_t._M_ptr() = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 using std::swap;
 swap(_M_t._M_ptr(), __p);
 if (__p != pointer())
   get_deleter()(std::move(__p));
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {
      template <typename _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_impl<_Tp, _Dp> _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep,
               typename _UPtr = unique_ptr<_Up, _Ep>,
        typename _UP_pointer = typename _UPtr::pointer,
        typename _UP_element_type = typename _UPtr::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<_UP_pointer, _UP_element_type*>,
          is_convertible<_UP_element_type(*)[], element_type(*)[]>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }
# 479 "/usr/include/c++/9/bits/unique_ptr.h" 3
      template<typename _Up,
        typename _Vp = _Dp,
        typename = _DeleterConstraint<_Vp>,
        typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
 explicit
 unique_ptr(_Up __p) noexcept
 : _M_t(__p)
        { }
# 497 "/usr/include/c++/9/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_copy_constructible<_Del>>>
      unique_ptr(_Up __p, const deleter_type& __d) noexcept
      : _M_t(__p, __d) { }
# 511 "/usr/include/c++/9/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_move_constructible<_Del>>>
 unique_ptr(_Up __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(std::move(__p), std::move(__d))
 { }

      template<typename _Up, typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type,
        typename = _Require<__safe_conversion_raw<_Up>>>
 unique_ptr(_Up,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
        { }

      template<typename _Up, typename _Ep, typename = _Require<
        __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 563 "/usr/include/c++/9/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 578 "/usr/include/c++/9/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 _M_t._M_ptr() = pointer();
 return __p;
      }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      {
 pointer __ptr = __p;
 using std::swap;
 swap(_M_t._M_ptr(), __ptr);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
      }

      void reset(nullptr_t = nullptr) noexcept
      {
        reset(pointer());
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline


    typename enable_if<__is_swappable<_Dp>::value>::type



    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }


  template<typename _Tp, typename _Dp>
    typename enable_if<!__is_swappable<_Dp>::value>::type
    swap(unique_ptr<_Tp, _Dp>&,
  unique_ptr<_Tp, _Dp>&) = delete;


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
    private __poison_hash<typename unique_ptr<_Tp, _Dp>::pointer>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;
# 879 "/usr/include/c++/9/bits/unique_ptr.h" 3

}
# 81 "/usr/include/c++/9/memory" 2 3
# 1 "/usr/include/c++/9/bits/shared_ptr.h" 1 3
# 52 "/usr/include/c++/9/bits/shared_ptr.h" 3
# 1 "/usr/include/c++/9/bits/shared_ptr_base.h" 1 3
# 53 "/usr/include/c++/9/bits/shared_ptr_base.h" 3
# 1 "/usr/include/c++/9/bits/allocated_ptr.h" 1 3
# 40 "/usr/include/c++/9/bits/allocated_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return std::__to_address(_M_ptr); }

    private:
      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}
# 54 "/usr/include/c++/9/bits/shared_ptr_base.h" 2 3


# 1 "/usr/include/c++/9/ext/aligned_buffer.h" 1 3
# 32 "/usr/include/c++/9/ext/aligned_buffer.h" 3
       
# 33 "/usr/include/c++/9/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {





      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
# 89 "/usr/include/c++/9/ext/aligned_buffer.h" 3
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
    {
      typename
 std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };


}
# 57 "/usr/include/c++/9/bits/shared_ptr_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const* what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      bool
      _M_add_ref_lock_nothrow();

      void
      _M_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
            ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
  __atomic_thread_fence (4);
       }


            ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
            ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


  __atomic_thread_fence (4);
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (_M_use_count == 0)
 __throw_bad_weak_ptr();
      ++_M_use_count;
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     __throw_bad_weak_ptr();


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
    }

  template<>
    inline bool
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock_nothrow()
    {
      if (_M_use_count == 0)
 return false;
      ++_M_use_count;
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock_nothrow()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   return false;
 }
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock_nothrow()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     return false;


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
      return true;
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
        }
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
    { ++_M_weak_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
    {
      if (--_M_weak_count == 0)
        _M_destroy();
    }

  template<>
    inline long
    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
    { return _M_use_count; }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    private:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }

  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Sp_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, false>
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
 typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

      public:
 _Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 : _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)
 { }

 _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

 _Ptr _M_ptr;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;


      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, std::move(__d), _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, std::move(__d), __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_impl._M_del()(_M_impl._M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_deleter();
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {



        return __ti == typeid(_Deleter)
   ? std::__addressof(_M_impl._M_del())
   : nullptr;



      }

    private:
      _Impl _M_impl;
    };



  struct _Sp_make_shared_tag
  {
  private:
    template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
      friend class _Sp_counted_ptr_inplace;

    static const type_info&
    _S_ti() noexcept __attribute__ ((__visibility__ ("default")))
    {
      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };
      return reinterpret_cast<const type_info&>(__tag);
    }

    static bool _S_eq(const type_info&) noexcept;
  };

  template<typename _Alloc>
    struct _Sp_alloc_shared_tag
    {
      const _Alloc& _M_a;
    };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Alloc> _A_base;

      public:
 explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }

 _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }

 __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;


      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {


   allocator_traits<_Alloc>::construct(__a, _M_ptr(),
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      {
 allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
      }


      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_ptr_inplace();
      }

    private:
      friend class __shared_count<_Lp>;



      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept override
      {
 auto __ptr = const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());




 if (&__ti == &_Sp_make_shared_tag::_S_ti()
     ||

     __ti == typeid(_Sp_make_shared_tag)



    )
   return __ptr;
 return nullptr;
      }

      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

      _Impl _M_impl;
    };


  struct __sp_array_delete
  {
    template<typename _Yp>
      void operator()(_Yp* __p) const { delete[] __p; }
  };

  template<_Lock_policy _Lp>
    class __shared_count
    {
      template<typename _Tp>
 struct __not_alloc_shared_tag { using type = void; };

      template<typename _Tp>
 struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };

    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr>
 __shared_count(_Ptr __p, false_type)
 : __shared_count(__p)
 { }

      template<typename _Ptr>
 __shared_count(_Ptr __p, true_type)
 : __shared_count(__p, __sp_array_delete{}, allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter,
        typename = typename __not_alloc_shared_tag<_Deleter>::type>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc,
        typename = typename __not_alloc_shared_tag<_Deleter>::type>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   try
     {
       typename _Sp_cd_type::__allocator_type __a2(__a);
       auto __guard = std::__allocate_guarded(__a2);
       _Sp_cd_type* __mem = __guard.get();
       ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
       _M_pi = __mem;
       __guard = nullptr;
     }
   catch(...)
     {
       __d(__p);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,
         _Args&&... __args)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
   auto __guard = std::__allocate_guarded(__a2);
   _Sp_cp_type* __mem = __guard.get();
   auto __pi = ::new (__mem)
     _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
   __guard = nullptr;
   _M_pi = __pi;
   __p = __pi->_M_ptr();
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);
#pragma GCC diagnostic pop



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {


   if (__r.get() == nullptr)
     return;

   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
   _Alloc_traits::construct(__a, __mem, __r.release(),
       __r.get_deleter());
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);


      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(nullptr)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(__weak_count&& __r) noexcept
      : _M_pi(__r._M_pi)
      { __r._M_pi = nullptr; }

      ~__weak_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
      }

      __weak_count&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(const __weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(__weak_count&& __r) noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __r._M_pi;
        __r._M_pi = nullptr;
 return *this;
      }

      void
      _M_swap(__weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 if (!_M_pi->_M_add_ref_lock_nothrow())
   _M_pi = nullptr;
    }







  template<typename _Yp_ptr, typename _Tp_ptr>
    struct __sp_compatible_with
    : false_type
    { };

  template<typename _Yp, typename _Tp>
    struct __sp_compatible_with<_Yp*, _Tp*>
    : is_convertible<_Yp*, _Tp*>::type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>
    : true_type
    { };


  template<typename _Up, size_t _Nm, typename _Yp, typename = void>
    struct __sp_is_constructible_arrN
    : false_type
    { };

  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>
    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type
    { };


  template<typename _Up, typename _Yp, typename = void>
    struct __sp_is_constructible_arr
    : false_type
    { };

  template<typename _Up, typename _Yp>
    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>
    : is_convertible<_Yp(*)[], _Up(*)[]>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible;


  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible<_Up[_Nm], _Yp>
    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type
    { };


  template<typename _Up, typename _Yp>
    struct __sp_is_constructible<_Up[], _Yp>
    : __sp_is_constructible_arr<_Up, _Yp>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible
    : is_convertible<_Yp*, _Tp*>::type
    { };



  template<typename _Tp, _Lock_policy _Lp,
    bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>
    class __shared_ptr_access
    {
    public:
      using element_type = _Tp;

      element_type&
      operator*() const noexcept
      {
 ;
 return *_M_get();
      }

      element_type*
      operator->() const noexcept
      {
 ;
 return _M_get();
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, false, true>
    {
    public:
      using element_type = _Tp;

      element_type*
      operator->() const noexcept
      {
 auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get();
 ;
 return __ptr;
      }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, true, false>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;


      [[__deprecated__("shared_ptr<T[]>::operator* is absent from C++17")]]
      element_type&
      operator*() const noexcept
      {
 ;
 return *_M_get();
      }

      [[__deprecated__("shared_ptr<T[]>::operator-> is absent from C++17")]]
      element_type*
      operator->() const noexcept
      {
 ;
 return _M_get();
      }


      element_type&
      operator[](ptrdiff_t __i) const
      {
 ;
 ;
 return _M_get()[__i];
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    : public __shared_ptr_access<_Tp, _Lp>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;

    private:

      template<typename _Yp>
 using _SafeConv
   = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;


      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __shared_ptr&>;


      template<typename _Yp, typename _Del, typename _Res = void,
        typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>
 using _UniqCompatible = typename enable_if<__and_<
   __sp_compatible_with<_Yp*, _Tp*>, is_convertible<_Ptr, element_type*>
   >::value, _Res>::type;


      template<typename _Yp, typename _Del>
 using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;

    public:





      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Yp, typename = _SafeConv<_Yp>>
 explicit
 __shared_ptr(_Yp* __p)
 : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 {
   static_assert( !is_void<_Yp>::value, "incomplete type" );
   static_assert( sizeof(_Yp) > 0, "incomplete type" );
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, std::move(__d))
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))
 { }

      template<typename _Yp>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      template<typename _Yp, typename = _Compatible<_Yp>>
 explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {


   _M_ptr = __r._M_ptr;
 }


      template<typename _Yp, typename _Del,
        typename = _UniqCompatible<_Yp, _Del>>
 __shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = __to_address(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }


    protected:

      template<typename _Tp1, typename _Del,
        typename enable_if<__and_<
   __not_<is_array<_Tp>>, is_array<_Tp1>,
          is_convertible<typename unique_ptr<_Tp1, _Del>::pointer, _Tp*>
        >::value, bool>::type = true>
 __shared_ptr(unique_ptr<_Tp1, _Del>&& __r, __sp_array_delete)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = __to_address(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }
    public:



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(auto_ptr<_Yp>&& __r);
#pragma GCC diagnostic pop


      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp>
 _Assignable<_Yp>
 operator=(auto_ptr<_Yp>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }
#pragma GCC diagnostic pop


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Yp>
 _Assignable<_Yp>
 operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Yp, typename _Del>
 _UniqAssignable<_Yp, _Del>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Yp>
 _SafeConv<_Yp>
 reset(_Yp* __p)
 {

   ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Yp, typename _Deleter>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d)
 { __shared_ptr(__p, std::move(__d)).swap(*this); }

      template<typename _Yp, typename _Deleter, typename _Alloc>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }

      element_type*
      get() const noexcept
      { return _M_ptr; }

      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }

      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }

      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 : _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
 { _M_enable_shared_from_this_with(_M_ptr); }

      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);



      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)
      : _M_refcount(__r._M_refcount, std::nothrow)
      {
 _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
      }

      friend class __weak_ptr<_Tp, _Lp>;

    private:

      template<typename _Yp>
 using __esft_base_t = decltype(__enable_shared_from_this_base(
       std::declval<const __shared_count<_Lp>&>(),
       std::declval<_Yp*>()));


      template<typename _Yp, typename = void>
 struct __has_esft_base
 : false_type { };

      template<typename _Yp>
 struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
 : __not_<is_array<_Tp>> { };

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp* __p) noexcept
 {
   if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
     __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
 }

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<!__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp*) noexcept
 { }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      template<typename _Del, typename _Tp1>
 friend _Del* get_deleter(const shared_ptr<_Tp1>&) noexcept;

      element_type* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a,
       const __shared_ptr<_Up, _Lp>& __b) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      using _Up_elt = typename __shared_ptr<_Up, _Lp>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
# 1530 "/usr/include/c++/9/bits/shared_ptr_base.h" 3
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }
# 1576 "/usr/include/c++/9/bits/shared_ptr_base.h" 3
  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __weak_ptr&>;

    public:
      using element_type = typename remove_extent<_Tp>::type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(nullptr), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;

      ~__weak_ptr() = default;
# 1612 "/usr/include/c++/9/bits/shared_ptr_base.h" 3
      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __weak_ptr(__weak_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
      { __r._M_ptr = nullptr; }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
        { __r._M_ptr = nullptr; }

      __weak_ptr&
      operator=(const __weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __weak_ptr&
      operator=(__weak_ptr&& __r) noexcept
      {
 _M_ptr = __r._M_ptr;
 _M_refcount = std::move(__r._M_refcount);
 __r._M_ptr = nullptr;
 return *this;
      }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = std::move(__r._M_refcount);
   __r._M_ptr = nullptr;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 if (use_count() == 0)
   {
     _M_ptr = __ptr;
     _M_refcount = __refcount;
   }
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      element_type* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }
    };

  template<>
    struct _Sp_owner_less<void, void>
    {
      template<typename _Tp, typename _Up>
 auto
 operator()(const _Tp& __lhs, const _Up& __rhs) const noexcept
 -> decltype(__lhs.owner_before(__rhs))
 { return __lhs.owner_before(__rhs); }

      using is_transparent = void;
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }


      __weak_ptr<_Tp, _Lp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      __weak_ptr<const _Tp, _Lp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      friend const __enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<_Lp>&,
         const __enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy,
    typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy,
    typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      {
 return hash<typename __shared_ptr<_Tp, _Lp>::element_type*>()(
     __s.get());
      }
    };


}
# 53 "/usr/include/c++/9/bits/shared_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }

  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }


  template<typename _Del, typename _Tp>
    inline _Del*
    get_deleter(const shared_ptr<_Tp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }







  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
      template<typename... _Args>
 using _Constructible = typename enable_if<
   is_constructible<__shared_ptr<_Tp>, _Args...>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__shared_ptr<_Tp>&, _Arg>::value, shared_ptr&
 >::type;

    public:

      using element_type = typename __shared_ptr<_Tp>::element_type;
# 127 "/usr/include/c++/9/bits/shared_ptr.h" 3
      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Yp, typename = _Constructible<_Yp*>>
 explicit
 shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }
# 154 "/usr/include/c++/9/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter,
        typename = _Constructible<_Yp*, _Deleter>>
 shared_ptr(_Yp* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 172 "/usr/include/c++/9/bits/shared_ptr.h" 3
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 191 "/usr/include/c++/9/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _Constructible<_Yp*, _Deleter, _Alloc>>
 shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 211 "/usr/include/c++/9/bits/shared_ptr.h" 3
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 233 "/usr/include/c++/9/bits/shared_ptr.h" 3
      template<typename _Yp>
 shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
# 244 "/usr/include/c++/9/bits/shared_ptr.h" 3
      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>
 shared_ptr(shared_ptr<_Yp>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 274 "/usr/include/c++/9/bits/shared_ptr.h" 3
      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 explicit shared_ptr(const weak_ptr<_Yp>& __r)
 : __shared_ptr<_Tp>(__r) { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>
 shared_ptr(auto_ptr<_Yp>&& __r);
#pragma GCC diagnostic pop




      template<typename _Yp, typename _Del,
        typename = _Constructible<unique_ptr<_Yp, _Del>>>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }





      template<typename _Yp, typename _Del,
  _Constructible<unique_ptr<_Yp, _Del>, __sp_array_delete>* = 0>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r), __sp_array_delete()) { }






      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp>
 _Assignable<auto_ptr<_Yp>>
 operator=(auto_ptr<_Yp>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }
#pragma GCC diagnostic pop


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Yp>
 _Assignable<shared_ptr<_Yp>>
 operator=(shared_ptr<_Yp>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Yp, typename _Del>
 _Assignable<unique_ptr<_Yp, _Del>>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, std::forward<_Args>(__args)...)
 { }

      template<typename _Yp, typename _Alloc, typename... _Args>
 friend shared_ptr<_Yp>
 allocate_shared(const _Alloc& __a, _Args&&... __args);


      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)
      : __shared_ptr<_Tp>(__r, std::nothrow) { }

      friend class weak_ptr<_Tp>;
    };
# 381 "/usr/include/c++/9/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Up>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp>
    inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }

  template<typename _Tp, typename _Up>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp>
    inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      using _Up_elt = typename shared_ptr<_Up>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp>
    inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp, typename _Up>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, typename _Up>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp>
    inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp, typename _Up>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp>
    inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }


  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }

  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }

  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }
# 530 "/usr/include/c++/9/bits/shared_ptr.h" 3
  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
      template<typename _Arg>
 using _Constructible = typename enable_if<
   is_constructible<__weak_ptr<_Tp>, _Arg>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__weak_ptr<_Tp>&, _Arg>::value, weak_ptr&
 >::type;

    public:
      constexpr weak_ptr() noexcept = default;

      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 weak_ptr(const shared_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(const weak_ptr&) noexcept = default;

      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 weak_ptr(const weak_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(weak_ptr&&) noexcept = default;

      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>
 weak_ptr(weak_ptr<_Yp>&& __r) noexcept
 : __weak_ptr<_Tp>(std::move(__r)) { }

      weak_ptr&
      operator=(const weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<const weak_ptr<_Yp>&>
 operator=(const weak_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      weak_ptr&
      operator=(weak_ptr&& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<weak_ptr<_Yp>>
 operator=(weak_ptr<_Yp>&& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      { return shared_ptr<_Tp>(*this, std::nothrow); }
    };







  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp = void>
    struct owner_less;


  template<>
    struct owner_less<void> : _Sp_owner_less<void, void>
    { };


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }



      weak_ptr<_Tp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      weak_ptr<const _Tp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }


      friend const enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<>&,
         const enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable weak_ptr<_Tp> _M_weak_this;
    };
# 697 "/usr/include/c++/9/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
        std::forward<_Args>(__args)...);
    }
# 712 "/usr/include/c++/9/bits/shared_ptr.h" 3
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_cv<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      {
 return std::hash<typename shared_ptr<_Tp>::element_type*>()(__s.get());
      }
    };
# 756 "/usr/include/c++/9/bits/shared_ptr.h" 3

}
# 82 "/usr/include/c++/9/memory" 2 3
# 1 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 1 3
# 33 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
# 1 "/usr/include/c++/9/bits/atomic_base.h" 1 3
# 33 "/usr/include/c++/9/bits/atomic_base.h" 3
       
# 34 "/usr/include/c++/9/bits/atomic_base.h" 3



# 1 "/usr/include/c++/9/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/include/c++/9/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/include/c++/9/bits/atomic_lockfree_defines.h" 3
# 38 "/usr/include/c++/9/bits/atomic_base.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 73 "/usr/include/c++/9/bits/atomic_base.h" 3
  typedef enum memory_order
    {
      memory_order_relaxed,
      memory_order_consume,
      memory_order_acquire,
      memory_order_release,
      memory_order_acq_rel,
      memory_order_seq_cst
    } memory_order;


  enum __memory_order_modifier
    {
      __memory_order_mask = 0x0ffff,
      __memory_order_modifier_mask = 0xffff0000,
      __memory_order_hle_acquire = 0x10000,
      __memory_order_hle_release = 0x20000
    };

  constexpr memory_order
  operator|(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(int(__m) | int(__mod));
  }

  constexpr memory_order
  operator&(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(int(__m) & int(__mod));
  }


  constexpr memory_order
  __cmpexch_failure_order2(memory_order __m) noexcept
  {
    return __m == memory_order_acq_rel ? memory_order_acquire
      : __m == memory_order_release ? memory_order_relaxed : __m;
  }

  constexpr memory_order
  __cmpexch_failure_order(memory_order __m) noexcept
  {
    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
      | __memory_order_modifier(__m & __memory_order_modifier_mask));
  }

  inline __attribute__((__always_inline__)) void
  atomic_thread_fence(memory_order __m) noexcept
  { __atomic_thread_fence(int(__m)); }

  inline __attribute__((__always_inline__)) void
  atomic_signal_fence(memory_order __m) noexcept
  { __atomic_signal_fence(int(__m)); }


  template<typename _Tp>
    inline _Tp
    kill_dependency(_Tp __y) noexcept
    {
      _Tp __ret(__y);
      return __ret;
    }



  template<typename _IntTp>
    struct __atomic_base;




  template<typename _Tp>
    struct atomic;

  template<typename _Tp>
    struct atomic<_Tp*>;



    typedef bool __atomic_flag_data_type;
# 167 "/usr/include/c++/9/bits/atomic_base.h" 3
  extern "C" {

  struct __atomic_flag_base
  {
    __atomic_flag_data_type _M_i;
  };

  }




  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;


    constexpr atomic_flag(bool __i) noexcept
      : __atomic_flag_base{ _S_init(__i) }
    { }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) noexcept
    {
      return __atomic_test_and_set (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      return __atomic_test_and_set (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) noexcept
    {
      memory_order __b = __m & __memory_order_mask;
      ;
      ;
      ;

      __atomic_clear (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      memory_order __b = __m & __memory_order_mask;
      ;
      ;
      ;

      __atomic_clear (&_M_i, int(__m));
    }

  private:
    static constexpr __atomic_flag_data_type
    _S_init(bool __i)
    { return __i ? 1 : 0; }
  };
# 257 "/usr/include/c++/9/bits/atomic_base.h" 3
  template<typename _ITp>
    struct __atomic_base
    {
      using value_type = _ITp;
      using difference_type = value_type;

    private:
      typedef _ITp __int_type;

      static constexpr int _S_alignment =
 sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);

      alignas(_S_alignment) __int_type _M_i;

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }

      operator __int_type() const noexcept
      { return load(); }

      operator __int_type() const volatile noexcept
      { return load(); }

      __int_type
      operator=(__int_type __i) noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator=(__int_type __i) volatile noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __int_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __int_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __int_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __int_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator+=(__int_type __i) noexcept
      { return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator+=(__int_type __i) volatile noexcept
      { return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator-=(__int_type __i) noexcept
      { return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator-=(__int_type __i) volatile noexcept
      { return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator&=(__int_type __i) noexcept
      { return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator&=(__int_type __i) volatile noexcept
      { return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator|=(__int_type __i) noexcept
      { return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator|=(__int_type __i) volatile noexcept
      { return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator^=(__int_type __i) noexcept
      { return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator^=(__int_type __i) volatile noexcept
      { return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-_S_alignment));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-_S_alignment));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, int(__m));
      }


      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
   memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }
    };



  template<typename _PTp>
    struct __atomic_base<_PTp*>
    {
    private:
      typedef _PTp* __pointer_type;

      __pointer_type _M_p;


      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }

      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }

      operator __pointer_type() const noexcept
      { return load(); }

      operator __pointer_type() const volatile noexcept
      { return load(); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __pointer_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __pointer_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      {
        memory_order __b = __m & __memory_order_mask;

 ;
 ;
 ;

 __atomic_store_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, int(__m));
      }


      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }
    };




}
# 34 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  struct _Sp_locker
  {
    _Sp_locker(const _Sp_locker&) = delete;
    _Sp_locker& operator=(const _Sp_locker&) = delete;


    explicit
    _Sp_locker(const void*) noexcept;
    _Sp_locker(const void*, const void*) noexcept;
    ~_Sp_locker();

  private:
    unsigned char _M_key1;
    unsigned char _M_key2;



  };







  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)
    {

      return __gthread_active_p() == 0;



    }

  template<typename _Tp>
    inline bool
    atomic_is_lock_free(const shared_ptr<_Tp>* __p)
    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
# 96 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load(const shared_ptr<_Tp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
# 132 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline void
    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp>
    inline void
    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
# 169 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,
        __shared_ptr<_Tp, _Lp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }
# 218 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,
         shared_ptr<_Tp>* __v,
         shared_ptr<_Tp> __w,
         memory_order,
         memory_order)
    {
      shared_ptr<_Tp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<shared_ptr<_Tp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,
       shared_ptr<_Tp>* __v,
       shared_ptr<_Tp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    bool
    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,
         __shared_ptr<_Tp, _Lp>* __v,
         __shared_ptr<_Tp, _Lp> __w,
         memory_order,
         memory_order)
    {
      __shared_ptr<_Tp, _Lp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<__shared_ptr<_Tp, _Lp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp>* __v,
     __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }





}
# 83 "/usr/include/c++/9/memory" 2 3

# 1 "/usr/include/c++/9/backward/auto_ptr.h" 1 3
# 36 "/usr/include/c++/9/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/usr/include/c++/9/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 88 "/usr/include/c++/9/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 114 "/usr/include/c++/9/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 126 "/usr/include/c++/9/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 137 "/usr/include/c++/9/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 154 "/usr/include/c++/9/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 172 "/usr/include/c++/9/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 182 "/usr/include/c++/9/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 212 "/usr/include/c++/9/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 226 "/usr/include/c++/9/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 241 "/usr/include/c++/9/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 266 "/usr/include/c++/9/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1, typename>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {
     
      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      _M_enable_shared_from_this_with(__tmp);
    }

  template<typename _Tp>
  template<typename _Tp1, typename>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }


#pragma GCC diagnostic pop


}
# 85 "/usr/include/c++/9/memory" 2 3
# 97 "/usr/include/c++/9/memory" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 117 "/usr/include/c++/9/memory" 3
inline void*
align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
{

  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);






  const auto __aligned = (__intptr - 1u + __align) & -__align;
  const auto __diff = __aligned - __intptr;
  if ((__size + __diff) > __space)
    return nullptr;
  else
    {
      __space -= __diff;
      return __ptr = reinterpret_cast<void*>(__aligned);
    }
}



enum class pointer_safety { relaxed, preferred, strict };

inline void
declare_reachable(void*) { }

template <typename _Tp>
  inline _Tp*
  undeclare_reachable(_Tp* __p) { return __p; }

inline void
declare_no_pointers(char*, size_t) { }

inline void
undeclare_no_pointers(char*, size_t) { }

inline pointer_safety
get_pointer_safety() noexcept { return pointer_safety::relaxed; }
# 365 "/usr/include/c++/9/memory" 3

}
# 34 "../melder/melder.h" 2

# 1 "/usr/include/c++/9/algorithm" 1 3
# 58 "/usr/include/c++/9/algorithm" 3
       
# 59 "/usr/include/c++/9/algorithm" 3



# 1 "/usr/include/c++/9/bits/stl_algo.h" 1 3
# 59 "/usr/include/c++/9/bits/stl_algo.h" 3
# 1 "/usr/include/c++/9/cstdlib" 1 3
# 39 "/usr/include/c++/9/cstdlib" 3
       
# 40 "/usr/include/c++/9/cstdlib" 3
# 60 "/usr/include/c++/9/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/9/bits/algorithmfwd.h" 1 3
# 33 "/usr/include/c++/9/bits/algorithmfwd.h" 3
       
# 34 "/usr/include/c++/9/bits/algorithmfwd.h" 3
# 42 "/usr/include/c++/9/bits/algorithmfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 195 "/usr/include/c++/9/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);
# 224 "/usr/include/c++/9/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 565 "/usr/include/c++/9/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 594 "/usr/include/c++/9/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);



  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);



}
# 61 "/usr/include/c++/9/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/9/bits/stl_heap.h" 1 3
# 62 "/usr/include/c++/9/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare& __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return std::__is_heap_until(__first, __n, __comp) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __n, __cmp) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      return std::__is_heap(__first, std::move(__comp),
       std::distance(__first, __last));
    }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare& __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 152 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_val __comp;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
# 187 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;
      ;

      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 269 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   __gnu_cxx::__ops::_Iter_less_iter __comp;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 302 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   typedef __decltype(__comp) _Cmp;
   __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
   --__last;
   std::__pop_heap(__first, __last, __last, __cmp);
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 358 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__make_heap(__first, __last, __comp);
    }
# 384 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__make_heap(__first, __last, __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 420 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__sort_heap(__first, __last, __comp);
    }
# 447 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__sort_heap(__first, __last, __cmp);
    }
# 475 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last), __comp);
    }
# 503 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
    }
# 527 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 540 "/usr/include/c++/9/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    {

     

      ;
      ;

      const auto __dist = std::distance(__first, __last);
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __dist, __cmp) == __dist;
    }



}
# 62 "/usr/include/c++/9/bits/stl_algo.h" 2 3




# 1 "/usr/include/c++/9/bits/uniform_int_dist.h" 1 3
# 35 "/usr/include/c++/9/bits/uniform_int_dist.h" 3
# 1 "/usr/include/c++/9/limits" 1 3
# 40 "/usr/include/c++/9/limits" 3
       
# 41 "/usr/include/c++/9/limits" 3
# 158 "/usr/include/c++/9/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/9/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/9/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/9/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/usr/include/c++/9/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 796 "/usr/include/c++/9/limits" 3
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1636 "/usr/include/c++/9/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1659 "/usr/include/c++/9/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "/usr/include/c++/9/bits/uniform_int_dist.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      }
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument must be an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 param_type() : param_type(0) { }

 explicit
 param_type(_IntType __a,
     _IntType __b = numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

 friend bool
 operator!=(const param_type& __p1, const param_type& __p2)
 { return !(__p1 == __p2); }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      uniform_int_distribution() : uniform_int_distribution(0) { }




      explicit
      uniform_int_distribution(_IntType __a,
          _IntType __b = numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 271 "/usr/include/c++/9/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 355 "/usr/include/c++/9/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }




}
# 67 "/usr/include/c++/9/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, (void) ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      if (__first == __last)
 return true;
      ++__first;
      return std::none_of(__first, __last, __pred);
    }
# 601 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 668 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 700 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 734 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 797 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 825 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 894 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 927 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 993 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1023 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     

     


      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     


      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1178 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1205 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1432 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1469 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1546 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      return std::rotate(__left_split, __middle, __right_split);
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType>
 __buf(__first, std::distance(__first, __last));
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1648 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1734 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1748 "/usr/include/c++/9/bits/stl_algo.h" 3
     
     

     

     
      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1783 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1799 "/usr/include/c++/9/bits/stl_algo.h" 3
     
     

     

     

     

      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2020 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2074 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2104 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2175 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

     

      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2211 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     

     
                    ;
     
                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2244 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {

     
     

      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2277 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;
     
                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 return std::rotate(__first, __middle, __last);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      _BidirectionalIterator __new_middle
 = std::rotate(__first_cut, __middle, __second_cut);
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __len1 + __len2);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2566 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2607 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2779 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2818 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2862 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2897 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2946 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2978 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3046 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3078 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3128 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3162 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3201 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3215 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3244 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3268 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3293 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3314 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3394 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3422 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3534 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3565 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3658 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3685 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3761 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _IntType, typename _UniformRandomBitGenerator>
    pair<_IntType, _IntType>
    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
      _UniformRandomBitGenerator&& __g)
    {
      _IntType __x
 = uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
      return std::make_pair(__x / __b1, __x % __b1);
    }
# 3783 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;

      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
 _Gen;
      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
 __uc_type;

      const __uc_type __urngrange = __g.max() - __g.min();
      const __uc_type __urange = __uc_type(__last - __first);

      if (__urngrange / __urange >= __urange)

      {
 _RandomAccessIterator __i = __first + 1;





 if ((__urange % 2) == 0)
 {
   __distr_type __d{0, 1};
   std::iter_swap(__i++, __first + __d(__g));
 }





 while (__i != __last)
 {
   const __uc_type __swap_range = __uc_type(__i - __first) + 1;

   const pair<__uc_type, __uc_type> __pospos =
     __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

   std::iter_swap(__i++, __first + __pospos.first);
   std::iter_swap(__i++, __first + __pospos.second);
 }

 return;
      }

      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }





# 3868 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 3926 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3950 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3981 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4021 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4053 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4078 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 4103 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 4126 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4166 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4205 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4240 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4273 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4321 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4358 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4391 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4423 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4455 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4486 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, (void) ++__first)
 *__first = __gen();
      return __first;
    }
# 4522 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4562 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4595 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4630 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4670 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4703 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4741 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4777 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4816 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {

     

     


      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4853 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4883 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4944 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4994 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, std::distance(__first, __last));

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5058 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 5092 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5161 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5211 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5282 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5331 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5404 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5455 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5534 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5585 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5638 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5663 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5702 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5727 "/usr/include/c++/9/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
           typename _Size, typename _UniformRandomBitGenerator>
    _RandomAccessIterator
    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
      _RandomAccessIterator __out, random_access_iterator_tag,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      __distrib_type __d{};
      _Size __sample_sz = 0;
      while (__first != __last && __sample_sz != __n)
 {
   __out[__sample_sz++] = *__first;
   ++__first;
 }
      for (auto __pop_sz = __sample_sz; __first != __last;
   ++__first, (void) ++__pop_sz)
 {
   const auto __k = __d(__g, __param_type{0, __pop_sz});
   if (__k < __n)
     __out[__k] = *__first;
 }
      return __out + __sample_sz;
    }


  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
           typename _Size, typename _UniformRandomBitGenerator>
    _OutputIterator
    __sample(_ForwardIterator __first, _ForwardIterator __last,
      forward_iterator_tag,
      _OutputIterator __out, _Cat,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      using _USize = make_unsigned_t<_Size>;
      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;

      __distrib_type __d{};
      _Size __unsampled_sz = std::distance(__first, __last);
      __n = std::min(__n, __unsampled_sz);




      const __uc_type __urngrange = __g.max() - __g.min();
      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))


        {
   while (__n != 0 && __unsampled_sz >= 2)
     {
       const pair<_Size, _Size> __p =
  __gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);

       --__unsampled_sz;
       if (__p.first < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;

       if (__n == 0) break;

       --__unsampled_sz;
       if (__p.second < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;
     }
        }



      for (; __n != 0; ++__first)
 if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
   {
     *__out++ = *__first;
     --__n;
   }
      return __out;
    }
# 5870 "/usr/include/c++/9/bits/stl_algo.h" 3


}
# 63 "/usr/include/c++/9/algorithm" 2 3
# 36 "../melder/melder.h" 2
# 49 "../melder/melder.h"
# 1 "../melder/melder_assert.h" 1
# 32 "../melder/melder_assert.h"

# 32 "../melder/melder_assert.h"
void Melder_assert_ (const char *fileName, int lineNumber, const char *condition);
# 50 "../melder/melder.h" 2
# 1 "../melder/melder_int.h" 1
# 27 "../melder/melder_int.h"
using byte = unsigned char;
using int8 = int8_t;
using int16 = int16_t;
using int32 = int32_t;
using int64 = int64_t;
using integer = intptr_t;
using long_not_integer = long;
using int_not_integer = int;
using uinteger = uintptr_t;
using uint8 = uint8_t;
using uint16 = uint16_t;
using uint32 = uint32_t;
using uint64 = uint64_t;
# 64 "../melder/melder_int.h"
inline static integer operator"" _integer (unsigned long long value) { return integer (value); }







inline static uinteger integer_to_uinteger (integer n) {
 ((n >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_int.h", 73, "n >= 0"), abort ()));
 return (uinteger) n;
}
inline static integer uinteger_to_integer (uinteger n) {
 ((n <= ( sizeof (integer) == 4 ? 
# 77 "../melder/melder_int.h" 3 4
(2147483647) 
# 77 "../melder/melder_int.h"
: 
# 77 "../melder/melder_int.h" 3 4
(9223372036854775807L) 
# 77 "../melder/melder_int.h"
)) ? (void) (0) : (Melder_assert_ ("../melder/melder_int.h", 77, "n <= INTEGER_MAX"), abort ()));
 return (integer) n;
}

inline static integer integer_abs (integer n) {
 ((sizeof (integer) == sizeof (long) || sizeof (integer) == sizeof (long long)) ? (void) (0) : (Melder_assert_ ("../melder/melder_int.h", 82, "sizeof (integer) == sizeof (long) || sizeof (integer) == sizeof (long long)"), abort ()));
 if (sizeof (integer) == sizeof (long))
  return labs (n);
 else
  return llabs (n);
}

struct MelderIntegerRange {
 integer first, last;
 bool isEmpty () { return ( last < first ); }
 integer size () {
  integer result = last - first + 1;
  return std::max (result, 0_integer);
 }
};

template <typename T>
void Melder_clipLeft (T minimum, T *var) {
 if (*var < minimum)
  *var = minimum;
}

template <typename T>
T Melder_clippedLeft (T minimum, T var) {
 return std::max (minimum, var);
}

template <typename T>
void Melder_clipRight (T *var, T maximum) {
 if (*var > maximum)
  *var = maximum;
}

template <typename T>
T Melder_clippedRight (T var, T maximum) {
 return std::min (var, maximum);
}

template <typename T>
void Melder_clip (T minimum, T *var, T maximum) {
 ((maximum >= minimum) ? (void) (0) : (Melder_assert_ ("../melder/melder_int.h", 122, "maximum >= minimum"), abort ()));
 if (*var < minimum)
  *var = minimum;
 else if (*var > maximum)
  *var = maximum;
}

template <typename T>
T Melder_clipped (T minimum, T var, T maximum) {
 ((maximum >= minimum) ? (void) (0) : (Melder_assert_ ("../melder/melder_int.h", 131, "maximum >= minimum"), abort ()));
 return std::max (minimum, std::min (var, maximum));
}

class kleenean {
 int _intValue;
public:
 static constexpr int UNKNOWN = -1;
 static constexpr int NO_ = 0;
 static constexpr int YES_ = 1;
 explicit constexpr kleenean (int initialValue): _intValue (initialValue) { }
 bool isTrue () const noexcept {
  return this -> _intValue > 0;
 }
 bool isFalse () const noexcept {
  return this -> _intValue == 0;
 }
 bool isUnknown () const noexcept {
  return this -> _intValue < 0;
 }
 bool isKnown () const noexcept {
  return this -> _intValue >= 0;
 }
 explicit operator bool () const noexcept {
  return this -> isTrue();
 }
 bool operator! () const noexcept {
  return this -> isFalse();
 }
 kleenean operator&& (const kleenean other) const noexcept {
  return this -> isFalse() || other. isFalse() ? kleenean (this -> NO_) :
    this -> isTrue() && other. isTrue() ? kleenean (this -> YES_) :
    kleenean (this -> UNKNOWN);
 }
 kleenean operator|| (const kleenean other) const noexcept {
  return this -> isTrue() || other. isTrue() ? kleenean (this -> YES_) :
    this -> isFalse() && other. isFalse() ? kleenean (this -> NO_) :
    kleenean (this -> UNKNOWN);
 }
 kleenean operator== (const kleenean other) const noexcept {
  return this -> isUnknown() || other. isUnknown() ? kleenean (this -> UNKNOWN) :
    kleenean (this -> isTrue() == other. isTrue());
 }
 kleenean operator!= (const kleenean other) const noexcept {
  return this -> isUnknown() || other. isUnknown() ? kleenean (this -> UNKNOWN) :
    kleenean (this -> isTrue() != other. isTrue());

 }
};
constexpr kleenean kleenean_UNKNOWN = kleenean (-1);
constexpr kleenean kleenean_NO = kleenean (0);
constexpr kleenean kleenean_YES = kleenean (1);
# 51 "../melder/melder.h" 2
# 1 "../melder/melder_pointer.h" 1
# 52 "../melder/melder.h" 2
# 1 "../melder/melder_real.h" 1
# 24 "../melder/melder_real.h"
using longdouble = long double;

template <typename T>
constexpr T sqr (T x) {
 return x * x;
}

struct MelderPoint {
 double x, y;
};

struct MelderRealRange {
 double min, max;





};

struct MelderExtremaWithInit {
 double min = std::numeric_limits<double>::max();
 double max = std::numeric_limits<double>::lowest();
 void update (double val) {
  if (val < min)
   min = val;
  else if (val > max)
   max = val;
 }
 bool isValid () const {
  return min <= max;
 }
};

struct MelderGaussianStats {
 double mean, stdev;
};
# 53 "../melder/melder.h" 2
# 1 "../melder/NUMmath.h" 1
# 37 "../melder/NUMmath.h"
# 1 "/usr/include/c++/9/math.h" 1 3
# 36 "/usr/include/c++/9/math.h" 3
# 1 "/usr/include/c++/9/cmath" 1 3
# 39 "/usr/include/c++/9/cmath" 3
       
# 40 "/usr/include/c++/9/cmath" 3





# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4







# 34 "/usr/include/math.h" 3 4
extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));


extern int __isnan (double __value) throw () __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) throw ();


extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                        ;




extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();





 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();




extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();




extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();






 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();



extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();




extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();






extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
# 182 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();






extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));




extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();




extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();







extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();






extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw (); extern double __nextafter (double __x, double __y) throw ();

extern double nexttoward (double __x, long double __y) throw (); extern double __nexttoward (double __x, long double __y) throw ();




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern long int llogb (double __x) throw (); extern long int __llogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double roundeven (double __x) throw () __attribute__ ((__const__)); extern double __roundeven (double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) throw ()
                               ;


extern double fmaxmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) throw () __attribute__ ((__const__));


extern double fminmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) throw () __attribute__ ((__const__));


extern int totalorder (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermag (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) throw ();


extern double getpayload (const double *__x) throw (); extern double __getpayload (const double *__x) throw ();


extern int setpayload (double *__x, double __payload) throw ();


extern int setpayloadsig (double *__x, double __payload) throw ();







extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));


extern int __isnanf (float __value) throw () __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) throw ();


extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                        ;




extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();





 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();




extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();




extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();






 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();



extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();




extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();






extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw () __attribute__ ((__const__));




extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();






extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));




extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();




extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();







extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();






extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw (); extern float __nextafterf (float __x, float __y) throw ();

extern float nexttowardf (float __x, long double __y) throw (); extern float __nexttowardf (float __x, long double __y) throw ();




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern long int llogbf (float __x) throw (); extern long int __llogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float roundevenf (float __x) throw () __attribute__ ((__const__)); extern float __roundevenf (float __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) throw ()
                               ;


extern float fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern int totalorderf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) throw ();


extern float getpayloadf (const float *__x) throw (); extern float __getpayloadf (const float *__x) throw ();


extern int setpayloadf (float *__x, float __payload) throw ();


extern int setpayloadsigf (float *__x, float __payload) throw ();







extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));


extern int __isnanl (long double __value) throw () __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) throw ();


extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                        ;




extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();





 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();




extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();




extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();






 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();



extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();




extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();






extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw () __attribute__ ((__const__));




extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();






extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();




extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();







extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();






extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw (); extern long double __nextafterl (long double __x, long double __y) throw ();

extern long double nexttowardl (long double __x, long double __y) throw (); extern long double __nexttowardl (long double __x, long double __y) throw ();




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long int llogbl (long double __x) throw (); extern long int __llogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double roundevenl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundevenl (long double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) throw ()
                               ;


extern long double fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern int totalorderl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) throw ();


extern long double getpayloadl (const long double *__x) throw (); extern long double __getpayloadl (const long double *__x) throw ();


extern int setpayloadl (long double *__x, long double __payload) throw ();


extern int setpayloadsigl (long double *__x, long double __payload) throw ();







extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 351 "/usr/include/math.h" 2 3 4
# 389 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) throw (); extern _Float32 __acosf32 (_Float32 __x) throw ();

extern _Float32 asinf32 (_Float32 __x) throw (); extern _Float32 __asinf32 (_Float32 __x) throw ();

extern _Float32 atanf32 (_Float32 __x) throw (); extern _Float32 __atanf32 (_Float32 __x) throw ();

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) throw (); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) throw ();


 extern _Float32 cosf32 (_Float32 __x) throw (); extern _Float32 __cosf32 (_Float32 __x) throw ();

 extern _Float32 sinf32 (_Float32 __x) throw (); extern _Float32 __sinf32 (_Float32 __x) throw ();

extern _Float32 tanf32 (_Float32 __x) throw (); extern _Float32 __tanf32 (_Float32 __x) throw ();




extern _Float32 coshf32 (_Float32 __x) throw (); extern _Float32 __coshf32 (_Float32 __x) throw ();

extern _Float32 sinhf32 (_Float32 __x) throw (); extern _Float32 __sinhf32 (_Float32 __x) throw ();

extern _Float32 tanhf32 (_Float32 __x) throw (); extern _Float32 __tanhf32 (_Float32 __x) throw ();



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw (); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw ()
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) throw (); extern _Float32 __acoshf32 (_Float32 __x) throw ();

extern _Float32 asinhf32 (_Float32 __x) throw (); extern _Float32 __asinhf32 (_Float32 __x) throw ();

extern _Float32 atanhf32 (_Float32 __x) throw (); extern _Float32 __atanhf32 (_Float32 __x) throw ();





 extern _Float32 expf32 (_Float32 __x) throw (); extern _Float32 __expf32 (_Float32 __x) throw ();


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) throw (); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) throw ();


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) throw (); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) throw ();


 extern _Float32 logf32 (_Float32 __x) throw (); extern _Float32 __logf32 (_Float32 __x) throw ();


extern _Float32 log10f32 (_Float32 __x) throw (); extern _Float32 __log10f32 (_Float32 __x) throw ();


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) throw (); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) throw (); extern _Float32 __exp10f32 (_Float32 __x) throw ();




extern _Float32 expm1f32 (_Float32 __x) throw (); extern _Float32 __expm1f32 (_Float32 __x) throw ();


extern _Float32 log1pf32 (_Float32 __x) throw (); extern _Float32 __log1pf32 (_Float32 __x) throw ();


extern _Float32 logbf32 (_Float32 __x) throw (); extern _Float32 __logbf32 (_Float32 __x) throw ();




extern _Float32 exp2f32 (_Float32 __x) throw (); extern _Float32 __exp2f32 (_Float32 __x) throw ();


extern _Float32 log2f32 (_Float32 __x) throw (); extern _Float32 __log2f32 (_Float32 __x) throw ();






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 sqrtf32 (_Float32 __x) throw (); extern _Float32 __sqrtf32 (_Float32 __x) throw ();



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) throw ();




extern _Float32 cbrtf32 (_Float32 __x) throw (); extern _Float32 __cbrtf32 (_Float32 __x) throw ();






extern _Float32 ceilf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32 __nanf32 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) throw (); extern _Float32 __j0f32 (_Float32) throw ();
extern _Float32 j1f32 (_Float32) throw (); extern _Float32 __j1f32 (_Float32) throw ();
extern _Float32 jnf32 (int, _Float32) throw (); extern _Float32 __jnf32 (int, _Float32) throw ();
extern _Float32 y0f32 (_Float32) throw (); extern _Float32 __y0f32 (_Float32) throw ();
extern _Float32 y1f32 (_Float32) throw (); extern _Float32 __y1f32 (_Float32) throw ();
extern _Float32 ynf32 (int, _Float32) throw (); extern _Float32 __ynf32 (int, _Float32) throw ();





extern _Float32 erff32 (_Float32) throw (); extern _Float32 __erff32 (_Float32) throw ();
extern _Float32 erfcf32 (_Float32) throw (); extern _Float32 __erfcf32 (_Float32) throw ();
extern _Float32 lgammaf32 (_Float32) throw (); extern _Float32 __lgammaf32 (_Float32) throw ();




extern _Float32 tgammaf32 (_Float32) throw (); extern _Float32 __tgammaf32 (_Float32) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) throw (); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) throw ();






extern _Float32 rintf32 (_Float32 __x) throw (); extern _Float32 __rintf32 (_Float32 __x) throw ();


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) throw ();






extern _Float32 nextdownf32 (_Float32 __x) throw (); extern _Float32 __nextdownf32 (_Float32 __x) throw ();

extern _Float32 nextupf32 (_Float32 __x) throw (); extern _Float32 __nextupf32 (_Float32 __x) throw ();



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) throw ();



extern _Float32 scalbnf32 (_Float32 __x, int __n) throw (); extern _Float32 __scalbnf32 (_Float32 __x, int __n) throw ();



extern int ilogbf32 (_Float32 __x) throw (); extern int __ilogbf32 (_Float32 __x) throw ();




extern long int llogbf32 (_Float32 __x) throw (); extern long int __llogbf32 (_Float32 __x) throw ();




extern _Float32 scalblnf32 (_Float32 __x, long int __n) throw (); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) throw ();



extern _Float32 nearbyintf32 (_Float32 __x) throw (); extern _Float32 __nearbyintf32 (_Float32 __x) throw ();



extern _Float32 roundf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) throw () __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw (); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw ();






extern long int lrintf32 (_Float32 __x) throw (); extern long int __lrintf32 (_Float32 __x) throw ();
__extension__
extern long long int llrintf32 (_Float32 __x) throw (); extern long long int __llrintf32 (_Float32 __x) throw ();



extern long int lroundf32 (_Float32 __x) throw (); extern long int __lroundf32 (_Float32 __x) throw ();
__extension__
extern long long int llroundf32 (_Float32 __x) throw (); extern long long int __llroundf32 (_Float32 __x) throw ();



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw (); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw ();




extern _Float32 roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern int totalorderf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) throw ();


extern _Float32 getpayloadf32 (const _Float32 *__x) throw (); extern _Float32 __getpayloadf32 (const _Float32 *__x) throw ();


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) throw ();


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) throw ();
# 390 "/usr/include/math.h" 2 3 4
# 406 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) throw (); extern _Float64 __acosf64 (_Float64 __x) throw ();

extern _Float64 asinf64 (_Float64 __x) throw (); extern _Float64 __asinf64 (_Float64 __x) throw ();

extern _Float64 atanf64 (_Float64 __x) throw (); extern _Float64 __atanf64 (_Float64 __x) throw ();

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) throw (); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) throw ();


 extern _Float64 cosf64 (_Float64 __x) throw (); extern _Float64 __cosf64 (_Float64 __x) throw ();

 extern _Float64 sinf64 (_Float64 __x) throw (); extern _Float64 __sinf64 (_Float64 __x) throw ();

extern _Float64 tanf64 (_Float64 __x) throw (); extern _Float64 __tanf64 (_Float64 __x) throw ();




extern _Float64 coshf64 (_Float64 __x) throw (); extern _Float64 __coshf64 (_Float64 __x) throw ();

extern _Float64 sinhf64 (_Float64 __x) throw (); extern _Float64 __sinhf64 (_Float64 __x) throw ();

extern _Float64 tanhf64 (_Float64 __x) throw (); extern _Float64 __tanhf64 (_Float64 __x) throw ();



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw (); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw ()
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) throw (); extern _Float64 __acoshf64 (_Float64 __x) throw ();

extern _Float64 asinhf64 (_Float64 __x) throw (); extern _Float64 __asinhf64 (_Float64 __x) throw ();

extern _Float64 atanhf64 (_Float64 __x) throw (); extern _Float64 __atanhf64 (_Float64 __x) throw ();





 extern _Float64 expf64 (_Float64 __x) throw (); extern _Float64 __expf64 (_Float64 __x) throw ();


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) throw (); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) throw ();


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) throw (); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) throw ();


 extern _Float64 logf64 (_Float64 __x) throw (); extern _Float64 __logf64 (_Float64 __x) throw ();


extern _Float64 log10f64 (_Float64 __x) throw (); extern _Float64 __log10f64 (_Float64 __x) throw ();


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) throw (); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) throw (); extern _Float64 __exp10f64 (_Float64 __x) throw ();




extern _Float64 expm1f64 (_Float64 __x) throw (); extern _Float64 __expm1f64 (_Float64 __x) throw ();


extern _Float64 log1pf64 (_Float64 __x) throw (); extern _Float64 __log1pf64 (_Float64 __x) throw ();


extern _Float64 logbf64 (_Float64 __x) throw (); extern _Float64 __logbf64 (_Float64 __x) throw ();




extern _Float64 exp2f64 (_Float64 __x) throw (); extern _Float64 __exp2f64 (_Float64 __x) throw ();


extern _Float64 log2f64 (_Float64 __x) throw (); extern _Float64 __log2f64 (_Float64 __x) throw ();






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 sqrtf64 (_Float64 __x) throw (); extern _Float64 __sqrtf64 (_Float64 __x) throw ();



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) throw ();




extern _Float64 cbrtf64 (_Float64 __x) throw (); extern _Float64 __cbrtf64 (_Float64 __x) throw ();






extern _Float64 ceilf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64 __nanf64 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) throw (); extern _Float64 __j0f64 (_Float64) throw ();
extern _Float64 j1f64 (_Float64) throw (); extern _Float64 __j1f64 (_Float64) throw ();
extern _Float64 jnf64 (int, _Float64) throw (); extern _Float64 __jnf64 (int, _Float64) throw ();
extern _Float64 y0f64 (_Float64) throw (); extern _Float64 __y0f64 (_Float64) throw ();
extern _Float64 y1f64 (_Float64) throw (); extern _Float64 __y1f64 (_Float64) throw ();
extern _Float64 ynf64 (int, _Float64) throw (); extern _Float64 __ynf64 (int, _Float64) throw ();





extern _Float64 erff64 (_Float64) throw (); extern _Float64 __erff64 (_Float64) throw ();
extern _Float64 erfcf64 (_Float64) throw (); extern _Float64 __erfcf64 (_Float64) throw ();
extern _Float64 lgammaf64 (_Float64) throw (); extern _Float64 __lgammaf64 (_Float64) throw ();




extern _Float64 tgammaf64 (_Float64) throw (); extern _Float64 __tgammaf64 (_Float64) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) throw (); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) throw ();






extern _Float64 rintf64 (_Float64 __x) throw (); extern _Float64 __rintf64 (_Float64 __x) throw ();


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) throw ();






extern _Float64 nextdownf64 (_Float64 __x) throw (); extern _Float64 __nextdownf64 (_Float64 __x) throw ();

extern _Float64 nextupf64 (_Float64 __x) throw (); extern _Float64 __nextupf64 (_Float64 __x) throw ();



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) throw ();



extern _Float64 scalbnf64 (_Float64 __x, int __n) throw (); extern _Float64 __scalbnf64 (_Float64 __x, int __n) throw ();



extern int ilogbf64 (_Float64 __x) throw (); extern int __ilogbf64 (_Float64 __x) throw ();




extern long int llogbf64 (_Float64 __x) throw (); extern long int __llogbf64 (_Float64 __x) throw ();




extern _Float64 scalblnf64 (_Float64 __x, long int __n) throw (); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) throw ();



extern _Float64 nearbyintf64 (_Float64 __x) throw (); extern _Float64 __nearbyintf64 (_Float64 __x) throw ();



extern _Float64 roundf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) throw () __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw (); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw ();






extern long int lrintf64 (_Float64 __x) throw (); extern long int __lrintf64 (_Float64 __x) throw ();
__extension__
extern long long int llrintf64 (_Float64 __x) throw (); extern long long int __llrintf64 (_Float64 __x) throw ();



extern long int lroundf64 (_Float64 __x) throw (); extern long int __lroundf64 (_Float64 __x) throw ();
__extension__
extern long long int llroundf64 (_Float64 __x) throw (); extern long long int __llroundf64 (_Float64 __x) throw ();



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw (); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw ();




extern _Float64 roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern int totalorderf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) throw ();


extern _Float64 getpayloadf64 (const _Float64 *__x) throw (); extern _Float64 __getpayloadf64 (const _Float64 *__x) throw ();


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) throw ();


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) throw ();
# 407 "/usr/include/math.h" 2 3 4
# 420 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) throw ();


extern int __issignalingf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));
# 421 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 acosf128 (_Float128 __x) throw (); extern _Float128 __acosf128 (_Float128 __x) throw ();

extern _Float128 asinf128 (_Float128 __x) throw (); extern _Float128 __asinf128 (_Float128 __x) throw ();

extern _Float128 atanf128 (_Float128 __x) throw (); extern _Float128 __atanf128 (_Float128 __x) throw ();

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) throw (); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) throw ();


 extern _Float128 cosf128 (_Float128 __x) throw (); extern _Float128 __cosf128 (_Float128 __x) throw ();

 extern _Float128 sinf128 (_Float128 __x) throw (); extern _Float128 __sinf128 (_Float128 __x) throw ();

extern _Float128 tanf128 (_Float128 __x) throw (); extern _Float128 __tanf128 (_Float128 __x) throw ();




extern _Float128 coshf128 (_Float128 __x) throw (); extern _Float128 __coshf128 (_Float128 __x) throw ();

extern _Float128 sinhf128 (_Float128 __x) throw (); extern _Float128 __sinhf128 (_Float128 __x) throw ();

extern _Float128 tanhf128 (_Float128 __x) throw (); extern _Float128 __tanhf128 (_Float128 __x) throw ();



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw (); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw ()
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) throw (); extern _Float128 __acoshf128 (_Float128 __x) throw ();

extern _Float128 asinhf128 (_Float128 __x) throw (); extern _Float128 __asinhf128 (_Float128 __x) throw ();

extern _Float128 atanhf128 (_Float128 __x) throw (); extern _Float128 __atanhf128 (_Float128 __x) throw ();





 extern _Float128 expf128 (_Float128 __x) throw (); extern _Float128 __expf128 (_Float128 __x) throw ();


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) throw (); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) throw ();


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) throw (); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) throw ();


 extern _Float128 logf128 (_Float128 __x) throw (); extern _Float128 __logf128 (_Float128 __x) throw ();


extern _Float128 log10f128 (_Float128 __x) throw (); extern _Float128 __log10f128 (_Float128 __x) throw ();


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) throw (); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) throw (); extern _Float128 __exp10f128 (_Float128 __x) throw ();




extern _Float128 expm1f128 (_Float128 __x) throw (); extern _Float128 __expm1f128 (_Float128 __x) throw ();


extern _Float128 log1pf128 (_Float128 __x) throw (); extern _Float128 __log1pf128 (_Float128 __x) throw ();


extern _Float128 logbf128 (_Float128 __x) throw (); extern _Float128 __logbf128 (_Float128 __x) throw ();




extern _Float128 exp2f128 (_Float128 __x) throw (); extern _Float128 __exp2f128 (_Float128 __x) throw ();


extern _Float128 log2f128 (_Float128 __x) throw (); extern _Float128 __log2f128 (_Float128 __x) throw ();






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 sqrtf128 (_Float128 __x) throw (); extern _Float128 __sqrtf128 (_Float128 __x) throw ();



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) throw ();




extern _Float128 cbrtf128 (_Float128 __x) throw (); extern _Float128 __cbrtf128 (_Float128 __x) throw ();






extern _Float128 ceilf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float128 __nanf128 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) throw (); extern _Float128 __j0f128 (_Float128) throw ();
extern _Float128 j1f128 (_Float128) throw (); extern _Float128 __j1f128 (_Float128) throw ();
extern _Float128 jnf128 (int, _Float128) throw (); extern _Float128 __jnf128 (int, _Float128) throw ();
extern _Float128 y0f128 (_Float128) throw (); extern _Float128 __y0f128 (_Float128) throw ();
extern _Float128 y1f128 (_Float128) throw (); extern _Float128 __y1f128 (_Float128) throw ();
extern _Float128 ynf128 (int, _Float128) throw (); extern _Float128 __ynf128 (int, _Float128) throw ();





extern _Float128 erff128 (_Float128) throw (); extern _Float128 __erff128 (_Float128) throw ();
extern _Float128 erfcf128 (_Float128) throw (); extern _Float128 __erfcf128 (_Float128) throw ();
extern _Float128 lgammaf128 (_Float128) throw (); extern _Float128 __lgammaf128 (_Float128) throw ();




extern _Float128 tgammaf128 (_Float128) throw (); extern _Float128 __tgammaf128 (_Float128) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) throw (); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) throw ();






extern _Float128 rintf128 (_Float128 __x) throw (); extern _Float128 __rintf128 (_Float128 __x) throw ();


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) throw ();






extern _Float128 nextdownf128 (_Float128 __x) throw (); extern _Float128 __nextdownf128 (_Float128 __x) throw ();

extern _Float128 nextupf128 (_Float128 __x) throw (); extern _Float128 __nextupf128 (_Float128 __x) throw ();



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) throw ();



extern _Float128 scalbnf128 (_Float128 __x, int __n) throw (); extern _Float128 __scalbnf128 (_Float128 __x, int __n) throw ();



extern int ilogbf128 (_Float128 __x) throw (); extern int __ilogbf128 (_Float128 __x) throw ();




extern long int llogbf128 (_Float128 __x) throw (); extern long int __llogbf128 (_Float128 __x) throw ();




extern _Float128 scalblnf128 (_Float128 __x, long int __n) throw (); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) throw ();



extern _Float128 nearbyintf128 (_Float128 __x) throw (); extern _Float128 __nearbyintf128 (_Float128 __x) throw ();



extern _Float128 roundf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) throw () __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw (); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw ();






extern long int lrintf128 (_Float128 __x) throw (); extern long int __lrintf128 (_Float128 __x) throw ();
__extension__
extern long long int llrintf128 (_Float128 __x) throw (); extern long long int __llrintf128 (_Float128 __x) throw ();



extern long int lroundf128 (_Float128 __x) throw (); extern long int __lroundf128 (_Float128 __x) throw ();
__extension__
extern long long int llroundf128 (_Float128 __x) throw (); extern long long int __llroundf128 (_Float128 __x) throw ();



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw (); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw ();




extern _Float128 roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern int totalorderf128 (_Float128 __x, _Float128 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf128 (_Float128 __x, _Float128 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) throw ();


extern _Float128 getpayloadf128 (const _Float128 *__x) throw (); extern _Float128 __getpayloadf128 (const _Float128 *__x) throw ();


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) throw ();


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) throw ();
# 424 "/usr/include/math.h" 2 3 4
# 440 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) throw (); extern _Float32x __acosf32x (_Float32x __x) throw ();

extern _Float32x asinf32x (_Float32x __x) throw (); extern _Float32x __asinf32x (_Float32x __x) throw ();

extern _Float32x atanf32x (_Float32x __x) throw (); extern _Float32x __atanf32x (_Float32x __x) throw ();

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) throw (); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) throw ();


 extern _Float32x cosf32x (_Float32x __x) throw (); extern _Float32x __cosf32x (_Float32x __x) throw ();

 extern _Float32x sinf32x (_Float32x __x) throw (); extern _Float32x __sinf32x (_Float32x __x) throw ();

extern _Float32x tanf32x (_Float32x __x) throw (); extern _Float32x __tanf32x (_Float32x __x) throw ();




extern _Float32x coshf32x (_Float32x __x) throw (); extern _Float32x __coshf32x (_Float32x __x) throw ();

extern _Float32x sinhf32x (_Float32x __x) throw (); extern _Float32x __sinhf32x (_Float32x __x) throw ();

extern _Float32x tanhf32x (_Float32x __x) throw (); extern _Float32x __tanhf32x (_Float32x __x) throw ();



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw (); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw ()
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) throw (); extern _Float32x __acoshf32x (_Float32x __x) throw ();

extern _Float32x asinhf32x (_Float32x __x) throw (); extern _Float32x __asinhf32x (_Float32x __x) throw ();

extern _Float32x atanhf32x (_Float32x __x) throw (); extern _Float32x __atanhf32x (_Float32x __x) throw ();





 extern _Float32x expf32x (_Float32x __x) throw (); extern _Float32x __expf32x (_Float32x __x) throw ();


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) throw (); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) throw ();


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) throw (); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) throw ();


 extern _Float32x logf32x (_Float32x __x) throw (); extern _Float32x __logf32x (_Float32x __x) throw ();


extern _Float32x log10f32x (_Float32x __x) throw (); extern _Float32x __log10f32x (_Float32x __x) throw ();


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) throw (); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) throw (); extern _Float32x __exp10f32x (_Float32x __x) throw ();




extern _Float32x expm1f32x (_Float32x __x) throw (); extern _Float32x __expm1f32x (_Float32x __x) throw ();


extern _Float32x log1pf32x (_Float32x __x) throw (); extern _Float32x __log1pf32x (_Float32x __x) throw ();


extern _Float32x logbf32x (_Float32x __x) throw (); extern _Float32x __logbf32x (_Float32x __x) throw ();




extern _Float32x exp2f32x (_Float32x __x) throw (); extern _Float32x __exp2f32x (_Float32x __x) throw ();


extern _Float32x log2f32x (_Float32x __x) throw (); extern _Float32x __log2f32x (_Float32x __x) throw ();






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x sqrtf32x (_Float32x __x) throw (); extern _Float32x __sqrtf32x (_Float32x __x) throw ();



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) throw ();




extern _Float32x cbrtf32x (_Float32x __x) throw (); extern _Float32x __cbrtf32x (_Float32x __x) throw ();






extern _Float32x ceilf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32x __nanf32x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) throw (); extern _Float32x __j0f32x (_Float32x) throw ();
extern _Float32x j1f32x (_Float32x) throw (); extern _Float32x __j1f32x (_Float32x) throw ();
extern _Float32x jnf32x (int, _Float32x) throw (); extern _Float32x __jnf32x (int, _Float32x) throw ();
extern _Float32x y0f32x (_Float32x) throw (); extern _Float32x __y0f32x (_Float32x) throw ();
extern _Float32x y1f32x (_Float32x) throw (); extern _Float32x __y1f32x (_Float32x) throw ();
extern _Float32x ynf32x (int, _Float32x) throw (); extern _Float32x __ynf32x (int, _Float32x) throw ();





extern _Float32x erff32x (_Float32x) throw (); extern _Float32x __erff32x (_Float32x) throw ();
extern _Float32x erfcf32x (_Float32x) throw (); extern _Float32x __erfcf32x (_Float32x) throw ();
extern _Float32x lgammaf32x (_Float32x) throw (); extern _Float32x __lgammaf32x (_Float32x) throw ();




extern _Float32x tgammaf32x (_Float32x) throw (); extern _Float32x __tgammaf32x (_Float32x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) throw (); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) throw ();






extern _Float32x rintf32x (_Float32x __x) throw (); extern _Float32x __rintf32x (_Float32x __x) throw ();


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) throw ();






extern _Float32x nextdownf32x (_Float32x __x) throw (); extern _Float32x __nextdownf32x (_Float32x __x) throw ();

extern _Float32x nextupf32x (_Float32x __x) throw (); extern _Float32x __nextupf32x (_Float32x __x) throw ();



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) throw ();



extern _Float32x scalbnf32x (_Float32x __x, int __n) throw (); extern _Float32x __scalbnf32x (_Float32x __x, int __n) throw ();



extern int ilogbf32x (_Float32x __x) throw (); extern int __ilogbf32x (_Float32x __x) throw ();




extern long int llogbf32x (_Float32x __x) throw (); extern long int __llogbf32x (_Float32x __x) throw ();




extern _Float32x scalblnf32x (_Float32x __x, long int __n) throw (); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) throw ();



extern _Float32x nearbyintf32x (_Float32x __x) throw (); extern _Float32x __nearbyintf32x (_Float32x __x) throw ();



extern _Float32x roundf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) throw () __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw (); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw ();






extern long int lrintf32x (_Float32x __x) throw (); extern long int __lrintf32x (_Float32x __x) throw ();
__extension__
extern long long int llrintf32x (_Float32x __x) throw (); extern long long int __llrintf32x (_Float32x __x) throw ();



extern long int lroundf32x (_Float32x __x) throw (); extern long int __lroundf32x (_Float32x __x) throw ();
__extension__
extern long long int llroundf32x (_Float32x __x) throw (); extern long long int __llroundf32x (_Float32x __x) throw ();



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw (); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw ();




extern _Float32x roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern int totalorderf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) throw ();


extern _Float32x getpayloadf32x (const _Float32x *__x) throw (); extern _Float32x __getpayloadf32x (const _Float32x *__x) throw ();


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) throw ();


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) throw ();
# 441 "/usr/include/math.h" 2 3 4
# 457 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) throw (); extern _Float64x __acosf64x (_Float64x __x) throw ();

extern _Float64x asinf64x (_Float64x __x) throw (); extern _Float64x __asinf64x (_Float64x __x) throw ();

extern _Float64x atanf64x (_Float64x __x) throw (); extern _Float64x __atanf64x (_Float64x __x) throw ();

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) throw (); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) throw ();


 extern _Float64x cosf64x (_Float64x __x) throw (); extern _Float64x __cosf64x (_Float64x __x) throw ();

 extern _Float64x sinf64x (_Float64x __x) throw (); extern _Float64x __sinf64x (_Float64x __x) throw ();

extern _Float64x tanf64x (_Float64x __x) throw (); extern _Float64x __tanf64x (_Float64x __x) throw ();




extern _Float64x coshf64x (_Float64x __x) throw (); extern _Float64x __coshf64x (_Float64x __x) throw ();

extern _Float64x sinhf64x (_Float64x __x) throw (); extern _Float64x __sinhf64x (_Float64x __x) throw ();

extern _Float64x tanhf64x (_Float64x __x) throw (); extern _Float64x __tanhf64x (_Float64x __x) throw ();



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw (); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw ()
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) throw (); extern _Float64x __acoshf64x (_Float64x __x) throw ();

extern _Float64x asinhf64x (_Float64x __x) throw (); extern _Float64x __asinhf64x (_Float64x __x) throw ();

extern _Float64x atanhf64x (_Float64x __x) throw (); extern _Float64x __atanhf64x (_Float64x __x) throw ();





 extern _Float64x expf64x (_Float64x __x) throw (); extern _Float64x __expf64x (_Float64x __x) throw ();


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) throw (); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) throw ();


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) throw (); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) throw ();


 extern _Float64x logf64x (_Float64x __x) throw (); extern _Float64x __logf64x (_Float64x __x) throw ();


extern _Float64x log10f64x (_Float64x __x) throw (); extern _Float64x __log10f64x (_Float64x __x) throw ();


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) throw (); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) throw (); extern _Float64x __exp10f64x (_Float64x __x) throw ();




extern _Float64x expm1f64x (_Float64x __x) throw (); extern _Float64x __expm1f64x (_Float64x __x) throw ();


extern _Float64x log1pf64x (_Float64x __x) throw (); extern _Float64x __log1pf64x (_Float64x __x) throw ();


extern _Float64x logbf64x (_Float64x __x) throw (); extern _Float64x __logbf64x (_Float64x __x) throw ();




extern _Float64x exp2f64x (_Float64x __x) throw (); extern _Float64x __exp2f64x (_Float64x __x) throw ();


extern _Float64x log2f64x (_Float64x __x) throw (); extern _Float64x __log2f64x (_Float64x __x) throw ();






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x sqrtf64x (_Float64x __x) throw (); extern _Float64x __sqrtf64x (_Float64x __x) throw ();



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) throw ();




extern _Float64x cbrtf64x (_Float64x __x) throw (); extern _Float64x __cbrtf64x (_Float64x __x) throw ();






extern _Float64x ceilf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64x __nanf64x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) throw (); extern _Float64x __j0f64x (_Float64x) throw ();
extern _Float64x j1f64x (_Float64x) throw (); extern _Float64x __j1f64x (_Float64x) throw ();
extern _Float64x jnf64x (int, _Float64x) throw (); extern _Float64x __jnf64x (int, _Float64x) throw ();
extern _Float64x y0f64x (_Float64x) throw (); extern _Float64x __y0f64x (_Float64x) throw ();
extern _Float64x y1f64x (_Float64x) throw (); extern _Float64x __y1f64x (_Float64x) throw ();
extern _Float64x ynf64x (int, _Float64x) throw (); extern _Float64x __ynf64x (int, _Float64x) throw ();





extern _Float64x erff64x (_Float64x) throw (); extern _Float64x __erff64x (_Float64x) throw ();
extern _Float64x erfcf64x (_Float64x) throw (); extern _Float64x __erfcf64x (_Float64x) throw ();
extern _Float64x lgammaf64x (_Float64x) throw (); extern _Float64x __lgammaf64x (_Float64x) throw ();




extern _Float64x tgammaf64x (_Float64x) throw (); extern _Float64x __tgammaf64x (_Float64x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) throw (); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) throw ();






extern _Float64x rintf64x (_Float64x __x) throw (); extern _Float64x __rintf64x (_Float64x __x) throw ();


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) throw ();






extern _Float64x nextdownf64x (_Float64x __x) throw (); extern _Float64x __nextdownf64x (_Float64x __x) throw ();

extern _Float64x nextupf64x (_Float64x __x) throw (); extern _Float64x __nextupf64x (_Float64x __x) throw ();



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) throw ();



extern _Float64x scalbnf64x (_Float64x __x, int __n) throw (); extern _Float64x __scalbnf64x (_Float64x __x, int __n) throw ();



extern int ilogbf64x (_Float64x __x) throw (); extern int __ilogbf64x (_Float64x __x) throw ();




extern long int llogbf64x (_Float64x __x) throw (); extern long int __llogbf64x (_Float64x __x) throw ();




extern _Float64x scalblnf64x (_Float64x __x, long int __n) throw (); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) throw ();



extern _Float64x nearbyintf64x (_Float64x __x) throw (); extern _Float64x __nearbyintf64x (_Float64x __x) throw ();



extern _Float64x roundf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) throw () __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw (); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw ();






extern long int lrintf64x (_Float64x __x) throw (); extern long int __lrintf64x (_Float64x __x) throw ();
__extension__
extern long long int llrintf64x (_Float64x __x) throw (); extern long long int __llrintf64x (_Float64x __x) throw ();



extern long int lroundf64x (_Float64x __x) throw (); extern long int __lroundf64x (_Float64x __x) throw ();
__extension__
extern long long int llroundf64x (_Float64x __x) throw (); extern long long int __llroundf64x (_Float64x __x) throw ();



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw (); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw ();




extern _Float64x roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern int totalorderf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) throw ();


extern _Float64x getpayloadf64x (const _Float64x *__x) throw (); extern _Float64x __getpayloadf64x (const _Float64x *__x) throw ();


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) throw ();


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) throw ();
# 458 "/usr/include/math.h" 2 3 4
# 489 "/usr/include/math.h" 3 4
extern int signgam;
# 569 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 684 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     throw () __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 685 "/usr/include/math.h" 2 3 4
# 696 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}

inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 725 "/usr/include/math.h" 3 4
extern "C++" {
# 754 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1205 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (double __x, double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {
    return __iseqsigf128 (__x, __y);
  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/include/c++/9/cmath" 2 3
# 77 "/usr/include/c++/9/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/include/c++/9/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/usr/include/c++/9/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/usr/include/c++/9/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1923 "/usr/include/c++/9/cmath" 3

}





}
# 37 "/usr/include/c++/9/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 38 "../melder/NUMmath.h" 2
# 50 "../melder/NUMmath.h"

# 50 "../melder/NUMmath.h"
void NUMshift (double *x, double xfrom, double xto);
void NUMscale (double *x, double xminfrom, double xmaxfrom, double xminto, double xmaxto);
# 61 "../melder/NUMmath.h"
constexpr double NUMe = 2.7182818284590452353602874713526624977572;

constexpr double NUMlog2e = 1.4426950408889634073599246810018921374266;

constexpr double NUMlog2_10 = 3.3219280948873623478703194294893901758648;

constexpr double NUMlog10e = 0.4342944819032518276511289189166050822944;

constexpr double NUMlog10_2 = 0.3010299956639811952137388947244930267682;

constexpr double NUMln2 = 0.6931471805599453094172321214581765680755;

constexpr double NUMln10 = 2.3025850929940456840179914546843642076011;

constexpr double NUM2pi = 6.2831853071795864769252867665590057683943;

constexpr double NUMpi = 3.1415926535897932384626433832795028841972;

constexpr double NUMpi_2 = 1.5707963267948966192313216916397514420986;

constexpr double NUMpi_4 = 0.7853981633974483096156608458198757210493;

constexpr double NUM1_pi = 0.3183098861837906715377675267450287240689;

constexpr double NUM2_pi = 0.6366197723675813430755350534900574481378;

constexpr double NUMsqrtpi = 1.7724538509055160272981674833411451827975;

constexpr double NUMsqrt2pi = 2.5066282746310005024157652848110452530070;

constexpr double NUM1_sqrt2pi = 0.3989422804014326779399460599343818684759;

constexpr double NUM2_sqrtpi = 1.1283791670955125738961589031215451716881;

constexpr double NUMlnpi = 1.1447298858494001741434273513530587116473;

constexpr double NUMsqrt2 = 1.4142135623730950488016887242096980785697;

constexpr double NUMsqrt1_2 = 0.7071067811865475244008443621048490392848;

constexpr double NUMsqrt3 = 1.7320508075688772935274463415058723669428;

constexpr double NUMsqrt5 = 2.2360679774997896964091736687312762354406;

constexpr double NUMsqrt6 = 2.4494897427831780981972840747058913919659;

constexpr double NUMsqrt7 = 2.6457513110645905905016157536392604257102;

constexpr double NUMsqrt8 = 2.8284271247461900976033774484193961571393;

constexpr double NUMsqrt10 = 3.1622776601683793319988935444327185337196;

constexpr double NUM_goldenSection = 0.6180339887498948482045868343656381177203;


constexpr double NUM_euler = 0.5772156649015328606065120900824024310422;

const double undefined = (0.0/0.0);
# 131 "../melder/NUMmath.h"
inline bool isdefined (double x) { return ((* (uint64 *) & x) & 0x7FF0'0000'0000'0000) != 0x7FF0'0000'0000'0000; }
inline bool isundef (double x) { return ((* (uint64 *) & x) & 0x7FF0'0000'0000'0000) == 0x7FF0'0000'0000'0000; }
# 54 "../melder/melder.h" 2
# 1 "../melder/complex.h" 1
# 22 "../melder/complex.h"
# 1 "/usr/include/c++/9/complex" 1 3
# 39 "/usr/include/c++/9/complex" 3
       
# 40 "/usr/include/c++/9/complex" 3




# 1 "/usr/include/c++/9/cmath" 1 3
# 39 "/usr/include/c++/9/cmath" 3
       
# 40 "/usr/include/c++/9/cmath" 3
# 45 "/usr/include/c++/9/complex" 2 3
# 1 "/usr/include/c++/9/sstream" 1 3
# 36 "/usr/include/c++/9/sstream" 3
       
# 37 "/usr/include/c++/9/sstream" 3

# 1 "/usr/include/c++/9/istream" 1 3
# 36 "/usr/include/c++/9/istream" 3
       
# 37 "/usr/include/c++/9/istream" 3

# 1 "/usr/include/c++/9/ios" 1 3
# 36 "/usr/include/c++/9/ios" 3
       
# 37 "/usr/include/c++/9/ios" 3





# 1 "/usr/include/c++/9/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/9/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/9/bits/ios_base.h" 3



# 1 "/usr/include/c++/9/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/9/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/9/bits/locale_classes.h" 3






# 43 "/usr/include/c++/9/bits/locale_classes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/9/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/9/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/9/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/9/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/9/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/9/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/include/c++/9/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/usr/include/c++/9/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/usr/include/c++/9/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/usr/include/c++/9/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/usr/include/c++/9/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/usr/include/c++/9/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/usr/include/c++/9/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "/usr/include/c++/9/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "/usr/include/c++/9/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "/usr/include/c++/9/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "/usr/include/c++/9/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "/usr/include/c++/9/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "/usr/include/c++/9/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 483 "/usr/include/c++/9/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 641 "/usr/include/c++/9/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 668 "/usr/include/c++/9/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 682 "/usr/include/c++/9/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 699 "/usr/include/c++/9/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 718 "/usr/include/c++/9/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 732 "/usr/include/c++/9/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 761 "/usr/include/c++/9/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 775 "/usr/include/c++/9/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 788 "/usr/include/c++/9/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/9/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/9/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/9/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/9/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/9/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 852 "/usr/include/c++/9/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/9/bits/ios_base.h" 2 3




# 1 "/usr/include/c++/9/system_error" 1 3
# 32 "/usr/include/c++/9/system_error" 3
       
# 33 "/usr/include/c++/9/system_error" 3






# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/error_constants.h" 1 3
# 34 "/usr/include/x86_64-linux-gnu/c++/9/bits/error_constants.h" 3
# 1 "/usr/include/c++/9/cerrno" 1 3
# 39 "/usr/include/c++/9/cerrno" 3
       
# 40 "/usr/include/c++/9/cerrno" 3
# 35 "/usr/include/x86_64-linux-gnu/c++/9/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/usr/include/c++/9/system_error" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };
# 71 "/usr/include/c++/9/system_error" 3
  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 110 "/usr/include/c++/9/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }


    system_error (const system_error &) = default;
    system_error &operator= (const system_error &) = default;


    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{





  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };
# 419 "/usr/include/c++/9/system_error" 3

}
# 47 "/usr/include/c++/9/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/usr/include/c++/9/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/usr/include/c++/9/bits/ios_base.h" 3
  public:
# 255 "/usr/include/c++/9/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/usr/include/c++/9/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/usr/include/c++/9/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/usr/include/c++/9/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/usr/include/c++/9/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;



    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 489 "/usr/include/c++/9/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 506 "/usr/include/c++/9/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 518 "/usr/include/c++/9/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();


      Init(const Init&) = default;
      Init& operator=(const Init&) = default;


    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 636 "/usr/include/c++/9/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 652 "/usr/include/c++/9/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 669 "/usr/include/c++/9/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 695 "/usr/include/c++/9/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 746 "/usr/include/c++/9/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 758 "/usr/include/c++/9/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 769 "/usr/include/c++/9/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 780 "/usr/include/c++/9/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 799 "/usr/include/c++/9/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 815 "/usr/include/c++/9/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 836 "/usr/include/c++/9/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 853 "/usr/include/c++/9/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 867 "/usr/include/c++/9/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/usr/include/c++/9/ios" 2 3
# 1 "/usr/include/c++/9/streambuf" 1 3
# 36 "/usr/include/c++/9/streambuf" 3
       
# 37 "/usr/include/c++/9/streambuf" 3
# 45 "/usr/include/c++/9/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 121 "/usr/include/c++/9/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 215 "/usr/include/c++/9/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 232 "/usr/include/c++/9/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 245 "/usr/include/c++/9/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 257 "/usr/include/c++/9/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 269 "/usr/include/c++/9/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 290 "/usr/include/c++/9/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 304 "/usr/include/c++/9/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 322 "/usr/include/c++/9/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 344 "/usr/include/c++/9/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 363 "/usr/include/c++/9/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 378 "/usr/include/c++/9/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 403 "/usr/include/c++/9/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 430 "/usr/include/c++/9/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 456 "/usr/include/c++/9/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 470 "/usr/include/c++/9/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 488 "/usr/include/c++/9/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 504 "/usr/include/c++/9/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 515 "/usr/include/c++/9/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 535 "/usr/include/c++/9/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 551 "/usr/include/c++/9/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 561 "/usr/include/c++/9/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 582 "/usr/include/c++/9/streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 597 "/usr/include/c++/9/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 608 "/usr/include/c++/9/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 620 "/usr/include/c++/9/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 633 "/usr/include/c++/9/streambuf" 3
      virtual int
      sync() { return 0; }
# 655 "/usr/include/c++/9/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 671 "/usr/include/c++/9/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 693 "/usr/include/c++/9/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 706 "/usr/include/c++/9/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 730 "/usr/include/c++/9/streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 748 "/usr/include/c++/9/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 774 "/usr/include/c++/9/streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 790 "/usr/include/c++/9/streambuf" 3
      [[__deprecated__("stossc is deprecated, use sbumpc instead")]]

      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}

# 1 "/usr/include/c++/9/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/9/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/9/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 863 "/usr/include/c++/9/streambuf" 2 3
# 44 "/usr/include/c++/9/ios" 2 3
# 1 "/usr/include/c++/9/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/9/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/9/bits/basic_ios.h" 3



# 1 "/usr/include/c++/9/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/9/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/9/bits/locale_facets.h" 3

# 1 "/usr/include/c++/9/cwctype" 1 3
# 39 "/usr/include/c++/9/cwctype" 3
       
# 40 "/usr/include/c++/9/cwctype" 3
# 80 "/usr/include/c++/9/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/9/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/9/cctype" 1 3
# 39 "/usr/include/c++/9/cctype" 3
       
# 40 "/usr/include/c++/9/cctype" 3
# 41 "/usr/include/c++/9/bits/locale_facets.h" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/ctype_base.h" 1 3
# 36 "/usr/include/x86_64-linux-gnu/c++/9/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/include/c++/9/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/9/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/9/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/9/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/9/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }


      istreambuf_iterator&
      operator=(const istreambuf_iterator&) noexcept = default;





      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 144 "/usr/include/c++/9/bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

      ;
     

                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {
      

                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 49 "/usr/include/c++/9/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/9/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/include/c++/9/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/usr/include/c++/9/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/usr/include/c++/9/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/usr/include/c++/9/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/usr/include/c++/9/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/usr/include/c++/9/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/usr/include/c++/9/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/usr/include/c++/9/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/usr/include/c++/9/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/usr/include/c++/9/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/usr/include/c++/9/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/usr/include/c++/9/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/usr/include/c++/9/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/usr/include/c++/9/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/usr/include/c++/9/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/usr/include/c++/9/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/usr/include/c++/9/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 930 "/usr/include/c++/9/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 963 "/usr/include/c++/9/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1013 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1030 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1046 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1063 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1083 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1106 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1133 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1159 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1185 "/usr/include/c++/9/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1218 "/usr/include/c++/9/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1229 "/usr/include/c++/9/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1253 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1272 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1290 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1308 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1325 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1342 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1358 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1375 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1395 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1417 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1440 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1466 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/x86_64-linux-gnu/c++/9/bits/ctype_inline.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/9/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1539 "/usr/include/c++/9/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1669 "/usr/include/c++/9/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1707 "/usr/include/c++/9/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1721 "/usr/include/c++/9/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1735 "/usr/include/c++/9/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1748 "/usr/include/c++/9/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1779 "/usr/include/c++/9/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1792 "/usr/include/c++/9/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1805 "/usr/include/c++/9/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1822 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1834 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1847 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1860 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1873 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1951 "/usr/include/c++/9/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1972 "/usr/include/c++/9/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1998 "/usr/include/c++/9/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2035 "/usr/include/c++/9/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2095 "/usr/include/c++/9/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2138 "/usr/include/c++/9/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2211 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2274 "/usr/include/c++/9/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2292 "/usr/include/c++/9/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2313 "/usr/include/c++/9/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2331 "/usr/include/c++/9/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2373 "/usr/include/c++/9/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2436 "/usr/include/c++/9/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2461 "/usr/include/c++/9/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2509 "/usr/include/c++/9/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/9/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/9/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/9/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/include/c++/9/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/include/c++/9/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/usr/include/c++/9/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/usr/include/c++/9/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/usr/include/c++/9/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "/usr/include/c++/9/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2656 "/usr/include/c++/9/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/9/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/include/c++/9/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/usr/include/c++/9/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/usr/include/c++/9/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/usr/include/c++/9/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/include/c++/9/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/include/c++/9/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/usr/include/c++/9/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/usr/include/c++/9/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/usr/include/c++/9/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/usr/include/c++/9/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/usr/include/c++/9/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/usr/include/c++/9/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/usr/include/c++/9/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/usr/include/c++/9/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/usr/include/c++/9/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/9/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/9/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/9/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/9/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/usr/include/c++/9/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/9/ios" 2 3
# 39 "/usr/include/c++/9/istream" 2 3
# 1 "/usr/include/c++/9/ostream" 1 3
# 36 "/usr/include/c++/9/ostream" 3
       
# 37 "/usr/include/c++/9/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/9/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/9/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 275 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 308 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 340 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 353 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      flush();
# 363 "/usr/include/c++/9/ostream" 3
      pos_type
      tellp();
# 374 "/usr/include/c++/9/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 386 "/usr/include/c++/9/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 431 "/usr/include/c++/9/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 450 "/usr/include/c++/9/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"







      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#pragma GCC diagnostic pop
# 482 "/usr/include/c++/9/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 504 "/usr/include/c++/9/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 546 "/usr/include/c++/9/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 597 "/usr/include/c++/9/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 609 "/usr/include/c++/9/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 683 "/usr/include/c++/9/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}

# 1 "/usr/include/c++/9/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/9/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/9/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 703 "/usr/include/c++/9/ostream" 2 3
# 40 "/usr/include/c++/9/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/9/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/9/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/9/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/9/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/9/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/9/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/9/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/9/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/9/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/9/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/9/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/9/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/9/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/9/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/9/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/9/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/9/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/9/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/9/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/9/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/9/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/9/istream" 3
      int
      sync();
# 570 "/usr/include/c++/9/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/9/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/9/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/usr/include/c++/9/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/usr/include/c++/9/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/usr/include/c++/9/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/usr/include/c++/9/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/usr/include/c++/9/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/usr/include/c++/9/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/usr/include/c++/9/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "/usr/include/c++/9/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}

# 1 "/usr/include/c++/9/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/9/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/9/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "/usr/include/c++/9/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "/usr/include/c++/9/istream" 2 3
# 39 "/usr/include/c++/9/sstream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 64 "/usr/include/c++/9/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/usr/include/c++/9/sstream" 3
      basic_stringbuf()
      : __streambuf_type(), _M_mode(ios_base::in | ios_base::out), _M_string()
      { }
# 110 "/usr/include/c++/9/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 123 "/usr/include/c++/9/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(),
 _M_string(__str.data(), __str.size(), __str.get_allocator())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 177 "/usr/include/c++/9/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret(_M_string.get_allocator());
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret.assign(this->pbase(), this->pptr());
     else
       __ret.assign(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 201 "/usr/include/c++/9/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 254 "/usr/include/c++/9/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (__from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 368 "/usr/include/c++/9/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 391 "/usr/include/c++/9/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 425 "/usr/include/c++/9/sstream" 3
      basic_istringstream()
      : __istream_type(), _M_stringbuf(ios_base::in)
      { this->init(&_M_stringbuf); }
# 441 "/usr/include/c++/9/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 459 "/usr/include/c++/9/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 510 "/usr/include/c++/9/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 549 "/usr/include/c++/9/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 583 "/usr/include/c++/9/sstream" 3
      basic_ostringstream()
      : __ostream_type(), _M_stringbuf(ios_base::out)
      { this->init(&_M_stringbuf); }
# 599 "/usr/include/c++/9/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 617 "/usr/include/c++/9/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 668 "/usr/include/c++/9/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 707 "/usr/include/c++/9/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 741 "/usr/include/c++/9/sstream" 3
      basic_stringstream()
      : __iostream_type(), _M_stringbuf(ios_base::out | ios_base::in)
      { this->init(&_M_stringbuf); }
# 755 "/usr/include/c++/9/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 771 "/usr/include/c++/9/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 822 "/usr/include/c++/9/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "/usr/include/c++/9/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/9/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/9/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if ((this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "/usr/include/c++/9/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp(_M_string.get_allocator());
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 880 "/usr/include/c++/9/sstream" 2 3
# 46 "/usr/include/c++/9/complex" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/9/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp>
    complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 122 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      constexpr complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }



      constexpr complex(const complex&) = default;



      template<typename _Up>
        constexpr complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      real() const { return _M_real; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      imag() const { return _M_imag; }
# 173 "/usr/include/c++/9/complex" 3
      void
      real(_Tp __val) { _M_real = __val; }

      void
      imag(_Tp __val) { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);



      complex& operator=(const complex&) = default;



      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      constexpr complex __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = -__y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      bool __fail = true;
      _CharT __ch;
      if (__is >> __ch)
 {
   if (_Traits::eq(__ch, __is.widen('(')))
     {
       _Tp __u;
       if (__is >> __u >> __ch)
  {
    const _CharT __rparen = __is.widen(')');
    if (_Traits::eq(__ch, __rparen))
      {
        __x = __u;
        __fail = false;
      }
    else if (_Traits::eq(__ch, __is.widen(',')))
      {
        _Tp __v;
        if (__is >> __v >> __ch)
   {
     if (_Traits::eq(__ch, __rparen))
       {
         __x = complex<_Tp>(__u, __v);
         __fail = false;
       }
     else
       __is.putback(__ch);
   }
      }
    else
      __is.putback(__ch);
  }
     }
   else
     {
       __is.putback(__ch);
       _Tp __u;
       if (__is >> __u)
  {
    __x = __u;
    __fail = false;
  }
     }
 }
      if (__fail)
 __is.setstate(ios_base::failbit);
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }



  template<typename _Tp>
    constexpr _Tp
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    constexpr _Tp
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }
# 592 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 628 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 658 "/usr/include/c++/9/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {


          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    {
      ;
      return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta));
    }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar<_Tp>(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 795 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 887 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 931 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 959 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 988 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)
    {
      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);

      while (__n >>= 1)
        {
          __x *= __x;
          if (__n % 2)
            __y *= __x;
        }

      return __y;
    }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return __n < 0
 ? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)
        : std::__complex_pow_unsigned(__z, __n);
    }

  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar<_Tp>(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar<_Tp>(pow(__x, __y.real()),
        __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(float __r = 0.0f, float __i = 0.0f)

      : _M_value{ __r, __i } { }







      explicit constexpr complex(const complex<double>&);
      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      imag() const { return __imag__ _M_value; }
# 1122 "/usr/include/c++/9/complex" 3
      void
      real(float __val) { __real__ _M_value = __val; }

      void
      imag(float __val) { __imag__ _M_value = __val; }

      complex&
      operator=(float __f)
      {
 _M_value = __f;
 return *this;
      }

      complex&
      operator+=(float __f)
      {
 _M_value += __f;
 return *this;
      }

      complex&
      operator-=(float __f)
      {
 _M_value -= __f;
 return *this;
      }

      complex&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }




      constexpr complex& operator=(const complex&) = default;


      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   _M_value += __z.__rep();
   return *this;
 }

      template<class _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   _M_value -= __z.__rep();
   return *this;
 }

      template<class _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(double __r = 0.0, double __i = 0.0)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      imag() const { return __imag__ _M_value; }
# 1269 "/usr/include/c++/9/complex" 3
      void
      real(double __val) { __real__ _M_value = __val; }

      void
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
 _M_value = __d;
 return *this;
      }

      complex&
      operator+=(double __d)
      {
 _M_value += __d;
 return *this;
      }

      complex&
      operator-=(double __d)
      {
 _M_value -= __d;
 return *this;
      }

      complex&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }



      constexpr complex& operator=(const complex&) = default;


      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   _M_value = __z.__rep();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   _M_value += __z.__rep();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   _M_value -= __z.__rep();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(long double __r = 0.0L,
     long double __i = 0.0L)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      constexpr complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      imag() const { return __imag__ _M_value; }
# 1416 "/usr/include/c++/9/complex" 3
      void
      real(long double __val) { __real__ _M_value = __val; }

      void
      imag(long double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(long double __r)
      {
 _M_value = __r;
 return *this;
      }

      complex&
      operator+=(long double __r)
      {
 _M_value += __r;
 return *this;
      }

      complex&
      operator-=(long double __r)
      {
 _M_value -= __r;
 return *this;
      }

      complex&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }



      constexpr complex& operator=(const complex&) = default;


      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   _M_value = __z.__rep();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator+=(const complex<_Tp>& __z)
 {
   _M_value += __z.__rep();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator-=(const complex<_Tp>& __z)
 {
   _M_value -= __z.__rep();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator*=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
 operator/=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline constexpr
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);






}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };


}



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);

  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);

  template<typename _Tp> _Tp fabs(const std::complex<_Tp>&);

  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_acos(const std::complex<_Tp>& __z)
    {
      const std::complex<_Tp> __t = std::asin(__z);
      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;
      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());
    }


  inline __complex__ float
  __complex_acos(__complex__ float __z)
  { return __builtin_cacosf(__z); }

  inline __complex__ double
  __complex_acos(__complex__ double __z)
  { return __builtin_cacos(__z); }

  inline __complex__ long double
  __complex_acos(const __complex__ long double& __z)
  { return __builtin_cacosl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acos(const std::complex<_Tp>& __z)
    { return __complex_acos(__z.__rep()); }
# 1632 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_asin(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t(-__z.imag(), __z.real());
      __t = std::asinh(__t);
      return std::complex<_Tp>(__t.imag(), -__t.real());
    }


  inline __complex__ float
  __complex_asin(__complex__ float __z)
  { return __builtin_casinf(__z); }

  inline __complex__ double
  __complex_asin(__complex__ double __z)
  { return __builtin_casin(__z); }

  inline __complex__ long double
  __complex_asin(const __complex__ long double& __z)
  { return __builtin_casinl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asin(const std::complex<_Tp>& __z)
    { return __complex_asin(__z.__rep()); }
# 1668 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atan(const std::complex<_Tp>& __z)
    {
      const _Tp __r2 = __z.real() * __z.real();
      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();

      _Tp __num = __z.imag() + _Tp(1.0);
      _Tp __den = __z.imag() - _Tp(1.0);

      __num = __r2 + __num * __num;
      __den = __r2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),
          _Tp(0.25) * log(__num / __den));
    }


  inline __complex__ float
  __complex_atan(__complex__ float __z)
  { return __builtin_catanf(__z); }

  inline __complex__ double
  __complex_atan(__complex__ double __z)
  { return __builtin_catan(__z); }

  inline __complex__ long double
  __complex_atan(const __complex__ long double& __z)
  { return __builtin_catanl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atan(const std::complex<_Tp>& __z)
    { return __complex_atan(__z.__rep()); }
# 1712 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_acosh(const std::complex<_Tp>& __z)
    {

      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))
     + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));
    }


  inline __complex__ float
  __complex_acosh(__complex__ float __z)
  { return __builtin_cacoshf(__z); }

  inline __complex__ double
  __complex_acosh(__complex__ double __z)
  { return __builtin_cacosh(__z); }

  inline __complex__ long double
  __complex_acosh(const __complex__ long double& __z)
  { return __builtin_cacoshl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acosh(const std::complex<_Tp>& __z)
    { return __complex_acosh(__z.__rep()); }
# 1748 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_asinh(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t((__z.real() - __z.imag())
       * (__z.real() + __z.imag()) + _Tp(1.0),
       _Tp(2.0) * __z.real() * __z.imag());
      __t = std::sqrt(__t);

      return std::log(__t + __z);
    }


  inline __complex__ float
  __complex_asinh(__complex__ float __z)
  { return __builtin_casinhf(__z); }

  inline __complex__ double
  __complex_asinh(__complex__ double __z)
  { return __builtin_casinh(__z); }

  inline __complex__ long double
  __complex_asinh(const __complex__ long double& __z)
  { return __builtin_casinhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asinh(const std::complex<_Tp>& __z)
    { return __complex_asinh(__z.__rep()); }
# 1787 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atanh(const std::complex<_Tp>& __z)
    {
      const _Tp __i2 = __z.imag() * __z.imag();
      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();

      _Tp __num = _Tp(1.0) + __z.real();
      _Tp __den = _Tp(1.0) - __z.real();

      __num = __i2 + __num * __num;
      __den = __i2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),
          _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));
    }


  inline __complex__ float
  __complex_atanh(__complex__ float __z)
  { return __builtin_catanhf(__z); }

  inline __complex__ double
  __complex_atanh(__complex__ double __z)
  { return __builtin_catanh(__z); }

  inline __complex__ long double
  __complex_atanh(const __complex__ long double& __z)
  { return __builtin_catanhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atanh(const std::complex<_Tp>& __z)
    { return __complex_atanh(__z.__rep()); }
# 1831 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    inline _Tp



    fabs(const std::complex<_Tp>& __z)
    { return std::abs(__z); }


  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    arg(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;

      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)
                        : __type();



    }

  template<typename _Tp>
    constexpr inline typename __gnu_cxx::__promote<_Tp>::__type
    imag(_Tp)
    { return _Tp(); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    norm(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __type(__x) * __type(__x);
    }

  template<typename _Tp>
    constexpr inline typename __gnu_cxx::__promote<_Tp>::__type
    real(_Tp __x)
    { return __x; }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const _Up& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const _Tp& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(__type(__x), std::complex<__type>(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x),
        std::complex<__type>(__y));
    }



  template<typename _Tp>
    std::complex<_Tp> proj(const std::complex<_Tp>&);


  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_proj(const std::complex<_Tp>& __z)
    { return __z; }


  inline complex<float>
  __complex_proj(const complex<float>& __z)
  { return __builtin_cprojf(__z.__rep()); }

  inline complex<double>
  __complex_proj(const complex<double>& __z)
  { return __builtin_cproj(__z.__rep()); }

  inline complex<long double>
  __complex_proj(const complex<long double>& __z)
  { return __builtin_cprojl(__z.__rep()); }
# 1948 "/usr/include/c++/9/complex" 3
  template<typename _Tp>
    inline std::complex<_Tp>
    proj(const std::complex<_Tp>& __z)
    { return __complex_proj(__z); }


  template<typename _Tp>
    inline std::complex<typename __gnu_cxx::__promote<_Tp>::__type>
    proj(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return std::proj(std::complex<__type>(__x));
    }

  template<typename _Tp>
    inline
 std::complex<typename __gnu_cxx::__promote<_Tp>::__type>
    conj(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return std::complex<__type>(__x, -__type());
    }



inline namespace literals {
inline namespace complex_literals {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"


  constexpr std::complex<float>
  operator""if(long double __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<float>
  operator""if(unsigned long long __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<double>
  operator""i(long double __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<double>
  operator""i(unsigned long long __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<long double>
  operator""il(long double __num)
  { return std::complex<long double>{0.0L, __num}; }

  constexpr std::complex<long double>
  operator""il(unsigned long long __num)
  { return std::complex<long double>{0.0L, static_cast<long double>(__num)}; }

#pragma GCC diagnostic pop
}
}




}
# 23 "../melder/complex.h" 2

# 23 "../melder/complex.h"
using dcomplex = std::complex <double>;

inline static dcomplex dcomplex_add (dcomplex a, dcomplex b) {
 dcomplex result;
 result. real (a.real() + b.real());
 result. imag (a.imag() + b.imag());
 return result;
}

inline static dcomplex dcomplex_sub (dcomplex a, dcomplex b) {
 dcomplex result;
 result. real (a.real() - b.real());
 result. imag (a.imag() - b.imag());
 return result;
}

inline static dcomplex dcomplex_mul (dcomplex a, dcomplex b) {
 dcomplex result;
 result. real (a.real() * b.real() - a.imag() * b.imag());
 result. imag (a.imag() * b.real() + a.real() * b.imag());
 return result;
}

inline static dcomplex dcomplex_conjugate (dcomplex z) {
 dcomplex result;
 result. real (z.real());
 result. imag (- z.imag());
 return result;
}

inline static dcomplex dcomplex_div (dcomplex a, dcomplex b) {
 dcomplex result;
 if (fabs (b.real()) >= fabs (b.imag())) {
  const double r = b.imag() / b.real();
  const double den = b.real() + r * b.imag();
  result. real ((a.real() + r * a.imag()) / den);
  result. imag ((a.imag() - r * a.real()) / den);
 } else {
  const double r = b.real() / b.imag();
  const double den = b.imag() + r * b.real();
  result. real ((a.real() * r + a.imag()) / den);
  result. imag ((a.imag() * r - a.real()) / den);
 }
 return result;
}

inline static double dcomplex_abs (dcomplex z) {
 const double x = fabs (z.real());
 const double y = fabs (z.imag());
 if (x == 0.0) return y;
 if (y == 0.0) return x;
 if (x > y) {
  const double temp = y / x;
  return x * sqrt (1.0 + temp * temp);
 } else {
  const double temp = x / y;
  return y * sqrt (1.0 + temp * temp);
 }
}

inline static dcomplex dcomplex_rmul (double x, dcomplex a) {
 dcomplex result;
 result. real (x * a.real());
 result. imag (x * a.imag());
 return result;
}

inline static dcomplex dcomplex_exp (dcomplex z) {
 dcomplex result;
 double size = exp (z.real());
 result. real (size * cos (z.imag()));
 result. imag (size * sin (z.imag()));
 return result;
}

dcomplex dcomplex_sqrt (dcomplex z);
# 55 "../melder/melder.h" 2

# 1 "../melder/melder_alloc.h" 1
# 26 "../melder/melder_alloc.h"
void Melder_alloc_init ();
void Melder_message_init ();
void * _Melder_malloc (int64 size);

void * _Melder_malloc_f (int64 size);

void * Melder_realloc (void *pointer, int64 size);
void * Melder_realloc_f (void *pointer, int64 size);
void * _Melder_calloc (int64 numberOfElements, int64 elementSize);

void * _Melder_calloc_f (int64 numberOfElements, int64 elementSize);



void _Melder_free (void **pointer) noexcept;







int64 Melder_allocationCount ();






int64 Melder_deallocationCount ();





int64 Melder_allocationSize ();






int64 Melder_reallocationsInSituCount ();
int64 Melder_movingReallocationsCount ();




namespace MelderArray {

 enum class kInitializationType { RAW = 0, ZERO = 1 };

 byte * _alloc_generic (integer cellSize, integer numberOfCells, kInitializationType initializationType);
 void _free_generic (byte *cells, integer numberOfCells) noexcept;

 template <class T>
 T* _alloc (integer numberOfCells, kInitializationType initializationType) {
  T* result = reinterpret_cast <T*> (MelderArray:: _alloc_generic (sizeof (T), numberOfCells, initializationType));
  return result;
 }

 template <class T>
 void _free (T* cells, integer numberOfCells) noexcept {
  _free_generic (reinterpret_cast <byte *> (cells), numberOfCells);
 }

}

int64 MelderArray_allocationCount ();
int64 MelderArray_deallocationCount ();
int64 MelderArray_cellAllocationCount ();
int64 MelderArray_cellDeallocationCount ();
# 57 "../melder/melder.h" 2
# 1 "../melder/melder_string32.h" 1
# 21 "../melder/melder_string32.h"
using char8 = unsigned char;
using char16 = char16_t;
using char32 = char32_t;
# 42 "../melder/melder_string32.h"
using conststring8 = const char *;
using conststring16 = const char16 *;
using conststringW = const wchar_t *;
using conststring32 = const char32 *;
# 64 "../melder/melder_string32.h"
using mutablestring8 = char *;
using mutablestring16 = char16 *;
using mutablestringW = wchar_t *;
using mutablestring32 = char32 *;




template <class T>
class _autostring {
 T *ptr;
public:

 _autostring () : ptr (nullptr) {

 }



 _autostring (integer length, bool f = false) {
  this -> ptr = ( f ? (T *) _Melder_malloc_f ((length + 1) * (int64) sizeof (T)) : (T *) _Melder_malloc ((length + 1) * (int64) sizeof (T)) );
  this -> ptr [0] = '\0';
  this -> ptr [length] = '\0';
 }



 ~_autostring () {

  if (this -> ptr) _Melder_free ((void **) & (this -> ptr));

 }
 template <class U> T& operator[] (U i) {
  return this -> ptr [i];
 }
 T * get () const {
  return this -> ptr;
 }
# 110 "../melder/melder_string32.h"
 T * transfer () {
  T *tmp = this -> ptr;
  this -> ptr = nullptr;
  return tmp;
 }
 void reset () {
  if (this -> ptr) _Melder_free ((void **) & (this -> ptr));
 }
 void resize (int64 newLength) {
  T *tmp = (T *) Melder_realloc (this -> ptr, (newLength + 1) * (int64) sizeof (T));
  this -> ptr = tmp;
  this -> ptr [newLength] = '\0';
 }
 _autostring& operator= (const _autostring&) = delete;
 _autostring (_autostring &) = delete;
 template <class Y> _autostring (_autostring<Y> &) = delete;
 explicit operator bool () const noexcept { return !! this -> ptr; }



 _autostring (_autostring&& other) noexcept {
  this -> ptr = other.ptr;
  other.ptr = nullptr;
 }
 _autostring& operator= (_autostring&& other) noexcept {
  if (& other != this) {
   if (this -> ptr) _Melder_free ((void **) & (this -> ptr));
   this -> ptr = other.ptr;
   other.ptr = nullptr;
  }
  return *this;
 }
 _autostring&& move () noexcept {
  return static_cast <_autostring&&> (*this);
 }
 void _zero_asInUnion () {
  this -> ptr = nullptr;
 }
};

typedef _autostring <char> autostring8;
typedef _autostring <char16> autostring16;
typedef _autostring <wchar_t> autostringW;
typedef _autostring <char32> autostring32;

autostring32 Melder_dup (conststring32 string );
autostring32 Melder_dup_f (conststring32 string );
# 58 "../melder/melder.h" 2
# 1 "../melder/melder_kar.h" 1
# 25 "../melder/melder_kar.h"
enum {
 mUCD_UPPERCASE_LETTER = (1 << 0),
 mUCD_LOWERCASE_LETTER = (1 << 1),
 mUCD_TITLECASE_LETTER = (1 << 2),
 mUCD_CASED_LETTER = (mUCD_UPPERCASE_LETTER | mUCD_LOWERCASE_LETTER | mUCD_TITLECASE_LETTER),
 mUCD_MODIFIER_LETTER = (1 << 3),
 mUCD_OTHER_LETTER = (1 << 4),
 mUCD_LETTER = (mUCD_CASED_LETTER | mUCD_MODIFIER_LETTER | mUCD_OTHER_LETTER),

 mUCD_NONSPACING_MARK = (1 << 5),
 mUCD_SPACING_MARK = (1 << 6),
 mUCD_ENCLOSING_MARK = (1 << 7),
 mUCD_MARK = (mUCD_NONSPACING_MARK | mUCD_SPACING_MARK | mUCD_ENCLOSING_MARK),

 mUCD_DECIMAL_NUMBER = (1 << 8),
 mUCD_LETTER_NUMBER = (1 << 9),
 mUCD_OTHER_NUMBER = (1 << 10),
 mUCD_NUMBER = (mUCD_DECIMAL_NUMBER | mUCD_LETTER_NUMBER | mUCD_OTHER_NUMBER),

 mUCD_CONNECTOR_PUNCTUATION = (1 << 11),
 mUCD_DASH_PUNCTUATION = (1 << 12),
 mUCD_OPEN_PUNCTUATION = (1 << 13),
 mUCD_CLOSE_PUNCTUATION = (1 << 14),
 mUCD_INITIAL_PUNCTUATION = (1 << 15),
 mUCD_FINAL_PUNCTUATION = (1 << 16),
 mUCD_OTHER_PUNCTUATION = (1 << 17),
 mUCD_PUNCTUATION = (mUCD_CONNECTOR_PUNCTUATION | mUCD_DASH_PUNCTUATION | mUCD_OPEN_PUNCTUATION | mUCD_CLOSE_PUNCTUATION | mUCD_INITIAL_PUNCTUATION | mUCD_FINAL_PUNCTUATION | mUCD_OTHER_PUNCTUATION),

 mUCD_MATH_SYMBOL = (1 << 18),
 mUCD_CURRENCY_SYMBOL = (1 << 19),
 mUCD_MODIFIER_SYMBOL = (1 << 20),
 mUCD_OTHER_SYMBOL = (1 << 21),
 mUCD_SYMBOL = (mUCD_MATH_SYMBOL | mUCD_CURRENCY_SYMBOL | mUCD_MODIFIER_SYMBOL | mUCD_OTHER_SYMBOL),

 mUCD_BREAKING_SPACE = (1 << 22),
 mUCD_NON_BREAKING_SPACE = (1 << 23),
 mUCD_SPACE_SEPARATOR = (mUCD_BREAKING_SPACE | mUCD_NON_BREAKING_SPACE),
 mUCD_LINE_SEPARATOR = (1 << 24),
 mUCD_PARAGRAPH_SEPARATOR = (1 << 25),
 mUCD_NEWLINE = (mUCD_LINE_SEPARATOR | mUCD_PARAGRAPH_SEPARATOR),
 mUCD_SEPARATOR = (mUCD_SPACE_SEPARATOR | mUCD_NEWLINE),

 mUCD_CONTROL = (1 << 26),
 mUCD_FORMAT = (1 << 27),
 mUCD_PRIVATE_USE = (1 << 28),

 mUCD_WORD_CHARACTER = (1 << 29),
 mUCD_NULL = (1 << 30),

 mUCD_ALPHANUMERIC = (mUCD_LETTER | mUCD_NUMBER),
 mUCD_END_OF_INK = (mUCD_SEPARATOR | mUCD_NULL),
 mUCD_END_OF_LINE = (mUCD_NEWLINE | mUCD_NULL),
};

struct UCD_CodePointInfo {
 uint32 features;
 char32 upperCase, lowerCase, titleCase;
 conststring32 decomposed;
 char first, second;
};
extern UCD_CodePointInfo theUnicodeDatabase [1+0x2FA1D];
# 100 "../melder/melder_kar.h"
inline static bool Melder_isHorizontalSpace (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_SPACE_SEPARATOR) != 0;
}
inline static void Melder_skipHorizontalSpace (char32 **p_text) {
 while (Melder_isHorizontalSpace (**p_text)) (*p_text) ++;
}
inline static char32 * Melder_findEndOfHorizontalSpace (char32 *p) {
 while (Melder_isHorizontalSpace (*p)) p ++;
 return p;
}
inline static const char32 * Melder_findEndOfHorizontalSpace (const char32 *p) {
 while (Melder_isHorizontalSpace (*p)) p ++;
 return p;
}

inline static bool Melder_isAsciiHorizontalSpace (char32 kar) {
 return kar == U'\t' || kar == U' ';
}

inline static bool Melder_isVerticalSpace (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_NEWLINE) != 0;
}
inline static bool Melder_isAsciiVerticalSpace (char32 kar) {
 return kar >= 10 && kar <= 13;
}




inline static bool Melder_isHorizontalOrVerticalSpace (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_SEPARATOR) != 0;
}
inline static bool Melder_isAsciiHorizontalOrVerticalSpace (char32 kar) {
 return kar <= 127 && (theUnicodeDatabase [kar]. features & mUCD_SEPARATOR) != 0;
}
inline static void Melder_skipHorizontalOrVerticalSpace (char32 **p_text) {
 while (Melder_isHorizontalOrVerticalSpace (**p_text)) (*p_text) ++;
}
inline static void Melder_skipHorizontalOrVerticalSpace (const char32 **p_text) {
 while (Melder_isHorizontalOrVerticalSpace (**p_text)) (*p_text) ++;
}

inline static bool Melder_isEndOfInk (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_END_OF_INK) != 0;
}
inline static bool Melder_isEndOfLine (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_END_OF_LINE) != 0;
}
inline static bool Melder_isEndOfText (char32 kar) {
 return kar == U'\0';
}
inline static bool Melder_staysWithinInk (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_END_OF_INK) == 0;
}
inline static bool Melder_staysWithinLine (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_END_OF_LINE) == 0;
}
inline static void Melder_skipToEndOfLine (char32 **p_text) {
 while (Melder_staysWithinLine (**p_text)) (*p_text) ++;
}
inline static char32 * Melder_findEndOfInk (char32 *p) {
 while (Melder_staysWithinInk (*p)) p ++;
 return p;
}
inline static const char32 * Melder_findEndOfInk (const char32 *p) {
 while (Melder_staysWithinInk (*p)) p ++;
 return p;
}
inline static char32 * Melder_findEndOfLine (char32 *p) {
 while (Melder_staysWithinLine (*p)) p ++;
 return p;
}
inline static const char32 * Melder_findEndOfLine (const char32 *p) {
 while (Melder_staysWithinLine (*p)) p ++;
 return p;
}




inline static bool Melder_isLetter (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_LETTER) != 0;
}
inline static bool Melder_isAsciiLetter (char32 kar) {
 return kar <= 127 && (theUnicodeDatabase [kar]. features & mUCD_LETTER) != 0;
}




inline static bool Melder_isUpperCaseLetter (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_UPPERCASE_LETTER) != 0;
}
inline static bool Melder_isAsciiUpperCaseLetter (char32 kar) {
 return kar >= U'A' && kar <= U'Z';
}




inline static bool Melder_isLowerCaseLetter (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_LOWERCASE_LETTER) != 0;
}
inline static bool Melder_isAsciiLowerCaseLetter (char32 kar) {
 return kar >= U'a' && kar <= U'z';
}

inline static bool Melder_isTitleCaseLetter (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_TITLECASE_LETTER) != 0;
}
inline static bool Melder_isAsciiTitleCaseLetter (char32 kar) {
 return kar >= U'A' && kar <= U'Z';
}




inline static bool Melder_isDecimalNumber (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_DECIMAL_NUMBER) != 0;
}
inline static bool Melder_isAsciiDecimalNumber (char32 kar) {
 return kar >= U'0' && kar <= U'9';
}




inline static bool Melder_isHexadecimalDigit (char32 kar) {
 return kar >= U'0' && kar <= U'9' || kar >= U'A' && kar <= U'Z' || kar >= U'a' && kar <= U'z';
}




inline static bool Melder_isAlphanumeric (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_ALPHANUMERIC) != 0;
}
inline static bool Melder_isAsciiAlphanumeric (char32 kar) {
 return kar <= 127 && (theUnicodeDatabase [kar]. features & mUCD_ALPHANUMERIC) != 0;
}

inline static bool Melder_isWordCharacter (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_WORD_CHARACTER) != 0;
}
inline static bool Melder_isAsciiWordCharacter (char32 kar) {
 return kar <= 127 && (theUnicodeDatabase [kar]. features & mUCD_WORD_CHARACTER) != 0;
}
# 255 "../melder/melder_kar.h"
inline static bool Melder_isPunctuationOrSymbol (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & (mUCD_PUNCTUATION | mUCD_SYMBOL)) != 0;
}
inline static bool Melder_isAsciiPunctuationOrSymbol (char32 kar) {
 return kar <= 127 && (theUnicodeDatabase [kar]. features & (mUCD_PUNCTUATION | mUCD_SYMBOL)) != 0;
}
inline static bool Melder_isControl (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_CONTROL) != 0;
}
inline static bool Melder_isAsciiControl (char32 kar) {
 return kar <= 127 && (theUnicodeDatabase [kar]. features & mUCD_CONTROL) != 0;
}
inline static bool Melder_isPrintable (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & mUCD_CONTROL) == 0;
}
inline static bool Melder_isAsciiPrintable (char32 kar) {
 return kar <= 127 && (theUnicodeDatabase [kar]. features & mUCD_CONTROL) == 0;
}
inline static bool Melder_hasInk (char32 kar) {
 return kar <= 0x2FA1D && (theUnicodeDatabase [kar]. features & (mUCD_CONTROL | mUCD_SEPARATOR)) == 0;
}
inline static bool Melder_hasAsciiInk (char32 kar) {
 return kar <= 127 && (theUnicodeDatabase [kar]. features & (mUCD_CONTROL | mUCD_SEPARATOR)) == 0;
}




inline static char32 Melder_toUpperCase (char32 kar) {
 return kar <= 0x2FA1D ? theUnicodeDatabase [kar]. upperCase : kar;
}
inline static char32 Melder_toLowerCase (char32 kar) {
 return kar <= 0x2FA1D ? theUnicodeDatabase [kar]. lowerCase : kar;
}
inline static char32 Melder_toTitleCase (char32 kar) {
 return kar <= 0x2FA1D ? theUnicodeDatabase [kar]. titleCase : kar;
}




inline static const char32 * Melder_findInk (conststring32 str) noexcept {
 if (! str)
  return nullptr;
 const char32 *p = & str [0];
 for (; ! Melder_hasInk (*p); p ++) {
  if (*p == U'\0')
   return nullptr;
 }
 return p;
}
inline static const char32 * Melder_findHorizontalOrVerticalSpace (conststring32 str) noexcept {
 if (! str)
  return nullptr;
 const char32 *p = & str [0];
 for (; ! Melder_isHorizontalOrVerticalSpace (*p); p ++)
  if (*p == U'\0')
   return nullptr;
 return p;
}
# 59 "../melder/melder.h" 2
# 1 "../melder/melder_str32.h" 1
# 21 "../melder/melder_str32.h"
inline static integer str16len (conststring16 string) noexcept {
 const char16 *p = & string [0];
 while (*p != u'\0') ++ p;
 return p - string;
}
inline static mutablestring16 str16cpy (mutablestring16 target, conststring16 source) noexcept {
 char16 *p = & target [0];
 while (* source != u'\0') * p ++ = * source ++;
 *p = u'\0';
 return target;
}

inline static integer str32len (conststring32 string) noexcept {
 const char32 *p = & string [0];
 while (*p != U'\0') ++ p;
 return p - string;
}
inline static mutablestring32 str32cpy (mutablestring32 target, conststring32 source) noexcept {
 char32 *p = & target [0];
 while (* source != U'\0') * p ++ = * source ++;
 *p = U'\0';
 return target;
}
inline static mutablestring32 str32cat (mutablestring32 target, conststring32 source) noexcept {
 char32 *p = & target [0];
 while (*p != U'\0') ++ p;
 while (* source != U'\0') * p ++ = * source ++;
 *p = U'\0';
 return target;
}
inline static char32 * stp32cpy (mutablestring32 target, conststring32 source) noexcept {
 char32 *p = & target [0];
 while (* source != U'\0') * p ++ = * source ++;
 *p = U'\0';
 return p;
}
inline static mutablestring32 str32ncpy (mutablestring32 target, conststring32 source, integer n) noexcept {
 char32 *p = & target [0];
 for (; n > 0 && *source != U'\0'; -- n) * p ++ = * source ++;
 for (; n > 0; -- n) * p ++ = U'\0';
 return target;
}

inline static int str32cmp (conststring32 string1, conststring32 string2) noexcept {
 for (;; ++ string1, ++ string2) {
  int32 diff = (int32) *string1 - (int32) *string2;
  if (diff) return (int) diff;
  if (*string1 == U'\0') return 0;
 }
}
inline static int str32cmp_caseInsensitive (conststring32 string1, conststring32 string2) noexcept {
 for (;; ++ string1, ++ string2) {
  int32 diff = (int32) Melder_toLowerCase (*string1) - (int32) Melder_toLowerCase (*string2);
  if (diff) return (int) diff;
  if (*string1 == U'\0') return 0;
 }
}
inline static int str32cmp_optionallyCaseSensitive (conststring32 string1, conststring32 string2, bool caseSensitive) noexcept {
 return caseSensitive ? str32cmp (string1, string2) : str32cmp_caseInsensitive (string1, string2);
}
inline static int str32ncmp (conststring32 string1, conststring32 string2, integer n) noexcept {
 for (; n > 0; -- n, ++ string1, ++ string2) {
  int32 diff = (int32) *string1 - (int32) *string2;
  if (diff) return (int) diff;
  if (*string1 == U'\0') return 0;
 }
 return 0;
}
inline static int str32ncmp_caseInsensitive (conststring32 string1, conststring32 string2, integer n) noexcept {
 for (; n > 0; -- n, ++ string1, ++ string2) {
  int32 diff = (int32) Melder_toLowerCase (*string1) - (int32) Melder_toLowerCase (*string2);
  if (diff) return (int) diff;
  if (*string1 == U'\0') return 0;
 }
 return 0;
}
inline static int str32ncmp_optionallyCaseSensitive (conststring32 string1, conststring32 string2, integer n, bool caseSensitive) noexcept {
 return caseSensitive ? str32ncmp (string1, string2, n) : str32ncmp_caseInsensitive (string1, string2, n);
}

int Melder_cmp (conststring32 string1, conststring32 string2);
int Melder_cmp_caseInsensitive (conststring32 string1, conststring32 string2);
int Melder_ncmp (conststring32 string1, conststring32 string2, integer n);
int Melder_ncmp_caseInsensitive (conststring32 string1, conststring32 string2, integer n);
# 114 "../melder/melder_str32.h"
bool Melder_equ_firstCharacterCaseInsensitive (conststring32 string1, conststring32 string2);



inline static char32 * str32chr (conststring32 string, char32 kar) noexcept {
 for (; *string != kar; ++ string) {
  if (*string == U'\0')
   return nullptr;
 }
 return (char32 *) string;
}
inline static char32 * str32chr_caseInsensitive (conststring32 string, char32 kar) noexcept {
 kar = Melder_toLowerCase (kar);
 for (; Melder_toLowerCase (*string) != kar; ++ string) {
  if (*string == U'\0')
   return nullptr;
 }
 return (char32 *) string;
}
inline static char32 * str32rchr (conststring32 string, char32 kar) noexcept {
 char32 *result = nullptr;
 for (; *string != U'\0'; ++ string) {
  if (*string == kar) result = (char32 *) string;
 }
 return result;
}
inline static char32 * str32rchr_caseInsensitive (conststring32 string, char32 kar) noexcept {
 kar = Melder_toLowerCase (kar);
 char32 *result = nullptr;
 for (; *string != U'\0'; ++ string) {
  if (Melder_toLowerCase (*string) == kar) result = (char32 *) string;
 }
 return result;
}
inline static char32 * str32str (conststring32 string, conststring32 find) noexcept {
 integer length = str32len (find);
 if (length == 0) return (char32 *) string;
 char32 firstCharacter = * find ++;
 do {
  char32 kar;
  do {
   kar = * string ++;
   if (kar == U'\0') return nullptr;
  } while (kar != firstCharacter);
 } while (str32ncmp (string, find, length - 1));
 return (char32 *) (string - 1);
}
inline static char32 * str32str_caseInsensitive (conststring32 string, conststring32 find) noexcept {
 integer length = str32len (find);
 if (length == 0) return (char32 *) string;
 char32 firstCharacter = Melder_toLowerCase (* find ++);
 do {
  char32 kar;
  do {
   kar = Melder_toLowerCase (* string ++);
   if (kar == U'\0') return nullptr;
  } while (kar != firstCharacter);
 } while (str32ncmp_caseInsensitive (string, find, length - 1));
 return (char32 *) (string - 1);
}
inline static char32 * str32str_optionallyCaseSensitive (conststring32 string, conststring32 find, bool caseSensitive) noexcept {
 return caseSensitive ? str32str (string, find) : str32str_caseInsensitive (string, find);
}
inline static integer str32spn (conststring32 string1, conststring32 string2) noexcept {
 const char32 *p = & string1 [0];
 char32 kar1, kar2;
cont:
 kar1 = * p ++;
 for (const char32 *q = & string2 [0]; (kar2 = * q ++) != U'\0';)
  if (kar2 == kar1)
   goto cont;
 return p - 1 - string1;
}
# 60 "../melder/melder.h" 2

# 1 "../melder/enums.h" 1
# 21 "../melder/enums.h"
typedef int (*enum_generic_getValue) (conststring32 text);
# 62 "../melder/melder.h" 2
# 1 "../melder/melder_enums.h" 1
# 19 "../melder/melder_enums.h"
enum class kMelder_number { UNDEFINED = -1, MIN = 1,
 EQUAL_TO = 1,
 NOT_EQUAL_TO = 2,
 LESS_THAN = 3,
 LESS_THAN_OR_EQUAL_TO = 4,
 GREATER_THAN = 5,
 GREATER_THAN_OR_EQUAL_TO = 6,
MAX = 6, DEFAULT = EQUAL_TO }; conststring32 kMelder_number_getText (kMelder_number value); kMelder_number kMelder_number_getValue (conststring32 text); inline static kMelder_number& operator++ (kMelder_number& value) { value = static_cast <kMelder_number> (static_cast <int> (value) + 1); return value; }

enum class kMelder_string { UNDEFINED = -1, MIN = 1,
 EQUAL_TO = 1,
 NOT_EQUAL_TO = 2,
 CONTAINS = 3,
 DOES_NOT_CONTAIN = 4,
 STARTS_WITH = 5,
 DOES_NOT_START_WITH = 6,
 ENDS_WITH = 7,
 DOES_NOT_END_WITH = 8,
 CONTAINS_WORD = 9,
 DOES_NOT_CONTAIN_WORD = 10,
 CONTAINS_WORD_STARTING_WITH = 11,
 DOES_NOT_CONTAIN_WORD_STARTING_WITH = 12,
 CONTAINS_WORD_ENDING_WITH = 13,
 DOES_NOT_CONTAIN_WORD_ENDING_WITH = 14,
 CONTAINS_INK = 15,
 DOES_NOT_CONTAIN_INK = 16,
 CONTAINS_INK_STARTING_WITH = 17,
 DOES_NOT_CONTAIN_INK_STARTING_WITH = 18,
 CONTAINS_INK_ENDING_WITH = 19,
 DOES_NOT_CONTAIN_INK_ENDING_WITH = 20,
 MATCH_REGEXP = 21,
MAX = 21, DEFAULT = EQUAL_TO }; conststring32 kMelder_string_getText (kMelder_string value); kMelder_string kMelder_string_getValue (conststring32 text); inline static kMelder_string& operator++ (kMelder_string& value) { value = static_cast <kMelder_string> (static_cast <int> (value) + 1); return value; }

enum class kMelder_textInputEncoding { UNDEFINED = -1, MIN = 1,
 UTF8 = 1,
 UTF8_THEN_ISO_LATIN1 = 2,
 ISO_LATIN1 = 3,
 UTF8_THEN_WINDOWS_LATIN1 = 4,
 WINDOWS_LATIN1 = 5,
 UTF8_THEN_MACROMAN = 6,
 MACROMAN = 7,





MAX = 7, DEFAULT = UTF8_THEN_ISO_LATIN1 }; conststring32 kMelder_textInputEncoding_getText (kMelder_textInputEncoding value); kMelder_textInputEncoding kMelder_textInputEncoding_getValue (conststring32 text); inline static kMelder_textInputEncoding& operator++ (kMelder_textInputEncoding& value) { value = static_cast <kMelder_textInputEncoding> (static_cast <int> (value) + 1); return value; }


enum class kMelder_textOutputEncoding { UNDEFINED = -1, MIN = 1,
 UTF8 = 1,
 UTF16 = 2,
 ASCII_THEN_UTF16 = 3,
 ISO_LATIN1_THEN_UTF16 = 4,
MAX = 4, DEFAULT = ASCII_THEN_UTF16 }; conststring32 kMelder_textOutputEncoding_getText (kMelder_textOutputEncoding value); kMelder_textOutputEncoding kMelder_textOutputEncoding_getValue (conststring32 text); inline static kMelder_textOutputEncoding& operator++ (kMelder_textOutputEncoding& value) { value = static_cast <kMelder_textOutputEncoding> (static_cast <int> (value) + 1); return value; }

enum class kMelder_asynchronicityLevel { UNDEFINED = -1, MIN = 0,
 SYNCHRONOUS = 0,
 CALLING_BACK = 1,
 INTERRUPTABLE = 2,
 ASYNCHRONOUS = 3,
MAX = 3, DEFAULT = ASYNCHRONOUS }; conststring32 kMelder_asynchronicityLevel_getText (kMelder_asynchronicityLevel value); kMelder_asynchronicityLevel kMelder_asynchronicityLevel_getValue (conststring32 text); inline static kMelder_asynchronicityLevel& operator++ (kMelder_asynchronicityLevel& value) { value = static_cast <kMelder_asynchronicityLevel> (static_cast <int> (value) + 1); return value; }
# 121 "../melder/melder_enums.h"
 enum class kMelder_inputSoundSystem { UNDEFINED = -1, MIN = 1,
  ALSA_VIA_PORTAUDIO = 1,
 MAX = 1, DEFAULT = ALSA_VIA_PORTAUDIO }; conststring32 kMelder_inputSoundSystem_getText (kMelder_inputSoundSystem value); kMelder_inputSoundSystem kMelder_inputSoundSystem_getValue (conststring32 text); inline static kMelder_inputSoundSystem& operator++ (kMelder_inputSoundSystem& value) { value = static_cast <kMelder_inputSoundSystem> (static_cast <int> (value) + 1); return value; }


 enum class kMelder_outputSoundSystem { UNDEFINED = -1, MIN = 1,
  PULSEAUDIO = 1,
  ALSA_VIA_PORTAUDIO = 2,
 MAX = 2, DEFAULT = PULSEAUDIO }; conststring32 kMelder_outputSoundSystem_getText (kMelder_outputSoundSystem value); kMelder_outputSoundSystem kMelder_outputSoundSystem_getValue (conststring32 text); inline static kMelder_outputSoundSystem& operator++ (kMelder_outputSoundSystem& value) { value = static_cast <kMelder_outputSoundSystem> (static_cast <int> (value) + 1); return value; }
# 63 "../melder/melder.h" 2







# 1 "../melder/melder_tensor.h" 1
# 21 "../melder/melder_tensor.h"
#pragma mark - TENSOR
# 49 "../melder/melder_tensor.h"
template <typename T> class vector;
template <typename T> class constvector;
template <typename T> class vectorview;
template <typename T> class constvectorview;
template <typename T> class autovector;
template <typename T> class matrix;
template <typename T> class constmatrix;
template <typename T> class matrixview;
template <typename T> class constmatrixview;
template <typename T> class automatrix;

template <typename T>
class vector {
public:
 T *cells = nullptr;
 integer size = 0;
public:
 vector () = default;
 explicit vector (T *givenCells, integer givenSize)
  : cells (givenCells), size (givenSize) { }
 explicit vector (matrix<T> const& mat)
  : vector (mat.cells, mat.nrow * mat.ncol) { }





 vector (vector const& other)
  = default;






 vector& operator= (vector const& other)
  = default;







 vector (autovector<T> const& other)
  = delete;
# 104 "../melder/melder_tensor.h"
 vector& operator= (const autovector<T>&)
  = delete;
 T& operator[] (integer i) const {
  return this -> cells [i - 1];
 }






 vector<T> part (integer first, integer last) const {
  const integer newSize = last - (first - 1);



  if (newSize <= 0)
   return vector<T> ();
  ((first >= 1 && first <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 122, "first >= 1 && first <= our size"), abort ()));
  ((last >= 1 && last <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 123, "last >= 1 && last <= our size"), abort ()));
  return vector<T> (& this -> cells [first - 1], newSize);
 }
 matrix<T> asmatrix (integer nrow, integer ncol) {
  ((nrow * ncol <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 127, "nrow * ncol <= our size"), abort ()));
  return matrix (this -> cells, nrow, ncol);
 }
 T *begin () const { return this -> cells; }
 T *end () const { return this -> cells + this -> size; }
 T *asArgumentToFunctionThatExpectsZeroBasedArray () const { return this -> cells; }
 T *asArgumentToFunctionThatExpectsOneBasedArray () const { return this -> cells - 1; }
};

template <typename T>
class vectorview {
public:
 T * firstCell = nullptr;
 integer size = 0;
 integer stride = 1;
 vectorview ()
  = default;
 vectorview (const vector<T>& other)
  : firstCell (other.cells), size (other.size), stride (1) { }
 vectorview (const autovector<T>& other)
  = delete;
 explicit vectorview (T * const firstCell_, integer const size_, integer const stride_)
  : firstCell (firstCell_), size (size_), stride (stride_) { }
 T& operator[] (integer i) const {
  return this -> firstCell [(i - 1) * this -> stride];
 }
 vectorview<T> part (integer first, integer last) const {
  const integer newSize = last - (first - 1);
  if (newSize <= 0)
   return vectorview<T> ();
  ((first >= 1 && first <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 157, "first >= 1 && first <= our size"), abort ()));
  ((last >= 1 && last <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 158, "last >= 1 && last <= our size"), abort ()));
  return vectorview<T> (& this -> operator[] (first), newSize, this -> stride);
 }
 matrixview<T> asmatrixview (integer nrow, integer ncol) {
  ((nrow * ncol <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 162, "nrow * ncol <= our size"), abort ()));
  return matrixview (this -> cells, nrow, ncol, ncol * this -> stride, this -> stride);
 }
 T *begin () const { return & this -> operator[] (1); }
 T *end () const { return & this -> operator[] (this -> size + 1); }
 T *asArgumentToFunctionThatExpectsZeroBasedArray () const { return & this -> operator[] [1]; }
 T *asArgumentToFunctionThatExpectsOneBasedArray () const { return & this -> operator[] [0]; }
};

template <typename T>
class constvector {
public:
 const T *cells = nullptr;
 integer size = 0;
public:
 constvector ()
  = default;
 explicit constvector (const T *givenCells, integer givenSize)
  : cells (givenCells), size (givenSize) { }
 explicit constvector (constmatrix<T> const& mat)
  : constvector (mat.cells, mat.nrow * mat.ncol) { }
 constvector (vector<T> const& other)
  : constvector (other.cells, other.size) { }


 const T& operator[] (integer i) const {
  return this -> cells [i - 1];
 }
 constvector<T> part (integer first, integer last) const {
  const integer newSize = last - (first - 1);
  if (newSize <= 0)
   return constvector<T> (nullptr, 0);
  ((first >= 1 && first <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 194, "first >= 1 && first <= our size"), abort ()));
  ((last >= 1 && last <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 195, "last >= 1 && last <= our size"), abort ()));
  return constvector<T> (& this -> cells [first - 1], newSize);
 }
 constmatrix<T> asmatrix (integer nrow, integer ncol) {
  ((nrow * ncol <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 199, "nrow * ncol <= our size"), abort ()));
  return constmatrix (this -> cells, nrow, ncol);
 }
 const T *begin () const { return this -> cells; }
 const T *end () const { return this -> cells + this -> size; }
 const T *asArgumentToFunctionThatExpectsZeroBasedArray () const { return this -> cells; }
 const T *asArgumentToFunctionThatExpectsOneBasedArray () const { return this -> cells - 1; }
};

template <typename T>
class constvectorview {
public:
 const T * firstCell = nullptr;
 integer size = 0;
 integer stride = 1;
 constvectorview () = default;
 explicit constvectorview (const T * const firstCell_, integer const size_, integer const stride_)
  : firstCell (firstCell_), size (size_), stride (stride_) { }
 constvectorview (vectorview<T> const& other)
  : constvectorview (other.firstCell, other.size, other.stride) { }
 constvectorview (constvector<T> const& other)
  : constvectorview (other.cells, other.size, 1) { }
 constvectorview (vector<T> const& other)
  : constvectorview (other.cells, other.size, 1) { }
 constvectorview (autovector<T> const& other)
  = delete;
 T const& operator[] (integer i) const {
  return this -> firstCell [(i - 1) * this -> stride];
 }
 constvectorview<T> part (integer first, integer last) const {
  const integer newSize = last - (first - 1);
  if (newSize <= 0)
   return constvectorview<T> ();
  ((first >= 1 && first <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 232, "first >= 1 && first <= our size"), abort ()));
  ((last >= 1 && last <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 233, "last >= 1 && last <= our size"), abort ()));
  return constvectorview<T> (& this -> operator[] (first), newSize, this -> stride);
 }
 constmatrixview<T> asmatrixview (integer nrow, integer ncol) {
  ((nrow * ncol <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 237, "nrow * ncol <= our size"), abort ()));
  return constmatrixview (this -> cells, nrow, ncol, ncol * this -> stride, this -> stride);
 }
 const T *begin () const { return & this -> operator[] (1); }
 const T *end () const { return & this -> operator[] (this -> size + 1); }
 const T *asArgumentToFunctionThatExpectsZeroBasedArray () const { return & this -> operator[] [1]; }
 const T *asArgumentToFunctionThatExpectsOneBasedArray () const { return & this -> operator[] [0]; }
};
# 253 "../melder/melder_tensor.h"
template <typename T>
class autovector : public vector<T> {
 integer _capacity = 0;
public:
 autovector ()
  : vector<T> (nullptr, 0) { }
 explicit autovector (integer givenSize, MelderArray::kInitializationType initializationType) {
  ((givenSize >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 260, "givenSize >= 0"), abort ()));
  this -> cells = ( givenSize == 0 ? nullptr : MelderArray:: _alloc <T> (givenSize, initializationType) );
  this -> size = givenSize;
  this -> _capacity = givenSize;
 }
 ~autovector () {
  this -> reset ();
  this -> _capacity = 0;
 }
 vector<T> get () const { return vector<T> (this -> cells, this -> size); }
 vectorview<T> all () const { return vectorview<T> (this -> cells, this -> size, 1); }
 void adoptFromAmbiguousOwner (vector<T> given) {
  this -> reset();
  this -> cells = given.cells;
  this -> size = given.size;
  this -> _capacity = given.size;
 }
 vector<T> releaseToAmbiguousOwner () {
  T *oldCells = this -> cells;
  this -> cells = nullptr;
  integer oldSize = this -> size;
  this -> _capacity = 0;
  return vector<T> (oldCells, oldSize);
 }



 autovector (autovector const& other) = delete;
 autovector& operator= (autovector const& other) = delete;




 autovector (autovector&& other) noexcept : vector<T> { other.get() } {
  other.cells = nullptr;
  other.size = 0;
  other._capacity = 0;
 }
 autovector& operator= (autovector&& other) noexcept {
  if (other.cells != this -> cells) {
   this -> reset ();
   this -> cells = other.cells;
   this -> size = other.size;
   this -> _capacity = other._capacity;
   other.cells = nullptr;
   other.size = 0;
   other._capacity = 0;
  }
  return *this;
 }
 void reset () noexcept {
  if (this -> cells) {
   MelderArray:: _free (this -> cells, this -> _capacity);
   this -> cells = nullptr;
   this -> _capacity = 0;
  }
  this -> size = 0;
 }
 autovector&& move () noexcept { return static_cast <autovector&&> (*this); }




 void initWithCapacity (integer capacity, MelderArray::kInitializationType initializationType = MelderArray::kInitializationType::ZERO) {
  if (capacity > 0)
   this -> cells = MelderArray:: _alloc <T> (capacity, initializationType);
  this -> size = 0;
  this -> _capacity = capacity;
 }
# 344 "../melder/melder_tensor.h"
 void resize (integer newSize, MelderArray::kInitializationType initializationType = MelderArray::kInitializationType::ZERO) {
  if (newSize > this -> _capacity) {






   integer newCapacity = newSize + this -> size + 10;



   T *newCells = MelderArray:: _alloc <T> (newCapacity, initializationType);



   for (integer i = 1; i <= this -> size; i ++)
    newCells [i - 1] = std::move (this -> cells [i - 1]);
   if (this -> cells)
    MelderArray:: _free (this -> cells, this -> _capacity);
   this -> cells = newCells;
   this -> _capacity = newCapacity;
  }
  this -> size = newSize;
 }
 void insert (integer position, const T& value) {
  resize (this -> size + 1, MelderArray::kInitializationType::RAW);
  ((position >= 1 && position <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 371, "position >= 1 && position <= our size"), abort ()));
  for (integer i = this -> size; i > position; i --)
   this -> cells [i - 1] = std::move (this -> cells [i - 2]);
  this -> cells [position - 1] = value;
 }
 T* append () {
  resize (this -> size + 1, MelderArray::kInitializationType::ZERO);
  return & this -> cells [this -> size - 1];
 }
 void remove (integer position) {
  ((position >= 1 && position <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 381, "position >= 1 && position <= our size"), abort ()));
  for (integer i = position; i < this -> size; i ++)
   this -> cells [i - 1] = std::move (this -> cells [i]);
  resize (this -> size - 1);
 }
};

template <typename T>
autovector<T> newvectorraw (integer size) {
 return autovector<T> (size, MelderArray::kInitializationType::RAW);
}
template <typename T>
autovector<T> newvectorzero (integer size) {
 return autovector<T> (size, MelderArray::kInitializationType::ZERO);
}
template <typename T>
autovector<T> newvectorcopy (constvectorview<T> source) {
 autovector<T> result = newvectorraw<T> (source.size);
 for (integer i = 1; i <= source.size; i ++)
  result [i] = source [i];
 return result;
}
template <typename T>
autovector<T> newvectorcopy (vectorview<T> source) {
 return newvectorcopy (constvectorview<T> (source));
}

template <typename T>
class matrix {
public:
 T *cells = nullptr;
 integer nrow = 0, ncol = 0;
public:
 matrix ()
  = default;
 explicit matrix (T *givenCells, integer givenNrow, integer givenNcol)
  : cells (givenCells), nrow (givenNrow), ncol (givenNcol) { }
 matrix (matrix const& other)
  = default;
 matrix& operator= (matrix const& other)
  = default;
 matrix (automatrix<T> const& other)
  = delete;
 matrix& operator= (automatrix<T> const& other)
  = delete;
 explicit matrix (vector<T> const& vec, integer givenNrow, integer givenNcol)
  : matrix (vec.cells, givenNrow, givenNcol)
 {
  ((givenNrow * givenNcol <= vec. size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 429, "givenNrow * givenNcol <= vec. size"), abort ()));
 }
 vector<T> operator[] (integer rowNumber) const {
  return vector<T> (this -> cells + (rowNumber - 1) * this -> ncol, this -> ncol);
 }
 vector<T> row (integer rowNumber) const {
  ((rowNumber >= 1 && rowNumber <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 435, "rowNumber >= 1 && rowNumber <= our nrow"), abort ()));
  ((this -> cells) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 436, "our cells"), abort ()));
  return vector<T> (this -> cells + (rowNumber - 1) * this -> ncol, this -> ncol);
 }
 vectorview<T> column (integer columnNumber) const {
  ((columnNumber >= 1 && columnNumber <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 440, "columnNumber >= 1 && columnNumber <= our ncol"), abort ()));
  return vectorview<T> (this -> cells + (columnNumber - 1), this -> nrow, this -> ncol);
 }
 vectorview<T> diagonal () const {
  return vectorview<T> (this -> cells, std::min (this -> nrow, this -> ncol), this -> ncol + 1);
 }
 matrixview<T> horizontalBand (integer firstRow, integer lastRow) const {
  const integer newNrow = lastRow - (firstRow - 1);
  if (newNrow <= 0)
   return matrixview<T> ();
  ((firstRow >= 1 && firstRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 450, "firstRow >= 1 && firstRow <= our nrow"), abort ()));
  ((lastRow >= 1 && lastRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 451, "lastRow >= 1 && lastRow <= our nrow"), abort ()));
  return matrixview<T> (this -> cells + (firstRow - 1) * this -> ncol, newNrow, this -> ncol, this -> ncol, 1);
 }
 matrixview<T> verticalBand (integer firstColumn, integer lastColumn) const {
  const integer newNcol = lastColumn - (firstColumn - 1);
  if (newNcol <= 0)
   return matrixview<T> ();
  ((firstColumn >= 1 && firstColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 458, "firstColumn >= 1 && firstColumn <= our ncol"), abort ()));
  ((lastColumn >= 1 && lastColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 459, "lastColumn >= 1 && lastColumn <= our ncol"), abort ()));
  return matrixview<T> (this -> cells + (firstColumn - 1), this -> nrow, newNcol, this -> ncol, 1);
 }
 matrixview<T> part (integer firstRow, integer lastRow, integer firstColumn, integer lastColumn) const {
  const integer newNrow = lastRow - (firstRow - 1), newNcol = lastColumn - (firstColumn - 1);
  if (newNrow <= 0 || newNcol <= 0)
   return matrixview<T> ();
  ((firstRow >= 1 && firstRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 466, "firstRow >= 1 && firstRow <= our nrow"), abort ()));
  ((lastRow >= 1 && lastRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 467, "lastRow >= 1 && lastRow <= our nrow"), abort ()));
  ((firstColumn >= 1 && firstColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 468, "firstColumn >= 1 && firstColumn <= our ncol"), abort ()));
  ((lastColumn >= 1 && lastColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 469, "lastColumn >= 1 && lastColumn <= our ncol"), abort ()));
  return matrixview<T> (
   this -> cells + (firstRow - 1) * this -> ncol + (firstColumn - 1),
   newNrow, newNcol, this -> ncol, 1
  );
 }
 matrixview<T> transpose () const {
  return matrixview<T> (this -> cells, this -> ncol, this -> nrow, 1, this -> ncol);
 }
 vector<T> asvector () const {
  return vector<T> (this -> cells, this -> nrow * this -> ncol);
 }
 vector<T> asvector (integer size) const {
  ((size <= this -> nrow * this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 482, "size <= our nrow * our ncol"), abort ()));
  return vector<T> (this -> cells, size);
 }
};

template <typename T>
class matrixview {
public:
 T * firstCell = nullptr;
 integer nrow = 0, ncol = 0;
             integer rowStride = 0, colStride = 1;





 matrixview ()
  = default;
# 514 "../melder/melder_tensor.h"
 explicit matrixview (T * firstCell_, integer nrow_, integer ncol_, integer rowStride_, integer colStride_)
  : firstCell (firstCell_), nrow (nrow_), ncol (ncol_), rowStride (rowStride_), colStride (colStride_) { }




 matrixview (matrix<T> const& other)
  : matrixview (other.cells, other.nrow, other.ncol, other.ncol, 1_integer) { }
# 530 "../melder/melder_tensor.h"
 matrixview (automatrix<T> const& other)
  = delete;
 explicit matrixview (vectorview<T> const& vec, integer givenNrow, integer givenNcol) :
   matrixview (vec.cells, givenNrow, givenNcol, givenNcol * vec.stride, vec.stride)
 {
  ((givenNrow * givenNcol <= vec. size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 535, "givenNrow * givenNcol <= vec. size"), abort ()));
 }
 vectorview<T> operator[] (integer rowNumber) const {
  return vectorview<T> (this -> firstCell + (rowNumber - 1) * this -> rowStride, this -> ncol, this -> colStride);
 }
 vectorview<T> row (integer rowNumber) const {
  ((rowNumber >= 1 && rowNumber <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 541, "rowNumber >= 1 && rowNumber <= our nrow"), abort ()));
  return vectorview<T> (this -> firstCell + (rowNumber - 1) * this -> rowStride, this -> ncol, this -> colStride);
 }
 vectorview<T> column (integer columnNumber) const {
  ((columnNumber >= 1 && columnNumber <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 545, "columnNumber >= 1 && columnNumber <= our ncol"), abort ()));
  return vectorview<T> (this -> firstCell + (columnNumber - 1) * this -> colStride, this -> nrow, this -> rowStride);
 }
 vectorview<T> diagonal () const {
  return vectorview<T> (this -> firstCell, std::min (this -> nrow, this -> ncol), this -> rowStride + this -> colStride);
 }
 matrixview<T> verticalBand (integer firstColumn, integer lastColumn) const {
  const integer newNcol = lastColumn - (firstColumn - 1);
  if (newNcol <= 0)
   return matrixview<T> ();
  ((firstColumn >= 1 && firstColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 555, "firstColumn >= 1 && firstColumn <= our ncol"), abort ()));
  ((lastColumn >= 1 && lastColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 556, "lastColumn >= 1 && lastColumn <= our ncol"), abort ()));
  return matrixview<T> (this -> firstCell + (firstColumn - 1) * this -> colStride,
    this -> nrow, newNcol, this -> rowStride, this -> colStride);
 }
 matrixview<T> part (integer firstRow, integer lastRow, integer firstColumn, integer lastColumn) const {
  const integer newNrow = lastRow - (firstRow - 1), newNcol = lastColumn - (firstColumn - 1);
  if (newNrow <= 0 || newNcol <= 0)
   return matrixview<T> ();
  ((firstRow >= 1 && firstRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 564, "firstRow >= 1 && firstRow <= our nrow"), abort ()));
  ((lastRow >= 1 && lastRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 565, "lastRow >= 1 && lastRow <= our nrow"), abort ()));
  ((firstColumn >= 1 && firstColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 566, "firstColumn >= 1 && firstColumn <= our ncol"), abort ()));
  ((lastColumn >= 1 && lastColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 567, "lastColumn >= 1 && lastColumn <= our ncol"), abort ()));
  return matrixview<T> (
   this -> firstCell + (firstRow - 1) * this -> rowStride + (firstColumn - 1) * this -> colStride,
   newNrow, newNcol, this -> rowStride, this -> colStride
  );
 }
 matrixview<T> transpose () const {
  return matrixview<T> (this -> firstCell, this -> ncol, this -> nrow, this -> colStride, this -> rowStride);
 }
};

template <typename T>
class constmatrix {
public:
 const T *cells = nullptr;
 integer nrow = 0, ncol = 0;
 constmatrix () = default;
 explicit constmatrix (const T *givenCells, integer givenNrow, integer givenNcol)
  : cells (givenCells), nrow (givenNrow), ncol (givenNcol) { }
 constmatrix (matrix<T> const& other)
  : constmatrix (other.cells, other.nrow, other.ncol) { }
 explicit constmatrix (vector<T> const& vec, integer givenNrow, integer givenNcol)
  : constmatrix (vec.cells, givenNrow, givenNcol)
 {
  ((givenNrow * givenNcol <= vec. size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 591, "givenNrow * givenNcol <= vec. size"), abort ()));
 }
 constvector<T> operator[] (integer rowNumber) const {
  return constvector<T> (this -> cells + (rowNumber - 1) * this -> ncol, this -> ncol);
 }
 constvector<T> row (integer rowNumber) const {
  ((rowNumber >= 1 && rowNumber <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 597, "rowNumber >= 1 && rowNumber <= our nrow"), abort ()));
  ((this -> cells) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 598, "our cells"), abort ()));
  return constvector<T> (this -> cells + (rowNumber - 1) * this -> ncol, this -> ncol);
 }
 constvectorview<T> column (integer columnNumber) const {
  ((columnNumber >= 1 && columnNumber <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 602, "columnNumber >= 1 && columnNumber <= our ncol"), abort ()));
  return constvectorview<T> (this -> cells + (columnNumber - 1), this -> nrow, this -> ncol);
 }
 constvectorview<T> diagonal () const {
  return constvectorview<T> (this -> cells, std::min (this -> nrow, this -> ncol), this -> ncol + 1);
 }
 constmatrixview<T> horizontalBand (integer firstRow, integer lastRow) const {
  const integer newNrow = lastRow - (firstRow - 1);
  if (newNrow <= 0)
   return constmatrixview<T> ();
  ((firstRow >= 1 && firstRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 612, "firstRow >= 1 && firstRow <= our nrow"), abort ()));
  ((lastRow >= 1 && lastRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 613, "lastRow >= 1 && lastRow <= our nrow"), abort ()));
  return constmatrixview<T> (this -> cells + (firstRow - 1) * this -> ncol, newNrow, this -> ncol, this -> ncol, 1);
 }
 constmatrixview<T> verticalBand (integer firstColumn, integer lastColumn) const {
  const integer newNcol = lastColumn - (firstColumn - 1);
  if (newNcol <= 0)
   return constmatrixview<T> ();
  ((firstColumn >= 1 && firstColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 620, "firstColumn >= 1 && firstColumn <= our ncol"), abort ()));
  ((lastColumn >= 1 && lastColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 621, "lastColumn >= 1 && lastColumn <= our ncol"), abort ()));
  return constmatrixview<T> (this -> cells + (firstColumn - 1), this -> nrow, newNcol, this -> ncol, 1);
 }
 constmatrixview<T> part (integer firstRow, integer lastRow, integer firstColumn, integer lastColumn) const {
  const integer newNrow = lastRow - (firstRow - 1), newNcol = lastColumn - (firstColumn - 1);
  if (newNrow <= 0 || newNcol <= 0)
   return constmatrixview<T> ();
  ((firstRow >= 1 && firstRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 628, "firstRow >= 1 && firstRow <= our nrow"), abort ()));
  ((lastRow >= 1 && lastRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 629, "lastRow >= 1 && lastRow <= our nrow"), abort ()));
  ((firstColumn >= 1 && firstColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 630, "firstColumn >= 1 && firstColumn <= our ncol"), abort ()));
  ((lastColumn >= 1 && lastColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 631, "lastColumn >= 1 && lastColumn <= our ncol"), abort ()));
  return constmatrixview<T> (
   this -> cells + (firstRow - 1) * this -> ncol + (firstColumn - 1),
   newNrow, newNcol, this -> ncol, 1
  );
 }
 constmatrixview<T> transpose () const {
  return constmatrixview<T> (this -> cells, this -> ncol, this -> nrow, 1, this -> ncol);
 }
 constvector<T> asvector () const {
  return constvector<T> (this -> cells, this -> nrow * this -> ncol);
 }
 constvector<T> asvector (integer size) const {
  ((size <= this -> nrow * this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 644, "size <= our nrow * our ncol"), abort ()));
  return constvector<T> (this -> cells, size);
 }
};

template <typename T>
class constmatrixview {
public:
 const T * firstCell = nullptr;
 integer nrow = 0, ncol = 0;
 integer rowStride = 0, colStride = 1;
 constmatrixview ()
  = default;
 explicit constmatrixview (const T * const firstCell_, integer const nrow_, integer const ncol_, integer const rowStride_, integer const colStride_)
  : firstCell (firstCell_), nrow (nrow_), ncol (ncol_), rowStride (rowStride_), colStride (colStride_) { }
 constmatrixview (const constmatrix<T>& other)
  : constmatrixview (other.cells, other.nrow, other.ncol, other.ncol, 1_integer) { }
 constmatrixview (const matrix<T>& other)
  : constmatrixview (other.cells, other.nrow, other.ncol, other.ncol, 1_integer) { }
 constmatrixview (const automatrix<T>& other)
  = delete;
 constmatrixview (matrixview<T> const& other)
  : constmatrixview (other.firstCell, other.nrow, other.ncol, other.rowStride, other.colStride) { }
 explicit constmatrixview (constvectorview<T> const& vec, integer givenNrow, integer givenNcol) :
   constmatrixview (vec.cells, givenNrow, givenNcol, givenNcol * vec.stride, vec.stride)
 {
  ((givenNrow * givenNcol <= vec. size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 670, "givenNrow * givenNcol <= vec. size"), abort ()));
 }
 constvectorview<T> operator[] (integer i) const {
  return constvectorview<T> (this -> firstCell + (i - 1) * this -> rowStride, this -> ncol, this -> colStride);
 }
 constvectorview<T> row (integer rowNumber) const {
  ((rowNumber >= 1 && rowNumber <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 676, "rowNumber >= 1 && rowNumber <= our nrow"), abort ()));
  return constvectorview<T> (this -> firstCell + (rowNumber - 1) * this -> rowStride, this -> ncol, this -> colStride);
 }
 constvectorview<T> column (integer columnNumber) const {
  ((columnNumber >= 1 && columnNumber <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 680, "columnNumber >= 1 && columnNumber <= our ncol"), abort ()));
  return constvectorview<T> (this -> firstCell + (columnNumber - 1) * this -> colStride, this -> nrow, this -> rowStride);
 }
 constvectorview<T> diagonal () const {
  return constvectorview<T> (this -> firstCell, std::min (this -> nrow, this -> ncol), this -> rowStride + this -> colStride);
 }
 constmatrixview<T> verticalBand (integer firstColumn, integer lastColumn) const {
  const integer newNcol = lastColumn - (firstColumn - 1);
  if (newNcol <= 0)
   return constmatrixview<T> ();
  ((firstColumn >= 1 && firstColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 690, "firstColumn >= 1 && firstColumn <= our ncol"), abort ()));
  ((lastColumn >= 1 && lastColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 691, "lastColumn >= 1 && lastColumn <= our ncol"), abort ()));
  return constmatrixview<T> (this -> firstCell + (firstColumn - 1) * this -> colStride,
    this -> nrow, newNcol, this -> rowStride, this -> colStride);
 }
 constmatrixview<T> part (integer firstRow, integer lastRow, integer firstColumn, integer lastColumn) const {
  const integer newNrow = lastRow - (firstRow - 1), newNcol = lastColumn - (firstColumn - 1);
  if (newNrow <= 0 || newNcol <= 0)
   return constmatrixview<T> ();
  ((firstRow >= 1 && firstRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 699, "firstRow >= 1 && firstRow <= our nrow"), abort ()));
  ((lastRow >= 1 && lastRow <= this -> nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 700, "lastRow >= 1 && lastRow <= our nrow"), abort ()));
  ((firstColumn >= 1 && firstColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 701, "firstColumn >= 1 && firstColumn <= our ncol"), abort ()));
  ((lastColumn >= 1 && lastColumn <= this -> ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 702, "lastColumn >= 1 && lastColumn <= our ncol"), abort ()));
  return constmatrixview<T> (
   this -> firstCell
   + (firstRow - 1) * this -> rowStride
   + (firstColumn - 1) * this -> colStride,
   newNrow, newNcol,
   this -> rowStride, this -> colStride
  );
 }
 constmatrixview<T> transpose () const {
  return constmatrixview<T> (this -> firstCell, this -> ncol, this -> nrow, this -> colStride, this -> rowStride);
 }
};
# 723 "../melder/melder_tensor.h"
template <typename T>
class automatrix : public matrix<T> {
public:
 automatrix ()
  : matrix<T> (nullptr, 0, 0) { }
 explicit automatrix (integer givenNrow, integer givenNcol, MelderArray::kInitializationType initializationType) {
  ((givenNrow >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 729, "givenNrow >= 0"), abort ()));
  ((givenNcol >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 730, "givenNcol >= 0"), abort ()));
  this -> cells = ( givenNrow == 0 || givenNcol == 0 ? nullptr
    : MelderArray:: _alloc <T> (givenNrow * givenNcol, initializationType) );
  this -> nrow = givenNrow;
  this -> ncol = givenNcol;
 }
 ~automatrix () {
  if (this -> cells)
   MelderArray:: _free (this -> cells, this -> nrow * this -> ncol);
 }

 const matrix<T>& get () const
  { return *this; }
 matrixview<T> all () const {
  return matrixview<T> (this -> cells, this -> nrow, this -> ncol, this -> ncol, 1);
 }
 void adoptFromAmbiguousOwner (matrix<T> const& given) {
  this -> reset();
  this -> cells = given.cells;
  this -> nrow = given.nrow;
  this -> ncol = given.ncol;
 }
 matrix<T> releaseToAmbiguousOwner () {
  T *oldCells = this -> cells;
  this -> cells = nullptr;
  return matrix<T> (oldCells, this -> nrow, this -> ncol);
 }



 automatrix (automatrix const& other)
  = delete;
 automatrix& operator= (automatrix const& other)
  = delete;




 automatrix (automatrix&& other) noexcept
   : matrix<T> (other.get())
 {
  other.cells = nullptr;
  other.nrow = 0;
  other.ncol = 0;
 }
 automatrix& operator= (automatrix&& other) noexcept {
  if (other.cells != this -> cells) {
   if (this -> cells)
    MelderArray:: _free (this -> cells, this -> nrow * this -> ncol);
   this -> cells = other.cells;
   this -> nrow = other.nrow;
   this -> ncol = other.ncol;
   other.cells = nullptr;
   other.nrow = 0;
   other.ncol = 0;
  }
  return *this;
 }
 void resize (integer newNrow, integer newNcol, MelderArray::kInitializationType initializationType = MelderArray::kInitializationType::ZERO) {
  if (newNrow > this -> nrow || newNcol > this -> ncol) {
   integer const newNumberOfCells = newNrow * newNcol;
   T *newCells = MelderArray:: _alloc <T> (newNumberOfCells, initializationType);
   integer const numberOfRowsToCopy = std::min (this -> nrow, newNrow);
   integer const numberOfColumnsToCopy = std::min (this -> ncol, newNcol);
   for (integer irow = 1; irow <= numberOfRowsToCopy; irow ++)
    for (integer icol = 1; icol <= numberOfColumnsToCopy; icol ++)
     newCells [(irow - 1) * newNcol + (icol - 1)] = std::move (this -> cells [(irow - 1) * this -> ncol + (icol - 1)]);
   if (this -> cells)
    MelderArray:: _free (this -> cells, this -> nrow * this -> ncol);
   this -> cells = newCells;
  } else if (newNcol == this -> ncol) {

  } else {



   for (integer irow = 2; irow <= newNrow; irow ++)
    for (integer icol = 1; icol <= newNcol; icol ++)
     this -> cells [(irow - 1) * newNcol + (icol - 1)] = std::move (this -> cells [(irow - 1) * this -> ncol + (icol - 1)]);
  }
  this -> nrow = newNrow;
  this -> ncol = newNcol;
 }
 void reset () noexcept {
  if (this -> cells) {
   MelderArray:: _free (this -> cells, this -> nrow * this -> ncol);
   this -> cells = nullptr;
  }
  this -> nrow = 0;
  this -> ncol = 0;
 }
 automatrix&& move () noexcept { return static_cast <automatrix&&> (*this); }
};

template <typename T>
automatrix<T> newmatrixraw (integer nrow, integer ncol) {
 return automatrix<T> (nrow, ncol, MelderArray::kInitializationType::RAW);
}
template <typename T>
automatrix<T> newmatrixzero (integer nrow, integer ncol) {
 return automatrix<T> (nrow, ncol, MelderArray::kInitializationType::ZERO);
}
template <typename T>
void matrixcopy (matrixview<T> const& target, constmatrixview<T> const& source) {
 ((source.nrow == target.nrow && source.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 834, "source.nrow == target.nrow && source.ncol == target.ncol"), abort ()));
 for (integer irow = 1; irow <= source.nrow; irow ++)
  for (integer icol = 1; icol <= source.ncol; icol ++)
   target [irow] [icol] = source [irow] [icol];
}
template <typename T>
void matrixcopy (matrixview<T> const& target, matrixview<T> const& source) {
 matrixcopy (target, constmatrixview<T> (source));
}
template <typename T>
automatrix<T> newmatrixcopy (constmatrixview<T> const& source) {
 automatrix<T> result = newmatrixraw<T> (source.nrow, source.ncol);
 matrixcopy (result.all(), source);
 return result;
}
template <typename T>
automatrix<T> newmatrixcopy (matrixview<T> const& source) {
 return newmatrixcopy<T> (constmatrixview<T> (source));
}

template <typename T>
void assertCell (constvector<T> const& x, integer elementNumber) {
 ((elementNumber >= 1 && elementNumber <= x.size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 856, "elementNumber >= 1 && elementNumber <= x.size"), abort ()));
}
template <typename T>
void assertRow (constmatrix<T> const& x, integer rowNumber) {
 ((rowNumber >= 1 && rowNumber <= x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 860, "rowNumber >= 1 && rowNumber <= x.nrow"), abort ()));
}
template <typename T>
void assertColumn (constmatrix<T> const& x, integer columnNumber) {
 ((columnNumber >= 1 && columnNumber <= x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 864, "columnNumber >= 1 && columnNumber <= x.ncol"), abort ()));
}
template <typename T>
void assertCell (constmatrix<T> const& x, integer rowNumber, integer columnNumber) {
 assertRow (x, rowNumber);
 assertColumn (x, columnNumber);
}
template <typename T>
automatrix<T> newmatrixpart (constmatrix<T> const& x, integer firstRow, integer lastRow, integer firstColumn, integer lastColumn) {
 assertCell (x, firstRow, firstColumn);
 assertCell (x, lastRow, lastColumn);
 integer numberOfRows = lastRow - (firstRow - 1);
 ((numberOfRows >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 876, "numberOfRows >= 0"), abort ()));
 integer numberOfColumns = lastColumn - (firstColumn - 1);
 ((numberOfColumns >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 878, "numberOfColumns >= 0"), abort ()));
 automatrix<T> result = newmatrixraw<T> (numberOfRows, numberOfColumns);
 for (integer irow = 1; irow <= numberOfRows; irow ++)
  for (integer icol = 1; icol <= numberOfColumns; icol ++)
   result [irow] [icol] = x [firstRow - 1 + irow] [firstColumn - 1 + icol];
 return result;
}
template <typename T>
automatrix<T> newmatrixpart (matrix<T> const& x, integer firstRow, integer lastRow, integer firstColumn, integer lastColumn) {
 newmatrixpart (constmatrix<T> (x), firstRow, lastRow, firstColumn, lastColumn);
}

template <typename T>
class autotensor3;

template <typename T>
class tensor3 {
public:
 T * cells = nullptr;
 integer ndim1 = 0, ndim2 = 0, ndim3 = 0;
 integer stride1 = 0, stride2 = 0, stride3 = 1;
 tensor3 ()
  = default;
 tensor3 (autotensor3<T> const& other)
  = delete;
 explicit tensor3 (T * cells_,
  integer ndim1_, integer ndim2_, integer ndim3_,
  integer stride1_, integer stride2_, integer stride3_
 ) :
  cells (cells_),
  ndim1 (ndim1_), ndim2 (ndim2_), ndim3 (ndim3_),
  stride1 (stride1_), stride2 (stride2_), stride3 (stride3_)
 { }
 matrixview<T> operator[] (integer dim1) const {
  return matrixview<T> (this -> cells + (dim1 - 1) * this -> stride1, this -> ndim2, this -> ndim3, this -> stride2, this -> stride3);
 }
 vectorview<T> line1 (integer dim2, integer dim3) const {
  ((dim2 >= 1 && dim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 915, "dim2 >= 1 && dim2 <= our ndim2"), abort ()));
  ((dim3 >= 1 && dim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 916, "dim3 >= 1 && dim3 <= our ndim3"), abort ()));
  return vectorview<T> (
   this -> cells
   + (dim2 - 1) * this -> stride2
   + (dim3 - 1) * this -> stride3,
   this -> ndim1,
   this -> stride1
  );
 }
 vectorview<T> line2 (integer dim1, integer dim3) const {
  ((dim1 >= 1 && dim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 926, "dim1 >= 1 && dim1 <= our ndim1"), abort ()));
  ((dim3 >= 1 && dim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 927, "dim3 >= 1 && dim3 <= our ndim3"), abort ()));
  return vectorview<T> (
   this -> cells
   + (dim1 - 1) * this -> stride1
   + (dim3 - 1) * this -> stride3,
   this -> ndim2,
   this -> stride2
  );
 }
 vectorview<T> line3 (integer dim1, integer dim2) const {
  ((dim1 >= 1 && dim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 937, "dim1 >= 1 && dim1 <= our ndim1"), abort ()));
  ((dim2 >= 1 && dim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 938, "dim2 >= 1 && dim2 <= our ndim2"), abort ()));
  return vectorview<T> (
   this -> cells
   + (dim1 - 1) * this -> stride1
   + (dim2 - 1) * this -> stride2,
   this -> ndim3,
   this -> stride3
  );
 }
 matrixview<T> plane12 (integer dim3) const {
  ((dim3 >= 1 && dim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 948, "dim3 >= 1 && dim3 <= our ndim3"), abort ()));
  return matrixview<T> (
   this -> cells
   + (dim3 - 1) * this -> stride3,
   this -> ndim1, this -> ndim2,
   this -> stride1, this -> stride2
  );
 }
 matrixview<T> plane13 (integer dim2) const {
  ((dim2 >= 1 && dim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 957, "dim2 >= 1 && dim2 <= our ndim2"), abort ()));
  return matrixview<T> (
   this -> cells
   + (dim2 - 1) * this -> stride2,
   this -> ndim1, this -> ndim3,
   this -> stride1, this -> stride3
  );
 }
 matrixview<T> plane23 (integer dim1) const {
  ((dim1 >= 1 && dim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 966, "dim1 >= 1 && dim1 <= our ndim1"), abort ()));
  return matrixview<T> (
   this -> cells
   + (dim1 - 1) * this -> stride1,
   this -> ndim2, this -> ndim3,
   this -> stride2, this -> stride3
  );
 }
 tensor3<T> part (
  integer firstDim1, integer lastDim1,
  integer firstDim2, integer lastDim2,
  integer firstDim3, integer lastDim3
 ) const {
  const integer newNdim1 = lastDim1 - (firstDim1 - 1);
  const integer newNdim2 = lastDim2 - (firstDim2 - 1);
  const integer newNdim3 = lastDim3 - (firstDim3 - 1);
  if (newNdim1 <= 0 || newNdim2 <= 0 || newNdim3 <= 0)
   return tensor3<T> ();
  ((firstDim1 >= 1 && firstDim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 984, "firstDim1 >= 1 && firstDim1 <= our ndim1"), abort ()));
  ((lastDim1 >= 1 && lastDim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 985, "lastDim1 >= 1 && lastDim1 <= our ndim1"), abort ()));
  ((firstDim2 >= 1 && firstDim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 986, "firstDim2 >= 1 && firstDim2 <= our ndim2"), abort ()));
  ((lastDim2 >= 1 && lastDim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 987, "lastDim2 >= 1 && lastDim2 <= our ndim2"), abort ()));
  ((firstDim3 >= 1 && firstDim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 988, "firstDim3 >= 1 && firstDim3 <= our ndim3"), abort ()));
  ((lastDim3 >= 1 && lastDim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 989, "lastDim3 >= 1 && lastDim3 <= our ndim3"), abort ()));
  return tensor3<T> (
   this -> cells
   + (firstDim1 - 1) * this -> stride1
   + (firstDim2 - 1) * this -> stride2
   + (firstDim3 - 1) * this -> stride3,
   newNdim1, newNdim2, newNdim3,
   this -> stride1, this -> stride2, this -> stride3
  );
 }
};

template <typename T>
class consttensor3 {
public:
 const T * cells = nullptr;
 integer ndim1 = 0, ndim2 = 0, ndim3 = 0;
 integer stride1 = 0, stride2 = 0, stride3 = 1;
 consttensor3 ()
  = default;
 consttensor3 (const autotensor3<T>& other)
  = delete;
 explicit consttensor3 (const T * cells_,
  integer ndim1_, integer ndim2_, integer ndim3_,
  integer stride1_, integer stride2_, integer stride3_
 ) :
  cells (cells_),
  ndim1 (ndim1_), ndim2 (ndim2_), ndim3 (ndim3_),
  stride1 (stride1_), stride2 (stride2_), stride3 (stride3_)
 { }
 consttensor3 (tensor3<T> ten) :
  cells (ten.cells),
  ndim1 (ten.ndim1), ndim2 (ten.ndim2), ndim3 (ten.ndim3),
  stride1 (ten.stride1), stride2 (ten.stride2), stride3 (ten.stride3)
 { }
 constmatrixview<T> operator[] (integer dim1) const {
  return constmatrixview<T> (this -> cells + (dim1 - 1) * this -> stride1, this -> ndim2, this -> ndim3, this -> stride2, this -> stride3);
 }
 constvectorview<T> line1 (integer dim2, integer dim3) const {
  ((dim2 >= 1 && dim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1028, "dim2 >= 1 && dim2 <= our ndim2"), abort ()));
  ((dim3 >= 1 && dim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1029, "dim3 >= 1 && dim3 <= our ndim3"), abort ()));
  return constvectorview<T> (
   this -> cells
   + (dim2 - 1) * this -> stride2
   + (dim3 - 1) * this -> stride3,
   this -> nidm1,
   this -> stride1
  );
 }
 constvectorview<T> line2 (integer dim1, integer dim3) const {
  ((dim1 >= 1 && dim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1039, "dim1 >= 1 && dim1 <= our ndim1"), abort ()));
  ((dim3 >= 1 && dim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1040, "dim3 >= 1 && dim3 <= our ndim3"), abort ()));
  return constvectorview<T> (
   this -> cells
   + (dim1 - 1) * this -> stride1
   + (dim3 - 1) * this -> stride3,
   this -> ndim2,
   this -> stride2
  );
 }
 constvectorview<T> line3 (integer dim1, integer dim2) const {
  ((dim1 >= 1 && dim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1050, "dim1 >= 1 && dim1 <= our ndim1"), abort ()));
  ((dim2 >= 1 && dim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1051, "dim2 >= 1 && dim2 <= our ndim2"), abort ()));
  return constvectorview<T> (
   this -> cells
   + (dim1 - 1) * this -> stride1
   + (dim2 - 1) * this -> stride2,
   this -> ndim3,
   this -> stride3
  );
 }
 constmatrixview<T> plane12 (integer dim3) const {
  ((dim3 >= 1 && dim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1061, "dim3 >= 1 && dim3 <= our ndim3"), abort ()));
  return constmatrixview<T> (
   this -> cells
   + (dim3 - 1) * this -> stride3,
   this -> ndim1, this -> ndim2,
   this -> stride1, this -> stride2
  );
 }
 constmatrixview<T> plane13 (integer dim2) const {
  ((dim2 >= 1 && dim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1070, "dim2 >= 1 && dim2 <= our ndim2"), abort ()));
  return constmatrixview<T> (
   this -> cells
   + (dim2 - 1) * this -> stride2,
   this -> ndim1, this -> ndim3,
   this -> stride1, this -> stride3
  );
 }
 constmatrixview<T> plane23 (integer dim1) const {
  ((dim1 >= 1 && dim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1079, "dim1 >= 1 && dim1 <= our ndim1"), abort ()));
  return constmatrixview<T> (
   this -> cells
   + (dim1 - 1) * this -> stride1,
   this -> ndim2, this -> ndim3,
   this -> stride2, this -> stride3
  );
 }
 consttensor3<T> part (
  integer firstDim1, integer lastDim1,
  integer firstDim2, integer lastDim2,
  integer firstDim3, integer lastDim3
 ) const {
  const integer newNdim1 = lastDim1 - (firstDim1 - 1);
  const integer newNdim2 = lastDim2 - (firstDim2 - 1);
  const integer newNdim3 = lastDim3 - (firstDim3 - 1);
  if (newNdim1 <= 0 || newNdim2 <= 0 || newNdim3 <= 0)
   return consttensor3<T> ();
  ((firstDim1 >= 1 && firstDim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1097, "firstDim1 >= 1 && firstDim1 <= our ndim1"), abort ()));
  ((lastDim1 >= 1 && lastDim1 <= this -> ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1098, "lastDim1 >= 1 && lastDim1 <= our ndim1"), abort ()));
  ((firstDim2 >= 1 && firstDim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1099, "firstDim2 >= 1 && firstDim2 <= our ndim2"), abort ()));
  ((lastDim2 >= 1 && lastDim2 <= this -> ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1100, "lastDim2 >= 1 && lastDim2 <= our ndim2"), abort ()));
  ((firstDim3 >= 1 && firstDim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1101, "firstDim3 >= 1 && firstDim3 <= our ndim3"), abort ()));
  ((lastDim3 >= 1 && lastDim3 <= this -> ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1102, "lastDim3 >= 1 && lastDim3 <= our ndim3"), abort ()));
  return consttensor3<T> (
   this -> cells
   + (firstDim1 - 1) * this -> stride1
   + (firstDim2 - 1) * this -> stride2
   + (firstDim3 - 1) * this -> stride3,
   newNdim1, newNdim2, newNdim3,
   this -> stride1, this -> stride2, this -> stride3
  );
 }
};

template <typename T>
class autotensor3 : public tensor3<T> {
public:
 autotensor3 () = default;
 explicit autotensor3 (integer givenNdim1, integer givenNdim2, integer givenNdim3, MelderArray::kInitializationType initializationType) {
  ((givenNdim1 >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1119, "givenNdim1 >= 0"), abort ()));
  ((givenNdim2 >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1120, "givenNdim2 >= 0"), abort ()));
  ((givenNdim3 >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1121, "givenNdim3 >= 0"), abort ()));
  this -> cells = ( givenNdim1 == 0 || givenNdim2 == 0 || givenNdim3 == 0 ? nullptr
    : MelderArray:: _alloc <T> (givenNdim3 * givenNdim2 * givenNdim1, initializationType) );
  this -> ndim1 = givenNdim1;
  this -> ndim2 = givenNdim2;
  this -> ndim3 = givenNdim3;
  this -> stride3 = 1;
  this -> stride2 = givenNdim3;
  this -> stride1 = givenNdim3 * givenNdim2;
 }
 ~autotensor3 () {
  if (this -> cells)
   MelderArray:: _free (this -> cells, this -> ndim1 * this -> ndim2 * this -> ndim3);
 }

 const tensor3<T>& get () const { return *this; }
 void adoptFromAmbiguousOwner (tensor3<T> const& given) {
  this -> reset();
  this -> cells = given.cells;
  this -> ndim1 = given.ndim1;
  this -> ndim2 = given.ndim2;
  this -> ndim3 = given.ndim3;
  this -> stride1 = given.stride1;
  this -> stride2 = given.stride2;
  this -> stride3 = given.stride3;
 }
 tensor3<T> releaseToAmbiguousOwner () {
  T * oldCells = this -> cells;
  this -> cells = nullptr;
  return tensor3<T> (oldCells, this -> ndim1, this -> ndim2, this -> ndim3, this -> stride1, this -> stride2, this -> stride3);
 }



 autotensor3 (const autotensor3&) = delete;
 autotensor3& operator= (const autotensor3&) = delete;




 autotensor3 (autotensor3&& other) noexcept : tensor3<T> (other.get()) {
  other.cells = nullptr;
  other.ndim1 = 0;
  other.ndim2 = 0;
  other.ndim3 = 0;
 }
 autotensor3& operator= (autotensor3&& other) noexcept {
  if (other.cells != this -> cells) {
   if (this -> cells)
    MelderArray:: _free (this -> cells, this -> ndim1 * this -> ndim2 * this -> ndim3);
   this -> cells = other.cells;
   this -> ndim1 = other.ndim1;
   this -> ndim2 = other.ndim2;
   this -> ndim3 = other.ndim3;
   other.cells = nullptr;
   other.ndim1 = 0;
   other.ndim2 = 0;
   other.ndim3 = 0;
  }
  return *this;
 }
 void reset () noexcept {
  if (this -> cells) {
   MelderArray:: _free (this -> cells, this -> ndim1 * this -> ndim2 * this -> ndim3);
   this -> cells = nullptr;
  }
  this -> ndim1 = 0;
  this -> ndim2 = 0;
  this -> ndim3 = 0;
 }
 autotensor3&& move () noexcept { return static_cast <autotensor3&&> (*this); }
};
template <typename T>
autotensor3<T> newtensor3raw (integer ndim1, integer ndim2, integer ndim3) {
 return autotensor3<T> (ndim1, ndim2, ndim3, MelderArray::kInitializationType::RAW);
}
template <typename T>
autotensor3<T> newtensor3zero (integer ndim1, integer ndim2, integer ndim3) {
 return autotensor3<T> (ndim1, ndim2, ndim3, MelderArray::kInitializationType::ZERO);
}
template <typename T>
void tensor3copy (tensor3<T> const& target, consttensor3<T> const& source) {
 ((source.ndim1 == target.ndim1 && source.ndim2 == target.ndim2 && source.ndim3 == target.ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1203, "source.ndim1 == target.ndim1 && source.ndim2 == target.ndim2 && source.ndim3 == target.ndim3"), abort ()));
 for (integer idim1 = 1; idim1 <= source.ndim1; idim1 ++)
  for (integer idim2 = 1; idim2 <= source.ndim2; idim2 ++)
   for (integer idim3 = 1; idim3 <= source.ndim3; idim3 ++)
    target [idim1] [idim2] [idim3] = source [idim1] [idim2] [idim3];
}
template <typename T>
void tensor3copy (tensor3<T> const& target, tensor3<T> const& source) {
 tensor3copy (target, consttensor3<T> (source));
}
template <typename T>
autotensor3<T> newtensor3copy (consttensor3<T> const& source) {
 autotensor3<T> result = newtensor3raw<T> (source.ndim1, source.ndim2, source.ndim3);
 tensor3copy (result.get(), source);
 return result;
}
template <typename T>
autotensor3<T> newtensor3copy (tensor3<T> const& source) {
 return newtensor3copy<T> (consttensor3<T> (source));
}
template <typename T>
void assertDim1 (consttensor3<T> const& x, integer dim1) {
 ((dim1 >= 1 && dim1 <= x.ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1225, "dim1 >= 1 && dim1 <= x.ndim1"), abort ()));
}
template <typename T>
void assertDim2 (consttensor3<T> const& x, integer dim2) {
 ((dim2 >= 1 && dim2 <= x.ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1229, "dim2 >= 1 && dim2 <= x.ndim2"), abort ()));
}
template <typename T>
void assertDim3 (consttensor3<T> const& x, integer dim3) {
 ((dim3 >= 1 && dim3 <= x.ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1233, "dim3 >= 1 && dim3 <= x.ndim3"), abort ()));
}
template <typename T>
void assertCell (consttensor3<T> const& x, integer dim1, integer dim2, integer dim3) {
 assertDim1 (x, dim1);
 assertDim2 (x, dim2);
 assertDim3 (x, dim3);
}
template <typename T>
autotensor3<T> newtensor3part (consttensor3<T> const& x,
 integer firstDim1, integer lastDim1,
 integer firstDim2, integer lastDim2,
 integer firstDim3, integer lastDim3
) {
 assertCell (x, firstDim1, firstDim2, firstDim3);
 assertCell (x, lastDim1, lastDim2, lastDim3);
 integer ndim1 = lastDim1 - (firstDim1 - 1);
 ((ndim1 >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1250, "ndim1 >= 0"), abort ()));
 integer ndim2 = lastDim2 - (firstDim2 - 1);
 ((ndim2 >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1252, "ndim2 >= 0"), abort ()));
 integer ndim3 = lastDim3 - (firstDim3 - 1);
 ((ndim3 >= 0) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1254, "ndim3 >= 0"), abort ()));
 autotensor3<T> result = newtensor3raw<T> (ndim1, ndim2, ndim3);
 for (integer idim1 = 1; idim1 <= ndim1; idim1 ++)
  for (integer idim2 = 1; idim2 <= ndim2; idim2 ++)
   for (integer idim3 = 1; idim3 <= ndim3; idim3 ++)
    result [idim1] [idim2] [idim3] = x [firstDim1 - 1 + idim1] [firstDim2 - 1 + idim2] [firstDim3 - 1 + idim3];
 return result;
}
template <typename T>
autotensor3<T> newtensor3part (tensor3<T> const& x,
 integer firstDim1, integer lastDim1,
 integer firstDim2, integer lastDim2,
 integer firstDim3, integer lastDim3
) {
 return newtensor3part (consttensor3<T> (x), firstDim1, lastDim1, firstDim2, lastDim2, firstDim3, lastDim3);
}






using VEC = vector <double>;
using VECVU = vectorview <double>;
using constVEC = constvector <double>;
using constVECVU = constvectorview <double>;
using autoVEC = autovector <double>;
inline autoVEC newVECraw (integer size) {
 return newvectorraw <double> (size);
}
inline autoVEC newVECzero (integer size) {
 return newvectorzero <double> (size);
}
inline autoVEC newVECcopy (constVECVU const& source) {
 return newvectorcopy (source);
}
# 1299 "../melder/melder_tensor.h"
using INTVEC = vector <integer>;
using INTVECVU = vectorview <integer>;
using constINTVEC = constvector <integer>;
using constINTVECVU = constvectorview <integer>;
using autoINTVEC = autovector <integer>;
inline autoINTVEC newINTVECraw (integer size) {
 return newvectorraw <integer> (size);
}
inline autoINTVEC newINTVECzero (integer size) {
 return newvectorzero <integer> (size);
}
inline autoINTVEC newINTVECcopy (constINTVECVU const& source) {
 return newvectorcopy (source);
}

using BOOLVEC = vector <bool>;
using BOOLVECVU = vectorview <bool>;
using constBOOLVEC = constvector <bool>;
using constBOOLVECVU = constvectorview <bool>;
using autoBOOLVEC = autovector <bool>;
inline autoBOOLVEC newBOOLVECraw (integer size) {
 return newvectorraw <bool> (size);
}
inline autoBOOLVEC newBOOLVECzero (integer size) {
 return newvectorzero <bool> (size);
}
inline autoBOOLVEC newBOOLVECcopy (constBOOLVECVU const& source) {
 return newvectorcopy (source);
}

using BYTEVEC = vector <byte>;
using BYTEVECVU = vectorview <byte>;
using constBYTEVEC = constvector <byte>;
using constBYTEVECVU = constvectorview <byte>;
using autoBYTEVEC = autovector <byte>;
inline autoBYTEVEC newBYTEVECraw (integer size) {
 return newvectorraw <byte> (size);
}
inline autoBYTEVEC newBYTEVECzero (integer size) {
 return newvectorzero <byte> (size);
}
inline autoBYTEVEC newBYTEVECcopy (constBYTEVECVU const& source) {
 return newvectorcopy (source);
}

using COMPVEC = vector <dcomplex>;
using COMPVECVU = vectorview <dcomplex>;
using constCOMPVEC = constvector <dcomplex>;
using constCOMPVECVU = constvectorview <dcomplex>;
using autoCOMPVEC = autovector <dcomplex>;
inline autoCOMPVEC newCOMPVECraw (integer size) {
 return newvectorraw <dcomplex> (size);
}
inline autoCOMPVEC newCOMPVECzero (integer size) {
 return newvectorzero <dcomplex> (size);
}
inline autoCOMPVEC newCOMPVECcopy (constCOMPVECVU const& source) {
 return newvectorcopy (source);
}

using MAT = matrix <double>;
using MATVU = matrixview <double>;
using constMAT = constmatrix <double>;
using constMATVU = constmatrixview <double>;
using autoMAT = automatrix <double>;
inline autoMAT newMATraw (integer nrow, integer ncol) {
 return newmatrixraw <double> (nrow, ncol);
}
inline autoMAT newMATzero (integer nrow, integer ncol) {
 return newmatrixzero <double> (nrow, ncol);
}
inline autoMAT newMATcopy (constMATVU source) {
 return newmatrixcopy (source);
}
inline autoMAT newMATpart (const constMAT& source,
 integer firstRow, integer lastRow,
 integer firstColumn, integer lastColumn
) {
 return newmatrixpart (source, firstRow, lastRow, firstColumn, lastColumn);
}

using TEN3 = tensor3 <double>;
using constTEN3 = consttensor3 <double>;
using autoTEN3 = autotensor3 <double>;
inline autoTEN3 newTEN3raw (integer ndim1, integer ndim2, integer ndim3) {
 return newtensor3raw <double> (ndim1, ndim2, ndim3);
}
inline autoTEN3 newTEN3zero (integer ndim1, integer ndim2, integer ndim3) {
 return newtensor3zero <double> (ndim1, ndim2, ndim3);
}
inline autoTEN3 newTEN3copy (constTEN3 source) {
 return newtensor3copy (source);
}
inline autoTEN3 newTEN3part (const constTEN3& source,
 integer firstDim1, integer lastDim1,
 integer firstDim2, integer lastDim2,
 integer firstDim3, integer lastDim3
) {
 return newtensor3part (source, firstDim1, lastDim1, firstDim2, lastDim2, firstDim3, lastDim3);
}

using INTMAT = matrix <integer>;
using INTMATVU = matrixview <integer>;
using constINTMAT = constmatrix <integer>;
using constINTMATVU = constmatrixview <integer>;
using autoINTMAT = automatrix <integer>;
inline autoINTMAT newINTMATraw (integer nrow, integer ncol) {
 return newmatrixraw <integer> (nrow, ncol);
}
inline autoINTMAT newINTMATzero (integer nrow, integer ncol) {
 return newmatrixzero <integer> (nrow, ncol);
}
inline autoINTMAT newINTMATcopy (constINTMATVU source) {
 return newmatrixcopy (source);
}

using BOOLMAT = matrix <bool>;
using BOOLMATVU = matrixview <bool>;
using constBOOLMAT = constmatrix <bool>;
using constBOOLMATVU = constmatrixview <bool>;
using autoBOOLMAT = automatrix <bool>;
inline autoBOOLMAT newBOOLMATraw (integer nrow, integer ncol) {
 return newmatrixraw <bool> (nrow, ncol);
}
inline autoBOOLMAT newBOOLMATzero (integer nrow, integer ncol) {
 return newmatrixzero <bool> (nrow, ncol);
}
inline autoBOOLMAT newBOOLMATcopy (constBOOLMATVU source) {
 return newmatrixcopy (source);
}

using BYTEMAT = matrix <byte>;
using BYTEMATVU = matrixview <byte>;
using constBYTEMAT = constmatrix <byte>;
using constBYTEMATVU = constmatrixview <byte>;
using autoBYTEMAT = automatrix <byte>;
inline autoBYTEMAT newBYTEMATraw (integer nrow, integer ncol) {
 return newmatrixraw <byte> (nrow, ncol);
}
inline autoBYTEMAT newBYTEMATzero (integer nrow, integer ncol) {
 return newmatrixzero <byte> (nrow, ncol);
}
inline autoBYTEMAT newBYTEMATcopy (constBYTEMATVU source) {
 return newmatrixcopy (source);
}

conststring32 Melder_VEC (constVECVU const& value);
conststring32 Melder_MAT (constMATVU const& value);

inline void operator<<= (INTVECVU const& target, constINTVECVU const& source) {
 ((target.size == source.size) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1449, "target.size == source.size"), abort ()));
 for (integer i = 1; i <= target.size; i ++)
  target [i] = source [i];
}
inline void operator<<= (TEN3 const& target, constTEN3 const& source) {
 ((target.ndim1 == source.ndim1) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1454, "target.ndim1 == source.ndim1"), abort ()));
 ((target.ndim2 == source.ndim2) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1455, "target.ndim2 == source.ndim2"), abort ()));
 ((target.ndim3 == source.ndim3) ? (void) (0) : (Melder_assert_ ("../melder/melder_tensor.h", 1456, "target.ndim3 == source.ndim3"), abort ()));
 for (integer idim1 = 1; idim1 <= target.ndim1; idim1 ++)
  for (integer idim2 = 1; idim2 <= target.ndim2; idim2 ++)
   for (integer idim3 = 1; idim3 <= target.ndim3; idim3 ++)
    target [idim1] [idim2] [idim3] = source [idim1] [idim2] [idim3];
}
# 71 "../melder/melder.h" 2
# 1 "../melder/melder_colour.h" 1
# 21 "../melder/melder_colour.h"
struct MelderColour {
 double red, green, blue, transparency;
 explicit MelderColour () :
  red (0.0), green (0.0), blue (0.0), transparency (0.0) {}
 explicit MelderColour (double greyValue) :
  red (Melder_clipped (0.0, greyValue, 1.0)), green (red), blue (red), transparency (0.0) {}
 explicit MelderColour (double initialRed, double initialGreen, double initialBlue) :
  red (initialRed), green (initialGreen), blue (initialBlue), transparency (0.0) {}
 explicit MelderColour (double initialRed, double initialGreen, double initialBlue, double initialTransparency) :
  red (initialRed), green (initialGreen), blue (initialBlue), transparency (initialTransparency) {}
 explicit MelderColour (constVEC const& vec);
 bool valid () const {
  return isdefined (this -> red);
 }
 bool isGrey () const {
  return this -> red == this -> green && this -> green == this -> blue;
 }
};

extern MelderColour Melder_BLACK, Melder_WHITE, Melder_RED, Melder_GREEN, Melder_BLUE,
 Melder_CYAN, Melder_MAGENTA, Melder_YELLOW, Melder_MAROON, Melder_LIME, Melder_NAVY, Melder_TEAL,
 Melder_PURPLE, Melder_OLIVE, Melder_PINK, Melder_SILVER, Melder_GREY, Melder_WINDOW_BACKGROUND_COLOUR;

MelderColour MelderColour_fromColourName (conststring32 colourName);





MelderColour MelderColour_fromNumberString (conststring32 numberString);

MelderColour MelderColour_fromRGBString (conststring32 rgbString);

MelderColour MelderColour_fromColourNameOrNumberStringOrRGBString (conststring32 string);

MelderColour MelderColour_fromColourNameOrRGBString (conststring32 string);

conststring32 MelderColour_nameRGB (MelderColour colour);
conststring32 MelderColour_namePrettyOrNull (MelderColour colour);
conststring32 MelderColour_name (MelderColour colour);

static inline bool MelderColour_equal (MelderColour colour1, MelderColour colour2) {
 return
  colour1. red == colour2. red &&
  colour1. green == colour2. green &&
  colour1. blue == colour2. blue &&
  colour1. transparency == colour2. transparency;
}
MelderColour Melder_cyclingBackgroundColour (integer category);
MelderColour Melder_cyclingTextColour (integer category);
# 72 "../melder/melder.h" 2
# 1 "../melder/melder_ftoa.h" 1
# 26 "../melder/melder_ftoa.h"
conststring32 Melder_integer (int64 value) noexcept;
conststring8 Melder8_integer (int64 value) noexcept;

conststring32 Melder_bigInteger (int64 value) noexcept;
conststring8 Melder8_bigInteger (int64 value) noexcept;

conststring32 Melder_boolean (bool value) noexcept;
conststring8 Melder8_boolean (bool value) noexcept;


conststring32 Melder_onoff (bool value) noexcept;
conststring8 Melder8_onoff (bool value) noexcept;

conststring32 Melder_kleenean (kleenean value) noexcept;
conststring8 Melder8_kleenean (kleenean value) noexcept;





conststring32 Melder_double (double value) noexcept;
conststring8 Melder8_double (double value) noexcept;




conststring32 Melder_single (double value) noexcept;
conststring8 Melder8_single (double value) noexcept;




conststring32 Melder_half (double value) noexcept;
conststring8 Melder8_half (double value) noexcept;




conststring32 Melder_fixed (double value, integer precision) noexcept;
conststring8 Melder8_fixed (double value, integer precision) noexcept;




conststring32 Melder_fixedExponent (double value, integer exponent, integer precision) noexcept;
conststring8 Melder8_fixedExponent (double value, integer exponent, integer precision) noexcept;




conststring32 Melder_percent (double value, integer precision) noexcept;
conststring8 Melder8_percent (double value, integer precision) noexcept;




conststring8 Melder8_hexadecimal (integer value, integer precision) noexcept;
conststring32 Melder_hexadecimal (integer value, integer precision) noexcept;





conststring32 Melder_dcomplex (dcomplex value) noexcept;
conststring8 Melder8_dcomplex (dcomplex value) noexcept;





conststring32 Melder_scomplex (dcomplex value) noexcept;
conststring8 Melder8_scomplex (dcomplex value) noexcept;





conststring32 Melder_float (conststring32 number) noexcept;





conststring32 Melder_naturalLogarithm (double lnNumber) noexcept;
conststring8 Melder8_naturalLogarithm (double lnNumber) noexcept;

conststring32 Melder_pointer (const void *pointer) noexcept;
conststring8 Melder8_pointer (const void *pointer) noexcept;

conststring32 Melder_character (char32 kar) noexcept;
conststring8 Melder8_character (char32 kar) noexcept;

conststring32 Melder_colour (MelderColour colour) noexcept;
conststring8 Melder8_colour (MelderColour colour) noexcept;

conststring32 Melder_pad (int64 width, conststring32 string);
conststring32 Melder_pad (conststring32 string, int64 width);
conststring32 Melder_truncate (int64 width, conststring32 string);
conststring32 Melder_truncate (conststring32 string, int64 width);
conststring32 Melder_padOrTruncate (int64 width, conststring32 string);
conststring32 Melder_padOrTruncate (conststring32 string, int64 width);
# 73 "../melder/melder.h" 2
# 1 "../melder/melder_console.h" 1
# 22 "../melder/melder_console.h"
namespace MelderConsole {
 enum class Encoding {
  UTF8 = 0,
  UTF16 = 1,
  ANSI = 2
 };
 extern void write (conststring32 message, bool useStderr);
 extern void setEncoding (Encoding encoding);
}
# 74 "../melder/melder.h" 2
# 1 "../melder/melder_textencoding.h" 1
# 24 "../melder/melder_textencoding.h"
void Melder_textEncoding_prefs ();
void Melder_setInputEncoding (kMelder_textInputEncoding encoding);
kMelder_textInputEncoding Melder_getInputEncoding ();
void Melder_setOutputEncoding (kMelder_textOutputEncoding encoding);
kMelder_textOutputEncoding Melder_getOutputEncoding ();






constexpr uint32 kMelder_textOutputEncoding_ASCII = 0x4153'4349;
constexpr uint32 kMelder_textOutputEncoding_ISO_LATIN1 = 0x4C41'5401;
constexpr uint32 kMelder_textOutputEncoding_FLAC = 0x464C'4143;

bool Melder_isValidAscii (conststring32 string);
bool Melder_str8IsValidUtf8 (const char *string);
bool Melder_isEncodable (conststring32 string, int outputEncoding);
extern char32 Melder_decodeMacRoman [256];
extern char32 Melder_decodeWindowsLatin1 [256];






integer Melder_killReturns_inplace (mutablestring32 text);
integer Melder_killReturns_inplace (mutablestring8 text);

size_t str32len_utf8 (conststring32 string, bool nativizeNewlines);
size_t str32len_utf16 (conststring32 string, bool nativizeNewlines);

extern "C" conststring32 Melder_peek8to32 (conststring8 string);
void Melder_8to32_inplace (conststring8 source, mutablestring32 target, kMelder_textInputEncoding inputEncoding);

autostring32 Melder_8to32 (conststring8 string, kMelder_textInputEncoding inputEncoding);

autostring32 Melder_8to32 (conststring8 string);


conststring32 Melder_peek16to32 (conststring16 text);
autostring32 Melder_16to32 (conststring16 text);

extern "C" conststring8 Melder_peek32to8 (conststring32 string);
void Melder_32to8_inplace (conststring32 string, mutablestring8 utf8);
autostring8 Melder_32to8 (conststring32 string);
autostring16 Melder_32to16 (conststring32 string);


conststring16 Melder_peek32to16 (conststring32 text, bool nativizeNewlines);
extern "C" conststring16 Melder_peek32to16 (conststring32 string);
# 85 "../melder/melder_textencoding.h"
void Melder_32to8_fileSystem_inplace (conststring32 string, mutablestring8 utf8);
conststring8 Melder_peek32to8_fileSystem (conststring32 string);

void Melder_8bitFileRepresentationToStr32_inplace (conststring8 utf8, mutablestring32 string);
const void * Melder_peek32toCfstring (conststring32 string);
# 75 "../melder/melder.h" 2
# 1 "../melder/melder_atof.h" 1
# 25 "../melder/melder_atof.h"
bool Melder_isStringNumeric (conststring32 string) noexcept;
# 34 "../melder/melder_atof.h"
double Melder_a8tof (conststring8 string) noexcept;
double Melder_atof (conststring32 string) noexcept;




int64 Melder_atoi (conststring32 string) noexcept;
# 76 "../melder/melder.h" 2
# 1 "../melder/melder_files.h" 1
# 27 "../melder/melder_files.h"
struct FLAC__StreamDecoder;
struct FLAC__StreamEncoder;



struct structMelderFile {
 FILE *filePointer;
 char32 path [1023 +1];
 enum class Format { none = 0, binary = 1, text = 2 } format;
 bool openForReading, openForWriting, verbose, requiresCRLF;
 uint32 outputEncoding;
 int indent;
 struct FLAC__StreamEncoder *flacEncoder;
};
typedef struct structMelderFile *MelderFile;

struct structMelderDir {
 char32 path [1023 +1];
};
typedef struct structMelderDir *MelderDir;

conststring32 MelderFile_name (MelderFile file);
conststring32 MelderDir_name (MelderDir dir);
void Melder_pathToDir (conststring32 path, MelderDir dir);
void Melder_pathToFile (conststring32 path, MelderFile file);
void Melder_relativePathToFile (conststring32 path, MelderFile file);
conststring32 Melder_dirToPath (MelderDir dir);

conststring32 Melder_fileToPath (MelderFile file);
void MelderFile_copy (MelderFile file, MelderFile copy);
void MelderDir_copy (MelderDir dir, MelderDir copy);
bool MelderFile_equal (MelderFile file1, MelderFile file2);
bool MelderDir_equal (MelderDir dir1, MelderDir dir2);
void MelderFile_setToNull (MelderFile file);
bool MelderFile_isNull (MelderFile file);
void MelderDir_setToNull (MelderDir dir);
bool MelderDir_isNull (MelderDir dir);
void MelderDir_getFile (MelderDir parent, conststring32 fileName, MelderFile file);
void MelderDir_relativePathToFile (MelderDir dir, conststring32 path, MelderFile file);
void MelderFile_getParentDir (MelderFile file, MelderDir parent);
void MelderDir_getParentDir (MelderDir file, MelderDir parent);
bool MelderDir_isDesktop (MelderDir dir);
void MelderDir_getSubdir (MelderDir parent, conststring32 subdirName, MelderDir subdir);
void Melder_rememberShellDirectory ();
conststring32 Melder_getShellDirectory ();
void Melder_getHomeDir (MelderDir homeDir);
void Melder_getPrefDir (MelderDir prefDir);
void Melder_getTempDir (MelderDir tempDir);

bool MelderFile_exists (MelderFile file);
bool MelderFile_readable (MelderFile file);
integer MelderFile_length (MelderFile file);
void MelderFile_delete (MelderFile file);


FILE * Melder_fopen (MelderFile file, const char *type);
void Melder_fclose (MelderFile file, FILE *stream);
void Melder_files_cleanUp ();





char32 * Melder_peekExpandBackslashes (conststring32 message);
conststring32 MelderFile_messageName (MelderFile file);

void Melder_createDirectory (MelderDir parent, conststring32 subdirName, int mode);

void Melder_getDefaultDir (MelderDir dir);
void Melder_setDefaultDir (MelderDir dir);
void MelderFile_setDefaultDir (MelderFile file);

class autofile {
 FILE *ptr;
public:
 autofile (FILE *f) : ptr (f) {
 }
 autofile () : ptr (nullptr) {
 }
 ~autofile () {
  if (ptr)
   fclose (ptr);
 }
 operator FILE * () {
  return ptr;
 }
 void reset (FILE *f) {
  if (ptr)
   fclose (ptr);
  ptr = f;
 }
 void close (MelderFile file) {
  if (ptr) {
   FILE *tmp = ptr;
   ptr = nullptr;
   Melder_fclose (file, tmp);
  }
 }
};

class autoMelderSaveDefaultDir {
 structMelderDir _savedDir;
public:
 autoMelderSaveDefaultDir () {
  Melder_getDefaultDir (& this -> _savedDir);
 }
 ~autoMelderSaveDefaultDir () {
  Melder_setDefaultDir (& this -> _savedDir);
 }



 autoMelderSaveDefaultDir (const autoMelderSaveDefaultDir&) = delete;
 autoMelderSaveDefaultDir& operator= (const autoMelderSaveDefaultDir&) = delete;
};

class autoMelderSetDefaultDir {
 structMelderDir _savedDir;
public:
 autoMelderSetDefaultDir (MelderDir dir) {
  Melder_getDefaultDir (& this -> _savedDir);
  Melder_setDefaultDir (dir);
 }
 ~autoMelderSetDefaultDir () {
  Melder_setDefaultDir (& this -> _savedDir);
 }



 autoMelderSetDefaultDir (const autoMelderSetDefaultDir&) = delete;
 autoMelderSetDefaultDir& operator= (const autoMelderSetDefaultDir&) = delete;
};

class autoMelderFileSetDefaultDir {
 structMelderDir _savedDir;
public:
 autoMelderFileSetDefaultDir (MelderFile file) {
  Melder_getDefaultDir (& this -> _savedDir);
  MelderFile_setDefaultDir (file);
 }
 ~autoMelderFileSetDefaultDir () {
  Melder_setDefaultDir (& this -> _savedDir);
 }



 autoMelderFileSetDefaultDir (const autoMelderFileSetDefaultDir&) = delete;
 autoMelderFileSetDefaultDir& operator= (const autoMelderFileSetDefaultDir&) = delete;
};


autostring32 MelderFile_readText (MelderFile file, autostring8 *string8 = nullptr);
void Melder_fwrite32to8 (conststring32 string, FILE *f);
void MelderFile_writeText (MelderFile file, conststring32 text, kMelder_textOutputEncoding outputEncoding);
void MelderFile_appendText (MelderFile file, conststring32 text);
# 77 "../melder/melder.h" 2
# 1 "../melder/melder_strvec.h" 1
# 21 "../melder/melder_strvec.h"
template <typename T>
class _stringvector {
public:
 T** elements = nullptr;
 integer size = 0;
 _stringvector () { }
 _stringvector (T** givenElements, integer givenSize): elements (givenElements), size (givenSize) { }
 T* & operator[] (integer i) const {
  return this -> elements [i - 1];
 }
 _stringvector<T> part (integer firstPosition, integer lastPosition) {
  ((firstPosition >= 1 && firstPosition <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_strvec.h", 32, "firstPosition >= 1 && firstPosition <= our size"), abort ()));
  ((lastPosition >= 1 && lastPosition <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_strvec.h", 33, "lastPosition >= 1 && lastPosition <= our size"), abort ()));
  integer newSize = lastPosition - (firstPosition - 1);
  if (newSize <= 0)
   return _stringvector<T> ();
  return _stringvector (this -> elements + (firstPosition - 1), newSize);
 }
 T* *begin () const { return & this -> operator[] (1); }
 T* *end () const { return & this -> operator[] (this -> size + 1); }
};
using string32vector = _stringvector <char32>;
using string8vector = _stringvector <char>;

template <typename T>
class _autostringvectorview;

template <typename T>
class _conststringvector {
public:
 const T* const * elements = nullptr;
 integer size = 0;
 _conststringvector () { }
 _conststringvector (const T* const * givenElements, integer givenSize): elements (givenElements), size (givenSize) { }
 _conststringvector (_stringvector<T> other): elements (other.elements), size (other.size) { }
 _conststringvector (_autostringvectorview<T> other): elements ((T**) other._ptr), size (other.size) { }
 const T* const & operator[] (integer i) const {
  return this -> elements [i - 1];
 }
 _conststringvector<T> part (integer firstPosition, integer lastPosition) {
  ((firstPosition >= 1 && firstPosition <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_strvec.h", 61, "firstPosition >= 1 && firstPosition <= our size"), abort ()));
  ((lastPosition >= 1 && lastPosition <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_strvec.h", 62, "lastPosition >= 1 && lastPosition <= our size"), abort ()));
  integer newSize = lastPosition - (firstPosition - 1);
  if (newSize <= 0)
   return _conststringvector<T> ();
  return _conststringvector (this -> elements + (firstPosition - 1), newSize);
 }
 T* *begin () const { return & this -> operator[] (1); }
 T* *end () const { return & this -> operator[] (this -> size + 1); }
};
using conststring32vector = _conststringvector <char32>;
using conststring8vector = _conststringvector <char>;

template <typename T>
class _autostringvectorview {
public:
 _autostring <T> * _elements = nullptr;
 integer size = 0;
 _autostringvectorview<T> () = default;
 _autostringvectorview<T> (_autostring <T> * givenElements, integer givenSize): _elements (givenElements), size (givenSize) { }
 _autostring <T> & operator[] (integer i) const {
  return this -> _elements [i - 1];
 }
};

template <typename T>
void operator<<= (_autostringvectorview <T> const& target, _autostringvectorview <T> const& source) {
 ((target.size == source.size) ? (void) (0) : (Melder_assert_ ("../melder/melder_strvec.h", 88, "target.size == source.size"), abort ()));
 for (integer i = 1; i <= target.size; i ++)
  target [i] = Melder_dup (source [i]);
}

template <typename T>
class _autostringautovector {
 _autostring <T> * _elements;
public:
 integer size;
 _autostringautovector () {
  this -> _elements = nullptr;
  this -> size = 0;
 }
 _autostringautovector<T> (integer initialSize) {
  this -> _elements = MelderArray:: _alloc <_autostring <T>> (initialSize, MelderArray::kInitializationType :: ZERO);
  this -> size = initialSize;
 }
 _autostringautovector (const _autostringautovector &) = delete;
 _autostringautovector (_autostringautovector&& other) {
  this -> _elements = other. _elements;
  this -> size = other. size;
  other. _elements = nullptr;
  other. size = 0;
 }
 _autostringautovector& operator= (const _autostringautovector &) = delete;
 _autostringautovector& operator= (_autostringautovector&& other) noexcept {
  if (& other != this) {
   this -> reset ();
   this -> _elements = other. _elements;
   this -> size = other. size;
   other. _elements = nullptr;
   other. size = 0;
  }
  return *this;
 }
 ~ _autostringautovector<T> () {
  this -> reset ();
 }
 explicit operator bool () const noexcept { return !! this -> _elements; }
 _autostring <T> & operator[] (integer i) {
  return this -> _elements [i - 1];
 }
 _stringvector<T> get () const {
  return _stringvector<T> { (T**) this -> _elements, this -> size };
 }
 _autostringvectorview<T> all () const {
  return _autostringvectorview<T> (this -> _elements, this -> size);
 }
 T** peek2 () const {
  return (T**) this -> _elements - 1;
 }
 void reset () {
  if (this -> _elements) {
   for (integer i = 1; i <= this -> size; i ++)
    this -> _elements [i - 1]. reset ();
   MelderArray:: _free (this -> _elements, this -> size);
   this -> _elements = nullptr;
   this -> size = 0;
  }
 }
 _autostringvectorview<T> part (integer firstPosition, integer lastPosition) {
  ((firstPosition >= 1 && firstPosition <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_strvec.h", 150, "firstPosition >= 1 && firstPosition <= our size"), abort ()));
  ((lastPosition >= 1 && lastPosition <= this -> size) ? (void) (0) : (Melder_assert_ ("../melder/melder_strvec.h", 151, "lastPosition >= 1 && lastPosition <= our size"), abort ()));
  integer newSize = lastPosition - (firstPosition - 1);
  if (newSize <= 0)
   return _autostringvectorview<T> ();
  return _autostringvectorview<T> (this -> _elements + (firstPosition - 1), newSize);
 }
};

using autostring32vector = _autostringautovector <char32>;
using autostring8vector = _autostringautovector <char>;

using STRVEC = _stringvector <char32>;
using constSTRVEC = _conststringvector <char32>;
using autoSTRVEC = _autostringautovector <char32>;

inline static autoSTRVEC newSTRVECcopy (constSTRVEC strvec) {
 autoSTRVEC result (strvec.size);
 for (integer i = 1; i <= result.size; i ++)
  result [i] = Melder_dup (strvec [i]);
 return result;
}

inline void operator<<= (_autostringvectorview <char32> const& target, _autostringvectorview <char32> const& source) {
 ((target.size == source.size) ? (void) (0) : (Melder_assert_ ("../melder/melder_strvec.h", 174, "target.size == source.size"), abort ()));
 for (integer i = 1; i <= target.size; i ++)
  target [i] = Melder_dup (source [i].get());
}
# 78 "../melder/melder.h" 2
# 1 "../melder/melder_sort.h" 1
# 23 "../melder/melder_sort.h"
double NUMquantile (integer n, double a [], double factor);
double NUMquantile (const constVECVU& a, double factor) noexcept;
# 79 "../melder/melder.h" 2

# 1 "../melder/MelderArg.h" 1
# 21 "../melder/MelderArg.h"
typedef class structThing *Thing;
conststring32 Thing_messageName (Thing me);

struct MelderArg {
 const conststring32 _arg;



 MelderArg (conststring32 arg) : _arg (arg) { }
 MelderArg (const double arg) : _arg (Melder_double (arg)) { }
 MelderArg (const long long arg) : _arg (Melder_integer (arg)) { }
 MelderArg (const unsigned long long arg) : _arg (Melder_integer ((int64) arg)) { }
 MelderArg (const long arg) : _arg (Melder_integer (arg)) { }
 MelderArg (const unsigned long arg) : _arg (Melder_integer ((int64) arg)) { }
 MelderArg (const int arg) : _arg (Melder_integer (arg)) { }
 MelderArg (const unsigned int arg) : _arg (Melder_integer (arg)) { }
 MelderArg (const short arg) : _arg (Melder_integer (arg)) { }
 MelderArg (const unsigned short arg) : _arg (Melder_integer (arg)) { }
 MelderArg (const dcomplex arg) : _arg (Melder_dcomplex (arg)) { }
 MelderArg (const char32 arg) : _arg (Melder_character (arg)) { }
 MelderArg (const MelderColour arg) : _arg (Melder_colour (arg)) { }



 MelderArg (constVECVU const& arg) : _arg (Melder_VEC (arg)) { }
 MelderArg (constMATVU const& arg) : _arg (Melder_MAT (arg)) { }
 MelderArg (Thing arg) : _arg (Thing_messageName (arg)) { }
 MelderArg (MelderFile arg) : _arg (MelderFile_messageName (arg)) { }
# 57 "../melder/MelderArg.h"
};

inline static integer MelderArg__length (const MelderArg& arg) {
 return arg._arg ? str32len (arg._arg) : 0;
}
template <typename... Args>
integer MelderArg__length (const MelderArg& first, Args... rest) {
 integer length = MelderArg__length (first);
 length += MelderArg__length (rest...);
 return length;
}
# 81 "../melder/melder.h" 2
# 1 "../melder/melder_debug.h" 1
# 29 "../melder/melder_debug.h"
extern int Melder_debug;


void Melder_tracingToFile (MelderFile file);
void Melder_setTracing (bool tracing);
extern bool Melder_isTracing;

namespace MelderTrace {
 extern structMelderFile _file;
 FILE * _open (conststring8 sourceCodeFileName, int lineNumber, conststring8 functionName);
 void _close (FILE *f);
 conststring8 _peek32to8 (conststring32 string);
 conststring16 _peek32to16 (conststring32 string);
}

inline static void _recursiveTemplate_Melder_trace (FILE *f, const MelderArg& arg) {
 if (arg._arg)
  fprintf (f, "%s", MelderTrace::_peek32to8 (arg. _arg));
}
template <typename... Args>
void _recursiveTemplate_Melder_trace (FILE *f, const MelderArg& first, Args... rest) {
 _recursiveTemplate_Melder_trace (f, first);
 _recursiveTemplate_Melder_trace (f, rest...);
}

template <typename... Args>
void Melder_trace (conststring8 sourceCodeFileName, int lineNumber, conststring8 functionName, const MelderArg& first, Args... rest) {
 if (! Melder_isTracing || MelderFile_isNull (& MelderTrace::_file))
  return;
 FILE *f = MelderTrace::_open (sourceCodeFileName, lineNumber, functionName);
 _recursiveTemplate_Melder_trace (f, first, rest...);
 MelderTrace::_close (f);
}
# 82 "../melder/melder.h" 2
# 1 "../melder/MelderFile.h" 1
# 22 "../melder/MelderFile.h"
MelderFile MelderFile_open (MelderFile file);
char * MelderFile_readLine (MelderFile file);

MelderFile MelderFile_create (MelderFile file);
void MelderFile_write (MelderFile file, conststring32 string);
void MelderFile_writeCharacter (MelderFile file, char32 kar);

inline static void _recursiveTemplate_MelderFile_write (MelderFile file, const MelderArg& arg) {
 MelderFile_write (file, arg. _arg);
}
template <typename... Args>
void _recursiveTemplate_MelderFile_write (MelderFile file, const MelderArg& first, Args... rest) {
 _recursiveTemplate_MelderFile_write (file, first);
 _recursiveTemplate_MelderFile_write (file, rest...);
}

template <typename... Args>
void MelderFile_write (MelderFile file, const MelderArg& first, Args... rest) {
 _recursiveTemplate_MelderFile_write (file, first, rest...);
}

void MelderFile_rewind (MelderFile file);
void MelderFile_seek (MelderFile file, integer position, int direction);
integer MelderFile_tell (MelderFile file);
void MelderFile_close (MelderFile file);
void MelderFile_close_nothrow (MelderFile file);

class autoMelderFile {
 MelderFile _file;
public:
 autoMelderFile (MelderFile file) : _file (file) {
 }
 ~autoMelderFile () {
  if (_file)
   MelderFile_close_nothrow (_file);
 }
 void close () {
  if (_file && _file -> filePointer) {
   MelderFile tmp = _file;
   _file = nullptr;
   MelderFile_close (tmp);
  }
 }
 MelderFile transfer () {
  MelderFile tmp = _file;
  _file = nullptr;
  return tmp;
 }
};
# 83 "../melder/melder.h" 2
# 1 "../melder/MelderString.h" 1
# 30 "../melder/MelderString.h"
typedef struct {
 int64 length = 0;
 int64 bufferSize = 0;
 char16 *string = nullptr;
} MelderString16;
typedef struct {
 int64 length = 0;
 int64 bufferSize = 0;
 char32 *string = nullptr;
} MelderString;

void MelderString16_free (MelderString16 *me);
void MelderString_free (MelderString *me);
void MelderString16_empty (MelderString16 *me);
void MelderString_empty (MelderString *me);
void MelderString_expand (MelderString *me, int64 sizeNeeded);
void MelderString_ncopy (MelderString *me, conststring32 source, int64 n);

inline static void _recursiveTemplate_MelderString_append (MelderString *me, const MelderArg& arg) {
 if (arg._arg) {
  const char32 *newEndOfStringLocation = stp32cpy (& me -> string [me -> length], arg._arg);
  me -> length = newEndOfStringLocation - & me -> string [0];
 } else {





 }
}
template <typename... Args>
void _recursiveTemplate_MelderString_append (MelderString *me, const MelderArg& first, Args... rest) {
 _recursiveTemplate_MelderString_append (me, first);
 _recursiveTemplate_MelderString_append (me, rest...);
}

template <typename... Args>
void MelderString_append (MelderString *me, const MelderArg& first, Args... rest) {
 integer extraLength = MelderArg__length (first, rest...);
 integer sizeNeeded = me -> length + extraLength + 1;
 if (sizeNeeded > me -> bufferSize)
  MelderString_expand (me, sizeNeeded);
 _recursiveTemplate_MelderString_append (me, first, rest...);
}

template <typename... Args>
void MelderString_copy (MelderString *me, const MelderArg& first, Args... rest) {
 constexpr int64 FREE_THRESHOLD_BYTES = 10'000;
 if (me -> bufferSize * (int64) sizeof (char32) >= FREE_THRESHOLD_BYTES)
  MelderString_free (me);
 integer length = MelderArg__length (first, rest...);
 integer sizeNeeded = length + 1;
 if (sizeNeeded > me -> bufferSize)
  MelderString_expand (me, sizeNeeded);
 me -> length = 0;
 me -> string [0] = U'\0';
 _recursiveTemplate_MelderString_append (me, first, rest...);
}

void MelderString16_appendCharacter (MelderString16 *me, char32 character);
void MelderString_appendCharacter (MelderString *me, char32 character);
void MelderString_get (MelderString *me, char32 *destination);
int64 MelderString_allocationCount ();
int64 MelderString_deallocationCount ();
int64 MelderString_allocationSize ();
int64 MelderString_deallocationSize ();

struct autoMelderString : MelderString {
 autoMelderString () {

 }
 ~autoMelderString () {
  MelderString_free (this);
 }
};
# 84 "../melder/melder.h" 2
# 1 "../melder/melder_cat.h" 1
# 21 "../melder/melder_cat.h"
namespace MelderCat {
 constexpr int _k_NUMBER_OF_BUFFERS = 33;
 extern MelderString _buffers [_k_NUMBER_OF_BUFFERS];
 extern int _bufferNumber;
}

template <typename... Args>
conststring32 Melder_cat (Args... args) {
 if (++ MelderCat::_bufferNumber == MelderCat::_k_NUMBER_OF_BUFFERS)
  MelderCat::_bufferNumber = 0;
 MelderString_copy (& MelderCat::_buffers [MelderCat::_bufferNumber], args...);
 return MelderCat::_buffers [MelderCat::_bufferNumber].string;
}
# 85 "../melder/melder.h" 2
# 1 "../melder/melder_sprint.h" 1
# 21 "../melder/melder_sprint.h"
inline static void _recursiveTemplate_Melder_sprint (char32 **inout_pointer, const MelderArg& arg) {
 if (arg._arg) {
  char32 *newEndOfStringLocation = stp32cpy (*inout_pointer, arg._arg);
  *inout_pointer = newEndOfStringLocation;
 }
}
template <typename... Args>
void _recursiveTemplate_Melder_sprint (char32 **inout_pointer, const MelderArg& first, Args... rest) {
 _recursiveTemplate_Melder_sprint (inout_pointer, first);
 _recursiveTemplate_Melder_sprint (inout_pointer, rest...);
}

template <typename... Args>
void Melder_sprint (mutablestring32 buffer, int64 bufferSize, const MelderArg& first, Args... rest) {
 integer length = MelderArg__length (first, rest...);
 if (length >= bufferSize) {
  for (int64 i = 0; i < bufferSize; i ++)
   buffer [i] = U'?';
  if (bufferSize > 0)
   buffer [bufferSize - 1] = U'\0';
  return;
 }
 char32 *p = & buffer [0];
 _recursiveTemplate_Melder_sprint (& p, first, rest...);
}
# 86 "../melder/melder.h" 2
# 1 "../melder/melder_search.h" 1
# 23 "../melder/melder_search.h"
bool Melder_numberMatchesCriterion (double value, kMelder_number which, double criterion);
bool Melder_stringMatchesCriterion (conststring32 value, kMelder_string which, conststring32 criterion, bool caseSensitive);
# 87 "../melder/melder.h" 2
# 1 "../melder/melder_casual.h" 1
# 28 "../melder/melder_casual.h"
inline static void _recursiveTemplate_Melder_casual (const MelderArg& arg) {
 MelderConsole::write (arg._arg, true);
}
template <typename... Args>
void _recursiveTemplate_Melder_casual (const MelderArg& first, Args... rest) {
 _recursiveTemplate_Melder_casual (first);
 _recursiveTemplate_Melder_casual (rest...);
}

template <typename... Args>
void Melder_casual (const MelderArg& first, Args... rest) {
 _recursiveTemplate_Melder_casual (first, rest...);
 MelderConsole::write (U"\n", true);
}

void MelderCasual_memoryUse (integer message = 0);
# 88 "../melder/melder.h" 2
# 1 "../melder/melder_info.h" 1
# 25 "../melder/melder_info.h"
namespace MelderInfo {
 using Proc = void (*) (conststring32 message);
 void _defaultProc (conststring32 message);
 extern Proc _p_currentProc;
 extern MelderString _foregroundBuffer, *_p_currentBuffer;
}

void MelderInfo_open ();
void MelderInfo_close ();
void MelderInfo_drain ();

inline static void _recursiveTemplate_MelderInfo_write (const MelderArg& arg) {
 MelderConsole::write (arg._arg, false);
}
template <typename... Args>
void _recursiveTemplate_MelderInfo_write (const MelderArg& first, Args... rest) {
 _recursiveTemplate_MelderInfo_write (first);
 _recursiveTemplate_MelderInfo_write (rest...);
}

template <typename... Args>
void MelderInfo_write (const MelderArg& first, Args... rest) {
 MelderString_append (MelderInfo::_p_currentBuffer, first, rest...);
 if (MelderInfo::_p_currentProc == & MelderInfo::_defaultProc && MelderInfo::_p_currentBuffer == & MelderInfo::_foregroundBuffer)
  _recursiveTemplate_MelderInfo_write (first, rest...);
}

template <typename... Args>
void MelderInfo_writeLine (const MelderArg& first, Args... rest) {
 MelderString_append (MelderInfo::_p_currentBuffer, first, rest...);
 MelderString_appendCharacter (MelderInfo::_p_currentBuffer, U'\n');
 if (MelderInfo::_p_currentProc == & MelderInfo::_defaultProc && MelderInfo::_p_currentBuffer == & MelderInfo::_foregroundBuffer) {
  _recursiveTemplate_MelderInfo_write (first, rest...);
  MelderConsole::write (U"\n", false);
 }
}

template <typename... Args>
void Melder_information (const MelderArg& first, Args... rest) {
 MelderString_copy (MelderInfo::_p_currentBuffer, first, rest...);
 if (MelderInfo::_p_currentProc == & MelderInfo::_defaultProc && MelderInfo::_p_currentBuffer == & MelderInfo::_foregroundBuffer)
  _recursiveTemplate_MelderInfo_write (first, rest...);
 MelderInfo_close ();
}

void Melder_informationReal (double value, conststring32 units);

void Melder_divertInfo (MelderString *p_buffer);

class autoMelderDivertInfo {
 public:
  autoMelderDivertInfo (MelderString *p_buffer) { Melder_divertInfo (p_buffer); }
  ~autoMelderDivertInfo () { Melder_divertInfo (nullptr); }
};

void Melder_clearInfo ();
conststring32 Melder_getInfo ();

void Melder_setInformationProc (MelderInfo::Proc proc);
# 89 "../melder/melder.h" 2
# 1 "../melder/melder_error.h" 1
# 21 "../melder/melder_error.h"
class MelderError {
public:
 static void _append (conststring32 message);
};

void Melder_appendError_noLine (const MelderArg& arg1);
# 46 "../melder/melder_error.h"
inline static void _recursiveTemplate_Melder_appendError (const MelderArg& arg) {
 MelderError::_append (arg._arg);
}
template <typename... Args>
void _recursiveTemplate_Melder_appendError (const MelderArg& first, Args... rest) {
 _recursiveTemplate_Melder_appendError (first);
 _recursiveTemplate_Melder_appendError (rest...);
}

template <typename... Args>
void Melder_appendError (const MelderArg& first, Args... rest) {
 _recursiveTemplate_Melder_appendError (first, rest...);
 MelderError::_append (U"\n");
}



void Melder_flushError ();

template <typename... Args>
void Melder_flushError (const MelderArg& first, Args... rest) {
 Melder_appendError (first, rest...);
 Melder_flushError ();
}



bool Melder_hasError ();
bool Melder_hasError (conststring32 partialError);


void Melder_clearError ();


conststring32 Melder_getError ();


void Melder_setErrorProc (void (*p_errorProc) (conststring32));
# 90 "../melder/melder.h" 2
# 1 "../melder/melder_require.h" 1
# 23 "../melder/melder_require.h"
inline void checkElementNumber (integer elementNumber, integer maximumElementNumber) {
 do { if (! (elementNumber >= 1)) do { Melder_appendError (U"The element number should be at least 1, not ", elementNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                        ;
 do { if (! (elementNumber <= maximumElementNumber)) do { Melder_appendError (U"The element number should be at most ", maximumElementNumber, U", not", elementNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                                                ;
}
template <typename T>
void checkElementNumber (integer elementNumber, const constvector<T>& vec) {
 do { if (! (elementNumber >= 1)) do { Melder_appendError (U"The element number should be at least 1, not ", elementNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                        ;
 do { if (! (elementNumber <= vec.size)) do { Melder_appendError (U"The element number should be at most the number of elements (", vec.size, U"), not", elementNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                                                             ;
}
template <typename T>
void checkElementNumber (integer elementNumber, const vector<T>& x) {
 checkElementNumber (elementNumber, constvector<T> (x));
}

template <typename T>
void checkElementRange (integer firstElement, integer lastElement, const constvector<T>& x, integer minimumNewNumberOfElements) {
 do { if (! (firstElement >= 1)) do { Melder_appendError (U"The first element should be at least 1, not ", firstElement, U"."); throw MelderError (); } while (false); } while (false)
                                                                      ;
 integer minimumLastRow = firstElement + (minimumNewNumberOfElements - 1);
 do { if (! (lastElement >= minimumLastRow)) do { Melder_appendError (U"The last element should be at least ", minimumLastRow, U", not ", lastElement, U", because the new vector should contain at least ", minimumNewNumberOfElements, U" elements (the first element is ", firstElement, U")."); throw MelderError (); } while (false); } while (false)



  ;
 do { if (! (lastElement <= x.size)) do { Melder_appendError (U"The last element should be at most the number of elements (", x.size, U"), not", lastElement, U"."); throw MelderError (); } while (false); } while (false)
                                                                                                       ;
}
template <typename T>
void checkElementRange (integer firstElement, integer lastElement, const vector<T>& x, integer minimumNewNumberOfElements) {
 checkElementRange (firstElement, lastElement, constvector<T> (x), minimumNewNumberOfElements);
}

inline void checkRowNumber (integer rowNumber, integer maximumRowNumber) {
 do { if (! (rowNumber >= 1)) do { Melder_appendError (U"The row number should be at least 1, not ", rowNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                ;
 do { if (! (rowNumber <= maximumRowNumber)) do { Melder_appendError (U"The row number should be at most ", maximumRowNumber, U", not", rowNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                                    ;
}
template <typename T>
void checkRowNumber (integer rowNumber, const constmatrix<T>& mat) {
 do { if (! (rowNumber >= 1)) do { Melder_appendError (U"The row number should be at least 1, not ", rowNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                ;
 do { if (! (rowNumber <= mat.nrow)) do { Melder_appendError (U"The row number should be at most the number of rows (", mat.nrow, U"), not", rowNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                                                 ;
}
template <typename T>
void checkRowNumber (integer rowNumber, const matrix<T>& x) {
 checkRowNumber (rowNumber, constmatrix<T> (x));
}

template <typename T>
void checkRowRange (integer firstRow, integer lastRow, const constmatrix<T>& x, integer minimumNewNumberOfRows) {
 do { if (! (firstRow >= 1)) do { Melder_appendError (U"The first row should be at least 1, not ", firstRow, U"."); throw MelderError (); } while (false); } while (false)
                                                              ;
 integer minimumLastRow = firstRow + (minimumNewNumberOfRows - 1);
 do { if (! (lastRow >= minimumLastRow)) do { Melder_appendError (U"The last row should be at least ", minimumLastRow, U", not ", lastRow, U", because the new matrix should contain at least ", minimumNewNumberOfRows, U" rows (the first row is ", firstRow, U")."); throw MelderError (); } while (false); } while (false)



  ;
 do { if (! (lastRow <= x.nrow)) do { Melder_appendError (U"The last row should be at most the number of rows (", x.nrow, U"), not", lastRow, U"."); throw MelderError (); } while (false); } while (false)
                                                                                           ;
}
template <typename T>
void checkRowRange (integer firstRow, integer lastRow, const matrix<T>& x, integer minimumNewNumberOfRows) {
 checkRowRange (firstRow, lastRow, constmatrix<T> (x), minimumNewNumberOfRows);
}

inline void checkColumnNumber (integer columnNumber, integer maximumColumnNumber) {
 do { if (! (columnNumber >= 1)) do { Melder_appendError (U"The column number should be at least 1, not ", columnNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                      ;
 do { if (! (columnNumber <= maximumColumnNumber)) do { Melder_appendError (U"The column number should be at most ", maximumColumnNumber, U", not", columnNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                                             ;
}
template <typename T>
void checkColumnNumber (integer columnNumber, const constmatrix<T>& mat) {
 do { if (! (columnNumber >= 1)) do { Melder_appendError (U"The column number should be at least 1, not ", columnNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                      ;
 do { if (! (columnNumber <= mat.ncol)) do { Melder_appendError (U"The column number should be at most the number of columns (", mat.ncol, U"), not", columnNumber, U"."); throw MelderError (); } while (false); } while (false)
                                                                                                          ;
}
template <typename T>
void checkColumnNumber (integer columnNumber, const matrix<T>& x) {
 checkColumnNumber (columnNumber, constmatrix<T> (x));
}

template <typename T>
void checkColumnRange (integer firstColumn, integer lastColumn, const constmatrix<T>& x, integer minimumNewNumberOfColumns) {
 do { if (! (firstColumn >= 1)) do { Melder_appendError (U"The first column should be at least 1, not ", firstColumn, U"."); throw MelderError (); } while (false); } while (false)
                                                                    ;
 integer minimumLastColumn = firstColumn + (minimumNewNumberOfColumns - 1);
 do { if (! (lastColumn >= minimumLastColumn)) do { Melder_appendError (U"The last column should be at least ", minimumLastColumn, U", not ", lastColumn, U", because the new matrix should contain at least ", minimumNewNumberOfColumns, U" columns (the first column is ", firstColumn, U")."); throw MelderError (); } while (false); } while (false)



  ;
 do { if (! (lastColumn <= x.ncol)) do { Melder_appendError (U"The last column should be at most the number of columns (", x.ncol, U"), not", lastColumn, U"."); throw MelderError (); } while (false); } while (false)
                                                                                                    ;
}
template <typename T>
void checkColumnRange (integer firstColumn, integer lastColumn, const matrix<T>& x, integer minimumNewNumberOfColumns) {
 checkColumnRange (firstColumn, lastColumn, constmatrix<T> (x), minimumNewNumberOfColumns);
}

inline void fixUnspecifiedRange (integer *inout_from, integer *inout_to, integer maximumAllowedValue) {
 if (*inout_from == 0) *inout_from = 1;
 if (*inout_to == 0) *inout_to = maximumAllowedValue;
}

template <typename T>
void fixUnspecifiedElementRange (integer *inout_firstElement, integer *inout_lastElement, const constvector<T> x) {
 fixUnspecifiedRange (inout_firstElement, inout_lastElement, x.size);
}
template <typename T>
void fixUnspecifiedElementRange (integer *inout_firstElement, integer *inout_lastElement, const vector<T> x) {
 fixUnspecifiedElementRange (inout_firstElement, inout_lastElement, constvector<T> (x));
}
template <typename T>
void fixAndCheckElementRange (integer *inout_firstElement, integer *inout_lastElement, const constvector<T> x, integer minimumNewNumberOfElements) {
 fixUnspecifiedElementRange (inout_firstElement, inout_lastElement, x);
 checkElementRange (*inout_firstElement, *inout_lastElement, x, minimumNewNumberOfElements);
}
template <typename T>
void fixAndCheckElementRange (integer *inout_firstElement, integer *inout_lastElement, const vector<T> x, integer minimumNewNumberOfElements) {
 fixAndCheckElementRange (inout_firstElement, inout_lastElement, constvector<T> (x), minimumNewNumberOfElements);
}
template <typename T>
void fixUnspecifiedRowRange (integer *inout_firstRow, integer *inout_lastRow, const constmatrix<T> x) {
 fixUnspecifiedRange (inout_firstRow, inout_lastRow, x.nrow);
}
template <typename T>
void fixUnspecifiedRowRange (integer *inout_firstRow, integer *inout_lastRow, const matrix<T> x) {
 fixUnspecifiedRange (inout_firstRow, inout_lastRow, x.nrow);
}
template <typename T>
void fixAndCheckRowRange (integer *inout_firstRow, integer *inout_lastRow, const constmatrix<T> x, integer minimumNewNumberOfRows) {
 fixUnspecifiedRowRange (inout_firstRow, inout_lastRow, x);
 checkRowRange (*inout_firstRow, *inout_lastRow, x, minimumNewNumberOfRows);
}
template <typename T>
void fixAndCheckRowRange (integer *inout_firstRow, integer *inout_lastRow, const matrix<T> x, integer minimumNewNumberOfRows) {
 fixAndCheckRowRange (inout_firstRow, inout_lastRow, constmatrix<T> (x), minimumNewNumberOfRows);
}
template <typename T>
void fixUnspecifiedColumnRange (integer *inout_firstColumn, integer *inout_lastColumn, const constmatrix<T> x) {
 fixUnspecifiedRange (inout_firstColumn, inout_lastColumn, x.ncol);
}
template <typename T>
void fixUnspecifiedColumnRange (integer *inout_firstColumn, integer *inout_lastColumn, const matrix<T> x) {
 fixUnspecifiedRange (inout_firstColumn, inout_lastColumn, x.ncol);
}
template <typename T>
void fixAndCheckColumnRange (integer *inout_firstColumn, integer *inout_lastColumn, const constmatrix<T> x, integer minimumNewNumberOfColumns) {
 fixUnspecifiedColumnRange (inout_firstColumn, inout_lastColumn, x);
 checkColumnRange (*inout_firstColumn, *inout_lastColumn, x, minimumNewNumberOfColumns);
}
template <typename T>
void fixAndCheckColumnRange (integer *inout_firstColumn, integer *inout_lastColumn, const matrix<T> x, integer minimumNewNumberOfColumns) {
 fixAndCheckColumnRange (inout_firstColumn, inout_lastColumn, constmatrix<T> (x), minimumNewNumberOfColumns);
}
# 91 "../melder/melder.h" 2
# 1 "../melder/melder_warning.h" 1
# 30 "../melder/melder_warning.h"
namespace MelderWarning {
 extern int _depth;
 extern MelderString _buffer;
 using Proc = void (*) (conststring32 message);
 void _defaultProc (conststring32 message);
 extern Proc _p_currentProc;
}

template <typename... Args>
void Melder_warning (const MelderArg& first, Args... rest);

template <typename... Args>
void Melder_warning (const MelderArg& first, Args... rest) {
 if (MelderWarning::_depth < 0)
  return;
 MelderString_copy (& MelderWarning::_buffer, first, rest...);
 (*MelderWarning::_p_currentProc) (MelderWarning::_buffer.string);
}

void Melder_warningOff ();
void Melder_warningOn ();

class autoMelderWarningOff {
public:
 autoMelderWarningOff () { Melder_warningOff (); }
 ~autoMelderWarningOff () { Melder_warningOn (); }
};

void Melder_setWarningProc (MelderWarning::Proc p_proc);
# 92 "../melder/melder.h" 2
# 1 "../melder/melder_fatal.h" 1
# 32 "../melder/melder_fatal.h"
void Melder_fatal (const MelderArg&,
 const MelderArg& = U"", const MelderArg& = U"", const MelderArg& = U"",
 const MelderArg& = U"", const MelderArg& = U"", const MelderArg& = U"",
 const MelderArg& = U"", const MelderArg& = U"", const MelderArg& = U""
);

void Melder_setFatalProc (void (*p_fatalProc) (conststring32));
# 93 "../melder/melder.h" 2
# 1 "../melder/melder_progress.h" 1
# 100 "../melder/melder_progress.h"
namespace MelderProgress {
 extern int _depth;
 using ProgressProc = void (*) (double progress, conststring32 message);
 using MonitorProc = void * (*) (double progress, conststring32 message);
 extern ProgressProc _p_progressProc;
 extern MonitorProc _p_monitorProc;
 void _doProgress (double progress, conststring32 message);
 void * _doMonitor (double progress, conststring32 message);
 extern MelderString _buffer;
}

void Melder_progressOff ();
void Melder_progressOn ();

inline static void Melder_progress (double progress) {
 MelderProgress::_doProgress (progress, U"");
}
template <typename... Args>
void Melder_progress (double progress, const MelderArg& first, Args... rest) {
 MelderString_copy (& MelderProgress::_buffer, first, rest...);
 MelderProgress::_doProgress (progress, MelderProgress::_buffer.string);
}
class autoMelderProgress {
public:
 autoMelderProgress (conststring32 message) {
  Melder_progress (0.0, message);
 }
 ~autoMelderProgress () {
  Melder_progress (1.0);
 }
};

inline static void * Melder_monitor (double progress) {
 return MelderProgress::_doMonitor (progress, U"");
}
template <typename... Args>
void * Melder_monitor (double progress, const MelderArg& first, Args... rest) {
 MelderString_copy (& MelderProgress::_buffer, first, rest...);
 return MelderProgress::_doMonitor (progress, MelderProgress::_buffer.string);
}

typedef class structGraphics *Graphics;
class autoMelderMonitor {
 Graphics _graphics;
public:
 autoMelderMonitor (conststring32 message) {
  _graphics = (Graphics) Melder_monitor (0.0, message);
 }
 ~autoMelderMonitor () {
  Melder_monitor (1.0);
 }
 Graphics graphics () { return _graphics; }
};

struct autoMelderProgressOff {
 autoMelderProgressOff () {
  Melder_progressOff ();
 }
 ~autoMelderProgressOff () {
  Melder_progressOn ();
 }
};

void Melder_setProgressProc (MelderProgress::ProgressProc p_proc);
void Melder_setMonitorProc (MelderProgress::MonitorProc p_proc);
# 94 "../melder/melder.h" 2
# 1 "../melder/melder_play.h" 1
# 21 "../melder/melder_play.h"
int Melder_record (double duration);
int Melder_recordFromFile (MelderFile file);
void Melder_play ();
void Melder_playReverse ();
int Melder_publishPlayed ();
void Melder_beep ();

void Melder_setRecordProc (int (*record) (double));
void Melder_setRecordFromFileProc (int (*recordFromFile) (MelderFile));
void Melder_setPlayProc (void (*play) ());
void Melder_setPlayReverseProc (void (*playReverse) ());
void Melder_setPublishPlayedProc (int (*publishPlayed) ());
# 95 "../melder/melder.h" 2
# 1 "../melder/melder_help.h" 1
# 21 "../melder/melder_help.h"
void Melder_help (conststring32 query);
void Melder_search ();
void Melder_setHelpProc (void (*help) (conststring32 query));
void Melder_setSearchProc (void (*search) ());
# 96 "../melder/melder.h" 2
# 1 "../melder/melder_ftoi.h" 1
# 21 "../melder/melder_ftoi.h"
#pragma mark - REAL TO INTEGER CONVERSION

inline static double Melder_roundDown (double x) {
 return floor (x);
}

inline static integer Melder_iroundDown (double x) {
 double xround = Melder_roundDown (x);
 do { if (! (xround >= (double) ( sizeof (integer) == 4 ? 
# 29 "../melder/melder_ftoi.h" 3 4
(-2147483647-1) 
# 29 "../melder/melder_ftoi.h"
: 
# 29 "../melder/melder_ftoi.h" 3 4
(-9223372036854775807L -1) 
# 29 "../melder/melder_ftoi.h"
) && xround <= (double) ( sizeof (integer) == 4 ? 
# 29 "../melder/melder_ftoi.h" 3 4
(2147483647) 
# 29 "../melder/melder_ftoi.h"
: 
# 29 "../melder/melder_ftoi.h" 3 4
(9223372036854775807L) 
# 29 "../melder/melder_ftoi.h"
))) do { Melder_appendError (U"When rounding down the real value ", x, U", the result cannot be represented in an integer."); throw MelderError (); } while (false); } while (false)
                                                                                                 ;
 return (integer) xround;
}


inline static double Melder_roundUp (double x) {
 return ceil (x);
}

inline static integer Melder_iroundUp (double x) {
 double xround = Melder_roundUp (x);
 do { if (! (xround >= (double) ( sizeof (integer) == 4 ? 
# 41 "../melder/melder_ftoi.h" 3 4
(-2147483647-1) 
# 41 "../melder/melder_ftoi.h"
: 
# 41 "../melder/melder_ftoi.h" 3 4
(-9223372036854775807L -1) 
# 41 "../melder/melder_ftoi.h"
) && xround <= (double) ( sizeof (integer) == 4 ? 
# 41 "../melder/melder_ftoi.h" 3 4
(2147483647) 
# 41 "../melder/melder_ftoi.h"
: 
# 41 "../melder/melder_ftoi.h" 3 4
(9223372036854775807L) 
# 41 "../melder/melder_ftoi.h"
))) do { Melder_appendError (U"When rounding up the real value ", x, U", the result cannot be represented in an integer."); throw MelderError (); } while (false); } while (false)
                                                                                               ;
 return (integer) xround;
}


inline static double Melder_roundTowardsZero (double x) {
 return x >= 0.0 ? Melder_roundDown (x) : Melder_roundUp (x);
}

inline static integer Melder_iroundTowardsZero (double x) {
 do { if (! (x >= (double) ( sizeof (integer) == 4 ? 
# 52 "../melder/melder_ftoi.h" 3 4
(-2147483647-1) 
# 52 "../melder/melder_ftoi.h"
: 
# 52 "../melder/melder_ftoi.h" 3 4
(-9223372036854775807L -1) 
# 52 "../melder/melder_ftoi.h"
) && x <= (double) ( sizeof (integer) == 4 ? 
# 52 "../melder/melder_ftoi.h" 3 4
(2147483647) 
# 52 "../melder/melder_ftoi.h"
: 
# 52 "../melder/melder_ftoi.h" 3 4
(9223372036854775807L) 
# 52 "../melder/melder_ftoi.h"
))) do { Melder_appendError (U"When rounding the real value ", x, U" towards zero, the result cannot be represented in an integer."); throw MelderError (); } while (false); } while (false)
                                                                                                         ;
 return (integer) x;
}

inline static double Melder_roundAwayFromZero (double x) {
 return x >= 0.0 ? Melder_roundUp (x) : Melder_roundDown (x);
}

inline static integer Melder_iroundAwayFromZero (double x) {
 double xround = Melder_roundAwayFromZero (x);
 do { if (! (xround >= (double) ( sizeof (integer) == 4 ? 
# 63 "../melder/melder_ftoi.h" 3 4
(-2147483647-1) 
# 63 "../melder/melder_ftoi.h"
: 
# 63 "../melder/melder_ftoi.h" 3 4
(-9223372036854775807L -1) 
# 63 "../melder/melder_ftoi.h"
) && xround <= (double) ( sizeof (integer) == 4 ? 
# 63 "../melder/melder_ftoi.h" 3 4
(2147483647) 
# 63 "../melder/melder_ftoi.h"
: 
# 63 "../melder/melder_ftoi.h" 3 4
(9223372036854775807L) 
# 63 "../melder/melder_ftoi.h"
))) do { Melder_appendError (U"When rounding the real value ", x, U" away from zero, the result cannot be represented in an integer."); throw MelderError (); } while (false); } while (false)
                                                                                                           ;
 return (integer) xround;
}

inline static double Melder_round_tieUp (double x) {
 return Melder_roundDown (x + 0.5);
}

inline static integer Melder_iround_tieUp (double x) {
 double xround = Melder_round_tieUp (x);
 do { if (! (xround >= (double) ( sizeof (integer) == 4 ? 
# 74 "../melder/melder_ftoi.h" 3 4
(-2147483647-1) 
# 74 "../melder/melder_ftoi.h"
: 
# 74 "../melder/melder_ftoi.h" 3 4
(-9223372036854775807L -1) 
# 74 "../melder/melder_ftoi.h"
) && xround <= (double) ( sizeof (integer) == 4 ? 
# 74 "../melder/melder_ftoi.h" 3 4
(2147483647) 
# 74 "../melder/melder_ftoi.h"
: 
# 74 "../melder/melder_ftoi.h" 3 4
(9223372036854775807L) 
# 74 "../melder/melder_ftoi.h"
))) do { Melder_appendError (U"When rounding the real value ", x, U", the result cannot be represented in an integer."); throw MelderError (); } while (false); } while (false)
                                                                                            ;
 return (integer) xround;
}


inline static double Melder_round_tieDown (double x) {
 return Melder_roundUp (x - 0.5);
}

inline static integer Melder_iround_tieDown (double x) {
 double xround = Melder_round_tieDown (x);
 do { if (! (xround >= (double) ( sizeof (integer) == 4 ? 
# 86 "../melder/melder_ftoi.h" 3 4
(-2147483647-1) 
# 86 "../melder/melder_ftoi.h"
: 
# 86 "../melder/melder_ftoi.h" 3 4
(-9223372036854775807L -1) 
# 86 "../melder/melder_ftoi.h"
) && xround <= (double) ( sizeof (integer) == 4 ? 
# 86 "../melder/melder_ftoi.h" 3 4
(2147483647) 
# 86 "../melder/melder_ftoi.h"
: 
# 86 "../melder/melder_ftoi.h" 3 4
(9223372036854775807L) 
# 86 "../melder/melder_ftoi.h"
))) do { Melder_appendError (U"When rounding the real value ", x, U", the result cannot be represented in an integer."); throw MelderError (); } while (false); } while (false)
                                                                                            ;
 return (integer) xround;
}

inline static double Melder_round_tieTowardsZero (double x) {
 return x >= 0.0 ? Melder_round_tieDown (x) : Melder_round_tieUp (x);
}

inline static integer Melder_iround_tieTowardsZero (double x) {
 double xround = Melder_round_tieTowardsZero (x);
 do { if (! (xround >= (double) ( sizeof (integer) == 4 ? 
# 97 "../melder/melder_ftoi.h" 3 4
(-2147483647-1) 
# 97 "../melder/melder_ftoi.h"
: 
# 97 "../melder/melder_ftoi.h" 3 4
(-9223372036854775807L -1) 
# 97 "../melder/melder_ftoi.h"
) && xround <= (double) ( sizeof (integer) == 4 ? 
# 97 "../melder/melder_ftoi.h" 3 4
(2147483647) 
# 97 "../melder/melder_ftoi.h"
: 
# 97 "../melder/melder_ftoi.h" 3 4
(9223372036854775807L) 
# 97 "../melder/melder_ftoi.h"
))) do { Melder_appendError (U"When rounding the real value ", x, U", the result cannot be represented in an integer."); throw MelderError (); } while (false); } while (false)
                                                                                            ;
 return (integer) xround;
}

inline static double Melder_round_tieAwayFromZero (double x) {
 return x >= 0.0 ? Melder_round_tieUp (x) : Melder_round_tieDown (x);
}

inline static integer Melder_iround_tieAwayFromZero (double x) {
 double xround = Melder_round_tieAwayFromZero (x);
 do { if (! (xround >= (double) ( sizeof (integer) == 4 ? 
# 108 "../melder/melder_ftoi.h" 3 4
(-2147483647-1) 
# 108 "../melder/melder_ftoi.h"
: 
# 108 "../melder/melder_ftoi.h" 3 4
(-9223372036854775807L -1) 
# 108 "../melder/melder_ftoi.h"
) && xround <= (double) ( sizeof (integer) == 4 ? 
# 108 "../melder/melder_ftoi.h" 3 4
(2147483647) 
# 108 "../melder/melder_ftoi.h"
: 
# 108 "../melder/melder_ftoi.h" 3 4
(9223372036854775807L) 
# 108 "../melder/melder_ftoi.h"
))) do { Melder_appendError (U"When rounding the real value ", x, U", the result cannot be represented in an integer."); throw MelderError (); } while (false); } while (false)
                                                                                            ;
 return (integer) xround;
}
# 97 "../melder/melder.h" 2
# 1 "../melder/melder_time.h" 1
# 21 "../melder/melder_time.h"
double Melder_stopwatch ();

void Melder_sleep (double duration);

double Melder_clock ();

autostring32 STRdate ();
# 98 "../melder/melder.h" 2
# 1 "../melder/melder_audio.h" 1
# 21 "../melder/melder_audio.h"
void MelderAudio_setInputSoundSystem (enum kMelder_inputSoundSystem inputSoundSystem);
enum kMelder_inputSoundSystem MelderAudio_getInputSoundSystem ();

void MelderAudio_setOutputSoundSystem (enum kMelder_outputSoundSystem outputSoundSystem);
enum kMelder_outputSoundSystem MelderAudio_getOutputSoundSystem ();
# 44 "../melder/melder_audio.h"
void MelderAudio_setOutputSilenceBefore (double silenceBefore);
double MelderAudio_getOutputSilenceBefore ();
void MelderAudio_setOutputSilenceAfter (double silenceAfter);
double MelderAudio_getOutputSilenceAfter ();

void MelderAudio_setUseInternalSpeaker (bool useInternalSpeaker);
bool MelderAudio_getUseInternalSpeaker ();
integer MelderAudio_getOutputBestSampleRate (integer fsamp);

extern bool MelderAudio_isPlaying;
extern bool MelderAudio_hasBeenInitialized;
void MelderAudio_play16 (int16 *buffer, integer sampleRate, integer numberOfSamples, integer numberOfChannels,
 bool (*playCallback) (void *playClosure, integer numberOfSamplesPlayed),
 void *playClosure);
bool MelderAudio_stopPlaying (bool isExplicit);


integer MelderAudio_getSamplesPlayed ();
bool MelderAudio_stopWasExplicit ();

void Melder_audio_prefs ();

#pragma mark - ASYNCHRONICITY

void MelderAudio_setOutputMaximumAsynchronicity (enum kMelder_asynchronicityLevel maximumAsynchronicity);
enum kMelder_asynchronicityLevel MelderAudio_getOutputMaximumAsynchronicity ();

class autoMelderAudioSaveMaximumAsynchronicity {
 bool _disowned;
 enum kMelder_asynchronicityLevel _savedAsynchronicity;
public:
 autoMelderAudioSaveMaximumAsynchronicity () {
  this -> _savedAsynchronicity = MelderAudio_getOutputMaximumAsynchronicity ();
  (! Melder_isTracing ? (void) 0 : Melder_trace ("../melder/melder_audio.h", 77, __FUNCTION__, U"value was ", (int) this -> _savedAsynchronicity));
  this -> _disowned = false;
 }
 ~autoMelderAudioSaveMaximumAsynchronicity () {
  MelderAudio_setOutputMaximumAsynchronicity (this -> _savedAsynchronicity);
  (! Melder_isTracing ? (void) 0 : Melder_trace ("../melder/melder_audio.h", 82, __FUNCTION__, U"value set to ", (int) this -> _savedAsynchronicity));
 }



 autoMelderAudioSaveMaximumAsynchronicity (const autoMelderAudioSaveMaximumAsynchronicity&) = delete;
 autoMelderAudioSaveMaximumAsynchronicity& operator= (const autoMelderAudioSaveMaximumAsynchronicity&) = delete;



 autoMelderAudioSaveMaximumAsynchronicity (autoMelderAudioSaveMaximumAsynchronicity&& other) noexcept {
  this -> _disowned = other._disowned;
  this -> _savedAsynchronicity = other._savedAsynchronicity;
  other._disowned = true;
 }
 autoMelderAudioSaveMaximumAsynchronicity& operator= (autoMelderAudioSaveMaximumAsynchronicity&& other) noexcept {
  if (& other != this) {
   this -> _disowned = other._disowned;
   this -> _savedAsynchronicity = other._savedAsynchronicity;
   other._disowned = true;
  }
  return *this;
 }
 autoMelderAudioSaveMaximumAsynchronicity&& move () noexcept { return static_cast <autoMelderAudioSaveMaximumAsynchronicity&&> (*this); }
 void releaseToAmbiguousOwner () {
  this -> _disowned = true;
 }
};





extern bool Melder_asynchronous;

class autoMelderAsynchronous {
 bool _disowned;
 bool _savedAsynchronicity;
public:
 autoMelderAsynchronous () {
  this -> _savedAsynchronicity = Melder_asynchronous;
  Melder_asynchronous = true;
  this -> _disowned = false;
 }
 ~autoMelderAsynchronous () {
  if (! _disowned) {
   Melder_asynchronous = _savedAsynchronicity;
  }
 }



 autoMelderAsynchronous (const autoMelderAsynchronous&) = delete;
 autoMelderAsynchronous& operator= (const autoMelderAsynchronous&) = delete;



 autoMelderAsynchronous (autoMelderAsynchronous&& other) noexcept {
  this -> _disowned = other._disowned;
  this -> _savedAsynchronicity = other._savedAsynchronicity;
  other._disowned = true;
 }
 autoMelderAsynchronous& operator= (autoMelderAsynchronous&& other) noexcept {
  if (& other != this) {
   this -> _disowned = other._disowned;
   this -> _savedAsynchronicity = other._savedAsynchronicity;
   other._disowned = true;
  }
  return *this;
 }
 autoMelderAsynchronous&& move () noexcept { return static_cast <autoMelderAsynchronous&&> (*this); }
 void releaseToAmbiguousOwner () {
  this -> _disowned = true;
 }
};
# 99 "../melder/melder.h" 2
# 1 "../melder/melder_audiofiles.h" 1
# 21 "../melder/melder_audiofiles.h"
#pragma mark - AUDIO FILES
# 32 "../melder/melder_audiofiles.h"
conststring32 Melder_audioFileTypeString (int audioFileType);
# 56 "../melder/melder_audiofiles.h"
int Melder_defaultAudioFileEncoding (int audioFileType, int numberOfBitsPerSamplePoint);
void MelderFile_writeAudioFileHeader (MelderFile file, int audioFileType, integer sampleRate, integer numberOfSamples, integer numberOfChannels, int numberOfBitsPerSamplePoint);
void MelderFile_writeAudioFileTrailer (MelderFile file, int audioFileType, integer sampleRate, integer numberOfSamples, integer numberOfChannels, int numberOfBitsPerSamplePoint);
void MelderFile_writeAudioFile (MelderFile file, int audioFileType, const short *buffer, integer sampleRate, integer numberOfSamples, integer numberOfChannels, int numberOfBitsPerSamplePoint);

int MelderFile_checkSoundFile (MelderFile file, integer *numberOfChannels, int *encoding,
 double *sampleRate, integer *startOfData, integer *numberOfSamples);




int Melder_bytesPerSamplePoint (int encoding);
void Melder_readAudioToFloat (FILE *f, int encoding, MAT buffer);


void Melder_readAudioToShort (FILE *f, integer numberOfChannels, int encoding, short *buffer, integer numberOfSamples);



void MelderFile_writeFloatToAudio (MelderFile file, constMATVU const& buffer, int encoding, bool warnIfClipped);
void MelderFile_writeShortToAudio (MelderFile file, integer numberOfChannels, int encoding, const short *buffer, integer numberOfSamples);
# 100 "../melder/melder.h" 2
# 110 "../melder/melder.h"
extern int32 Melder_systemVersion;
# 121 "../melder/melder.h"
extern bool Melder_batch;





extern bool Melder_backgrounding;

void Melder_init ();

# 1 "../melder/melder_quantity.h" 1
# 27 "../melder/melder_quantity.h"
conststring32 MelderQuantity_getText (int quantity);
conststring32 MelderQuantity_getWithUnitText (int quantity);
conststring32 MelderQuantity_getLongUnitText (int quantity);
conststring32 MelderQuantity_getShortUnitText (int quantity);
# 132 "../melder/melder.h" 2

# 1 "../melder/MelderReadText.h" 1
# 21 "../melder/MelderReadText.h"
struct structMelderReadText {
 autostring32 string32;
 char32 *readPointer32;
 autostring8 string8;
 char *readPointer8;
 kMelder_textInputEncoding input8Encoding;
 structMelderReadText () : readPointer32 (nullptr), readPointer8 (nullptr) {



  ((! this -> string32) ? (void) (0) : (Melder_assert_ ("../melder/MelderReadText.h", 31, "! our string32"), abort ()));
  ((! this -> string8) ? (void) (0) : (Melder_assert_ ("../melder/MelderReadText.h", 32, "! our string8"), abort ()));
 }
};
typedef struct structMelderReadText *MelderReadText;


 using autoMelderReadText = std::unique_ptr<structMelderReadText>;
# 73 "../melder/MelderReadText.h"
autoMelderReadText MelderReadText_createFromFile (MelderFile file);
char32 MelderReadText_getChar (MelderReadText text);
mutablestring32 MelderReadText_readLine (MelderReadText text);
int64 MelderReadText_getNumberOfLines (MelderReadText me);
conststring32 MelderReadText_getLineNumber (MelderReadText text);
# 134 "../melder/melder.h" 2
# 1 "../melder/melder_tensorio.h" 1
# 36 "../melder/melder_tensorio.h"
void vector_writeText_i8 (const constvector<signed char>& vec, MelderFile file, conststring32 name); void vector_writeBinary_i8 (const constvector<signed char>& vec, FILE *f); autovector<signed char> vector_readText_i8 (integer size, MelderReadText text, const char *name); autovector<signed char> vector_readBinary_i8 (integer size, FILE *f); void matrix_writeText_i8 (const constmatrix<signed char>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_i8 (const constmatrix<signed char>& mat, FILE *f); automatrix<signed char> matrix_readText_i8 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<signed char> matrix_readBinary_i8 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_i8 (const consttensor3<signed char>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_i8 (const consttensor3<signed char>& mat, FILE *f); autotensor3<signed char> tensor3_readText_i8 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<signed char> tensor3_readBinary_i8 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_i16 (const constvector<int>& vec, MelderFile file, conststring32 name); void vector_writeBinary_i16 (const constvector<int>& vec, FILE *f); autovector<int> vector_readText_i16 (integer size, MelderReadText text, const char *name); autovector<int> vector_readBinary_i16 (integer size, FILE *f); void matrix_writeText_i16 (const constmatrix<int>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_i16 (const constmatrix<int>& mat, FILE *f); automatrix<int> matrix_readText_i16 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<int> matrix_readBinary_i16 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_i16 (const consttensor3<int>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_i16 (const consttensor3<int>& mat, FILE *f); autotensor3<int> tensor3_readText_i16 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<int> tensor3_readBinary_i16 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_i32 (const constvector<long>& vec, MelderFile file, conststring32 name); void vector_writeBinary_i32 (const constvector<long>& vec, FILE *f); autovector<long> vector_readText_i32 (integer size, MelderReadText text, const char *name); autovector<long> vector_readBinary_i32 (integer size, FILE *f); void matrix_writeText_i32 (const constmatrix<long>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_i32 (const constmatrix<long>& mat, FILE *f); automatrix<long> matrix_readText_i32 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<long> matrix_readBinary_i32 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_i32 (const consttensor3<long>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_i32 (const consttensor3<long>& mat, FILE *f); autotensor3<long> tensor3_readText_i32 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<long> tensor3_readBinary_i32 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_integer32BE (const constvector<integer>& vec, MelderFile file, conststring32 name); void vector_writeBinary_integer32BE (const constvector<integer>& vec, FILE *f); autovector<integer> vector_readText_integer32BE (integer size, MelderReadText text, const char *name); autovector<integer> vector_readBinary_integer32BE (integer size, FILE *f); void matrix_writeText_integer32BE (const constmatrix<integer>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_integer32BE (const constmatrix<integer>& mat, FILE *f); automatrix<integer> matrix_readText_integer32BE (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<integer> matrix_readBinary_integer32BE (integer nrow, integer ncol, FILE *f); void tensor3_writeText_integer32BE (const consttensor3<integer>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_integer32BE (const consttensor3<integer>& mat, FILE *f); autotensor3<integer> tensor3_readText_integer32BE (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<integer> tensor3_readBinary_integer32BE (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_integer16BE (const constvector<integer>& vec, MelderFile file, conststring32 name); void vector_writeBinary_integer16BE (const constvector<integer>& vec, FILE *f); autovector<integer> vector_readText_integer16BE (integer size, MelderReadText text, const char *name); autovector<integer> vector_readBinary_integer16BE (integer size, FILE *f); void matrix_writeText_integer16BE (const constmatrix<integer>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_integer16BE (const constmatrix<integer>& mat, FILE *f); automatrix<integer> matrix_readText_integer16BE (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<integer> matrix_readBinary_integer16BE (integer nrow, integer ncol, FILE *f); void tensor3_writeText_integer16BE (const consttensor3<integer>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_integer16BE (const consttensor3<integer>& mat, FILE *f); autotensor3<integer> tensor3_readText_integer16BE (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<integer> tensor3_readBinary_integer16BE (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_u8 (const constvector<unsigned char>& vec, MelderFile file, conststring32 name); void vector_writeBinary_u8 (const constvector<unsigned char>& vec, FILE *f); autovector<unsigned char> vector_readText_u8 (integer size, MelderReadText text, const char *name); autovector<unsigned char> vector_readBinary_u8 (integer size, FILE *f); void matrix_writeText_u8 (const constmatrix<unsigned char>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_u8 (const constmatrix<unsigned char>& mat, FILE *f); automatrix<unsigned char> matrix_readText_u8 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<unsigned char> matrix_readBinary_u8 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_u8 (const consttensor3<unsigned char>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_u8 (const consttensor3<unsigned char>& mat, FILE *f); autotensor3<unsigned char> tensor3_readText_u8 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<unsigned char> tensor3_readBinary_u8 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_u16 (const constvector<unsigned int>& vec, MelderFile file, conststring32 name); void vector_writeBinary_u16 (const constvector<unsigned int>& vec, FILE *f); autovector<unsigned int> vector_readText_u16 (integer size, MelderReadText text, const char *name); autovector<unsigned int> vector_readBinary_u16 (integer size, FILE *f); void matrix_writeText_u16 (const constmatrix<unsigned int>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_u16 (const constmatrix<unsigned int>& mat, FILE *f); automatrix<unsigned int> matrix_readText_u16 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<unsigned int> matrix_readBinary_u16 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_u16 (const consttensor3<unsigned int>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_u16 (const consttensor3<unsigned int>& mat, FILE *f); autotensor3<unsigned int> tensor3_readText_u16 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<unsigned int> tensor3_readBinary_u16 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_u32 (const constvector<unsigned long>& vec, MelderFile file, conststring32 name); void vector_writeBinary_u32 (const constvector<unsigned long>& vec, FILE *f); autovector<unsigned long> vector_readText_u32 (integer size, MelderReadText text, const char *name); autovector<unsigned long> vector_readBinary_u32 (integer size, FILE *f); void matrix_writeText_u32 (const constmatrix<unsigned long>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_u32 (const constmatrix<unsigned long>& mat, FILE *f); automatrix<unsigned long> matrix_readText_u32 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<unsigned long> matrix_readBinary_u32 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_u32 (const consttensor3<unsigned long>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_u32 (const consttensor3<unsigned long>& mat, FILE *f); autotensor3<unsigned long> tensor3_readText_u32 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<unsigned long> tensor3_readBinary_u32 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_r32 (const constvector<double>& vec, MelderFile file, conststring32 name); void vector_writeBinary_r32 (const constvector<double>& vec, FILE *f); autovector<double> vector_readText_r32 (integer size, MelderReadText text, const char *name); autovector<double> vector_readBinary_r32 (integer size, FILE *f); void matrix_writeText_r32 (const constmatrix<double>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_r32 (const constmatrix<double>& mat, FILE *f); automatrix<double> matrix_readText_r32 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<double> matrix_readBinary_r32 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_r32 (const consttensor3<double>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_r32 (const consttensor3<double>& mat, FILE *f); autotensor3<double> tensor3_readText_r32 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<double> tensor3_readBinary_r32 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_r64 (const constvector<double>& vec, MelderFile file, conststring32 name); void vector_writeBinary_r64 (const constvector<double>& vec, FILE *f); autovector<double> vector_readText_r64 (integer size, MelderReadText text, const char *name); autovector<double> vector_readBinary_r64 (integer size, FILE *f); void matrix_writeText_r64 (const constmatrix<double>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_r64 (const constmatrix<double>& mat, FILE *f); automatrix<double> matrix_readText_r64 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<double> matrix_readBinary_r64 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_r64 (const consttensor3<double>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_r64 (const consttensor3<double>& mat, FILE *f); autotensor3<double> tensor3_readText_r64 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<double> tensor3_readBinary_r64 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_c64 (const constvector<dcomplex>& vec, MelderFile file, conststring32 name); void vector_writeBinary_c64 (const constvector<dcomplex>& vec, FILE *f); autovector<dcomplex> vector_readText_c64 (integer size, MelderReadText text, const char *name); autovector<dcomplex> vector_readBinary_c64 (integer size, FILE *f); void matrix_writeText_c64 (const constmatrix<dcomplex>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_c64 (const constmatrix<dcomplex>& mat, FILE *f); automatrix<dcomplex> matrix_readText_c64 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<dcomplex> matrix_readBinary_c64 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_c64 (const consttensor3<dcomplex>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_c64 (const consttensor3<dcomplex>& mat, FILE *f); autotensor3<dcomplex> tensor3_readText_c64 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<dcomplex> tensor3_readBinary_c64 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
void vector_writeText_c128 (const constvector<dcomplex>& vec, MelderFile file, conststring32 name); void vector_writeBinary_c128 (const constvector<dcomplex>& vec, FILE *f); autovector<dcomplex> vector_readText_c128 (integer size, MelderReadText text, const char *name); autovector<dcomplex> vector_readBinary_c128 (integer size, FILE *f); void matrix_writeText_c128 (const constmatrix<dcomplex>& mat, MelderFile file, conststring32 name); void matrix_writeBinary_c128 (const constmatrix<dcomplex>& mat, FILE *f); automatrix<dcomplex> matrix_readText_c128 (integer nrow, integer ncol, MelderReadText text, const char *name); automatrix<dcomplex> matrix_readBinary_c128 (integer nrow, integer ncol, FILE *f); void tensor3_writeText_c128 (const consttensor3<dcomplex>& mat, MelderFile file, conststring32 name); void tensor3_writeBinary_c128 (const consttensor3<dcomplex>& mat, FILE *f); autotensor3<dcomplex> tensor3_readText_c128 (integer ndim1, integer ndim2, integer ndim3, MelderReadText text, const char *name); autotensor3<dcomplex> tensor3_readBinary_c128 (integer ndim1, integer ndim2, integer ndim3, FILE *f);
# 135 "../melder/melder.h" 2
# 1 "../melder/melder_sysenv.h" 1
# 21 "../melder/melder_sysenv.h"
conststring32 Melder_getenv (conststring32 variableName);
void Melder_system (conststring32 command);
void Melder_execv (conststring32 executableFileName, integer narg, char32 **args);
# 136 "../melder/melder.h" 2
# 1 "../melder/abcio_enums.h" 1
# 19 "../melder/abcio_enums.h"
enum class kBoolean { UNDEFINED = -1, MIN = 0,
 FALSE_ = 0,
 TRUE_ = 1,
MAX = 1, DEFAULT = FALSE_ }; conststring32 kBoolean_getText (kBoolean value); kBoolean kBoolean_getValue (conststring32 text); inline static kBoolean& operator++ (kBoolean& value) { value = static_cast <kBoolean> (static_cast <int> (value) + 1); return value; }

enum class kQuestion { UNDEFINED = -1, MIN = 0,
 NO = 0,
 YES = 1,
MAX = 1, DEFAULT = NO }; conststring32 kQuestion_getText (kQuestion value); kQuestion kQuestion_getValue (conststring32 text); inline static kQuestion& operator++ (kQuestion& value) { value = static_cast <kQuestion> (static_cast <int> (value) + 1); return value; }

enum class kExistence { UNDEFINED = -1, MIN = 0,
 ABSENT = 0,
 EXISTS = 1,
MAX = 1, DEFAULT = ABSENT }; conststring32 kExistence_getText (kExistence value); kExistence kExistence_getValue (conststring32 text); inline static kExistence& operator++ (kExistence& value) { value = static_cast <kExistence> (static_cast <int> (value) + 1); return value; }
# 137 "../melder/melder.h" 2
# 1 "../melder/abcio.h" 1
# 23 "../melder/abcio.h"
int texgeti8 (MelderReadText text);
int16 texgeti16 (MelderReadText text);
int32 texgeti32 (MelderReadText text);
integer texgetinteger (MelderReadText text);


unsigned int texgetu8 (MelderReadText text);
uint16 texgetu16 (MelderReadText text);
uint32 texgetu32 (MelderReadText text);
double texgetr32 (MelderReadText text);
double texgetr64 (MelderReadText text);
double texgetr80 (MelderReadText text);
dcomplex texgetc64 (MelderReadText text);
dcomplex texgetc128 (MelderReadText text);
int texgete8 (MelderReadText text, enum_generic_getValue getValue);
int texgete16 (MelderReadText text, enum_generic_getValue getValue);
bool texgeteb (MelderReadText text);
bool texgeteq (MelderReadText text);
bool texgetex (MelderReadText text);
autostring32 texgetw16 (MelderReadText text);
autostring32 texgetw32 (MelderReadText text);

void texindent (MelderFile file);
void texexdent (MelderFile file);
void texresetindent (MelderFile file);





void texputintro (MelderFile file, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputi8 (MelderFile file, int i, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputi16 (MelderFile file, int i, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputi32 (MelderFile file, long i, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputinteger (MelderFile file, integer i, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);


void texputu8 (MelderFile file, unsigned int u, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputu16 (MelderFile file, unsigned int u, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputu32 (MelderFile file, unsigned long u, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputr32 (MelderFile file, double x, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputr64 (MelderFile file, double x, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputc64 (MelderFile file, dcomplex z, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputc128 (MelderFile file, dcomplex z, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texpute8 (MelderFile file, int i, conststring32 (*getText) (int), conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texpute16 (MelderFile file, int i, conststring32 (*getText) (int), conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputeb (MelderFile file, bool i, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputeq (MelderFile file, bool i, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputex (MelderFile file, bool i, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputs8 (MelderFile file, conststring8 s, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputs16 (MelderFile file, conststring8 s, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputs32 (MelderFile file, conststring8 s, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputw16 (MelderFile file, conststring32 s, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
void texputw32 (MelderFile file, conststring32 s, conststring32 s1 = nullptr, conststring32 s2 = nullptr, conststring32 s3 = nullptr, conststring32 s4 = nullptr, conststring32 s5 = nullptr, conststring32 s6 = nullptr, conststring32 s7 = nullptr, conststring32 s8 = nullptr, conststring32 s9 = nullptr);
# 86 "../melder/abcio.h"
unsigned int bingetu8 (FILE *f); void binputu8 (unsigned int i, FILE *f);
uint16 bingetu16 (FILE *f); void binputu16 (uint16 i, FILE *f);
uint32 bingetu32 (FILE *f); void binputu32 (uint32 i, FILE *f);

int bingeti8 (FILE *f); void binputi8 (int i, FILE *f);
int16 bingeti16 (FILE *f); void binputi16 (int16 i, FILE *f);
int32 bingeti24 (FILE *f); void binputi24 (int32 i, FILE *f);
int32 bingeti32 (FILE *f); void binputi32 (int32 i, FILE *f);
integer bingetinteger32BE (FILE *f); void binputinteger32BE (integer i, FILE *f);
integer bingetinteger16BE (FILE *f); void binputinteger16BE (integer i, FILE *f);






int16 bingeti16LE (FILE *f); void binputi16LE (int16 i, FILE *f);
int32 bingeti24LE (FILE *f); void binputi24LE (int32 i, FILE *f);
int32 bingeti32LE (FILE *f); void binputi32LE (int32 i, FILE *f);
uint16 bingetu16LE (FILE *f); void binputu16LE (uint16 i, FILE *f);
uint32 bingetu32LE (FILE *f); void binputu32LE (uint32 i, FILE *f);






unsigned int bingetb1 (FILE *f); void binputb1 (unsigned int value, FILE *f);
unsigned int bingetb2 (FILE *f); void binputb2 (unsigned int value, FILE *f);
unsigned int bingetb3 (FILE *f); void binputb3 (unsigned int value, FILE *f);
unsigned int bingetb4 (FILE *f); void binputb4 (unsigned int value, FILE *f);
unsigned int bingetb5 (FILE *f); void binputb5 (unsigned int value, FILE *f);
unsigned int bingetb6 (FILE *f); void binputb6 (unsigned int value, FILE *f);
unsigned int bingetb7 (FILE *f); void binputb7 (unsigned int value, FILE *f);
void bingetb (FILE *f); void binputb (FILE *f);
# 137 "../melder/abcio.h"
int bingete8 (FILE *f, int min, int max, conststring32 type);
int bingete16 (FILE *f, int min, int max, conststring32 type);
bool bingetbool8 (FILE *f);




void binpute8 (int value, FILE *f);
void binpute16 (int value, FILE *f);
void binputbool8 (bool value, FILE *f);




double bingetr32 (FILE *f); void binputr32 (double x, FILE *f);
# 160 "../melder/abcio.h"
double bingetr32LE (FILE *f); void binputr32LE (double x, FILE *f);

double bingetr64 (FILE *f); void binputr64 (double x, FILE *f);
# 171 "../melder/abcio.h"
double bingetr64LE (FILE *f); void binputr64LE (double x, FILE *f);

double bingetr80 (FILE *f); void binputr80 (double x, FILE *f);
# 185 "../melder/abcio.h"
dcomplex bingetc64 (FILE *f);
dcomplex bingetc128 (FILE *f);
void binputc64 (dcomplex z, FILE *f);
void binputc128 (dcomplex z, FILE *f);

autostring8 bingets8 (FILE *f); void binputs8 (const char *s, FILE *f);
autostring8 bingets16 (FILE *f); void binputs16 (const char *s, FILE *f);
autostring8 bingets32 (FILE *f); void binputs32 (const char *s, FILE *f);







autostring32 bingetw8 (FILE *f); void binputw8 (conststring32 s, FILE *f);
autostring32 bingetw16 (FILE *f); void binputw16 (conststring32 s, FILE *f);
autostring32 bingetw32 (FILE *f); void binputw32 (conststring32 s, FILE *f);
# 138 "../melder/melder.h" 2

# 1 "../melder/melder_templates.h" 1
# 25 "../melder/melder_templates.h"
template <typename Ret, typename T, typename... Args>
class MelderCallback {
 public:
  using FunctionType = Ret* (*) (T*, Args...);
  MelderCallback (FunctionType f = nullptr) : _f (f) { }
  template <typename T2 , typename Ret2 >
  MelderCallback (Ret2* (*f) (T2*, Args...)) : _f (reinterpret_cast<FunctionType> (f)) {
   static_assert (std::is_base_of <T, T2> :: value,
    "First argument of MelderCallback should have covariant type.");
   static_assert (std::is_base_of <Ret, Ret2> :: value,
    "Return type of MelderCallback should be covariant.");
  };
  Ret* operator () (T* data, Args ... args) { return _f (data, std::forward<Args>(args)...); }
  explicit operator bool () const noexcept { return !! _f; }
 private:
  FunctionType _f;
};
template <typename T, typename... Args>
class MelderCallback <void, T, Args...> {
 public:
  using FunctionType = void (*) (T*, Args...);
  MelderCallback (FunctionType f = nullptr) : _f (f) { }
  template <typename T2 >
  MelderCallback (void (*f) (T2*, Args...)) : _f (reinterpret_cast<FunctionType> (f)) {
   static_assert (std::is_base_of <T, T2> :: value,
    "First argument of MelderCallback should have covariant type.");
  };
  void operator () (T* data, Args ... args) { _f (data, std::forward<Args>(args)...); }
  explicit operator bool () const noexcept { return !! _f; }
 private:
  FunctionType _f;
};
template <typename T, typename... Args>
class MelderCallback <int, T, Args...> {
 public:
  using FunctionType = int (*) (T*, Args...);
  MelderCallback (FunctionType f = nullptr) : _f (f) { }
  template <typename T2 >
  MelderCallback (int (*f) (T2*, Args...)) : _f (reinterpret_cast<FunctionType> (f)) {
   static_assert (std::is_base_of <T, T2> :: value,
    "First argument of MelderCallback should have covariant type.");
  };
  int operator () (T* data, Args ... args) { return _f (data, std::forward<Args>(args)...); }
  explicit operator bool () const noexcept { return !! _f; }
 private:
  FunctionType _f;
};

template <typename T>
class MelderCompareHook {
 public:
  typedef int (*FunctionType) (T*, T*);
  MelderCompareHook (FunctionType f = nullptr) : _f (f) { }
  template <typename T2 , class = typename std::enable_if_t<std::is_base_of<T,T2>::value> >
   MelderCompareHook (int (*f) (T2*, T2*)) : _f (reinterpret_cast<FunctionType> (f)) { };
  int operator () (T* data1, T* data2) noexcept { return _f (data1, data2); }
  explicit operator bool () const noexcept { return !! _f; }
  FunctionType get () { return _f; }
 private:
  FunctionType _f;
};
# 140 "../melder/melder.h" 2

# 1 "../melder/NUMspecfunc.h" 1
# 21 "../melder/NUMspecfunc.h"
double NUMlnGamma (double x);
double NUMbeta (double z, double w);
double NUMbesselI (integer n, double x);
double NUMbessel_i0_f (double x);
double NUMbessel_i1_f (double x);
double NUMbesselK (integer n, double x);
double NUMbessel_k0_f (double x);
double NUMbessel_k1_f (double x);
double NUMbesselK_f (integer n, double x);
double NUMsigmoid (double x);
double NUMinvSigmoid (double x);
double NUMerfcc (double x);
double NUMgaussP (double z);
double NUMgaussQ (double z);
double NUMincompleteGammaP (double a, double x);
double NUMincompleteGammaQ (double a, double x);
double NUMchiSquareP (double chiSquare, double degreesOfFreedom);
double NUMchiSquareQ (double chiSquare, double degreesOfFreedom);
double NUMcombinations (integer n, integer k);
double NUMincompleteBeta (double a, double b, double x);
double NUMbinomialP (double p, double k, double n);
double NUMbinomialQ (double p, double k, double n);
double NUMinvBinomialP (double p, double k, double n);
double NUMinvBinomialQ (double p, double k, double n);
# 142 "../melder/melder.h" 2
# 1 "../melder/NUMear.h" 1
# 23 "../melder/NUMear.h"
double NUMhertzToBark (double hertz);
double NUMbarkToHertz (double bark);
double NUMphonToDifferenceLimens (double phon);
double NUMdifferenceLimensToPhon (double ndli);
double NUMsoundPressureToPhon (double soundPressure, double bark);
double NUMhertzToMel (double hertz);
double NUMmelToHertz (double mel);
double NUMhertzToSemitones (double hertz);
double NUMsemitonesToHertz (double semitones);
double NUMerb (double f);
double NUMhertzToErb (double hertz);
double NUMerbToHertz (double erb);
# 143 "../melder/melder.h" 2
# 1 "../melder/NUMinterpol.h" 1
# 30 "../melder/NUMinterpol.h"
double NUM_interpolate_sinc (constVEC const& y, double x, integer interpolationDepth);







double NUMimproveExtremum (constVEC const& y, integer ixmid, int interpolation, double *ixmid_real, bool isMaximum);
double NUMimproveMaximum (constVEC const& y, integer ixmid, int interpolation, double *ixmid_real);
double NUMimproveMinimum (constVEC const& y, integer ixmid, int interpolation, double *ixmid_real);

void NUM_viterbi (
 integer numberOfFrames, integer maxnCandidates,
 integer (*getNumberOfCandidates) (integer iframe, void *closure),
 double (*getLocalCost) (integer iframe, integer icand, void *closure),
 double (*getTransitionCost) (integer iframe, integer icand1, integer icand2, void *closure),
 void (*putResult) (integer iframe, integer place, void *closure),
 void *closure);

void NUM_viterbi_multi (
 integer nframe, integer ncand, integer ntrack,
 double (*getLocalCost) (integer iframe, integer icand, integer itrack, void *closure),
 double (*getTransitionCost) (integer iframe, integer icand1, integer icand2, integer itrack, void *closure),
 void (*putResult) (integer iframe, integer place, integer itrack, void *closure),
 void *closure);
# 144 "../melder/melder.h" 2
# 1 "../melder/NUMmetrics.h" 1
# 23 "../melder/NUMmetrics.h"
int NUMrotationsPointInPolygon
 (double x0, double y0, integer n, double x [], double y []);
# 145 "../melder/melder.h" 2
# 1 "../melder/NUMrandom.h" 1
# 23 "../melder/NUMrandom.h"
void NUMrandom_init ();

double NUMrandomFraction ();
double NUMrandomFraction_mt (int threadNumber);

double NUMrandomUniform (double lowest, double highest);

integer NUMrandomInteger (integer lowest, integer highest);

bool NUMrandomBernoulli (double probability);
double NUMrandomBernoulli_real (double probability);

double NUMrandomGauss (double mean, double standardDeviation);
double NUMrandomGauss_mt (int threadNumber, double mean, double standardDeviation);

double NUMrandomPoisson (double mean);

uint32 NUMhashString (conststring32 string);
# 146 "../melder/melder.h" 2
# 1 "../melder/NUMfilter.h" 1
# 21 "../melder/NUMfilter.h"
void NUMfbtoa (double formant, double bandwidth, double dt, double *a1, double *a2);
void VECfilterSecondOrderSection_a_inplace (VECVU const& x, double a1, double a2);
void VECfilterSecondOrderSection_fb_inplace (VECVU const& x, double dt, double formant, double bandwidth);
double NUMftopreemphasis (double f, double dt);
void VECpreemphasize_a_inplace (VECVU const& x, double preemphasis);
void VECdeemphasize_a_inplace (VECVU const& x, double preemphasis);
void VECpreemphasize_f_inplace (VECVU const& x, double dt, double frequency);
void VECdeemphasize_f_inplace (VECVU const& x, double dt, double frequency);
# 147 "../melder/melder.h" 2
# 1 "../melder/NUMlinprog.h" 1
# 23 "../melder/NUMlinprog.h"
typedef struct structNUMlinprog *NUMlinprog;
void NUMlinprog_delete (NUMlinprog me);
NUMlinprog NUMlinprog_new (bool maximize);
void NUMlinprog_addVariable (NUMlinprog me, double lowerBound, double upperBound, double coeff);
void NUMlinprog_addConstraint (NUMlinprog me, double lowerBound, double upperBound);
void NUMlinprog_addConstraintCoefficient (NUMlinprog me, double coefficient);
void NUMlinprog_run (NUMlinprog me);
double NUMlinprog_getPrimalValue (NUMlinprog me, integer ivar);
# 148 "../melder/melder.h" 2

# 1 "../melder/regularExp.h" 1
# 35 "../melder/regularExp.h"
# 1 "../melder/melder.h" 1
# 36 "../melder/regularExp.h" 2






typedef struct regexp {
   char32 *startp [50];
   char32 *endp [50];
   char32 *extentpBW;


   char32 *extentpFW;


   int top_branch;

   char32 match_start;
   char32 anchor;
   char32 program [1];
} regexp;



typedef enum {
  REDFLT_STANDARD = 0,
  REDFLT_CASE_INSENSITIVE = 1

} RE_DEFAULT_FLAG;



regexp * CompileRE (
   conststring32 exp,
   conststring32 *errorText,
   int defaultFlags);

regexp *CompileRE_throwable (conststring32 exp, int defaultFlags);



int ExecRE (
   regexp *prog,
   regexp *cross_regex_backref,




   conststring32 string,
   const char32 *end,

   int reverse,
   char32 prev_char,

   char32 succ_char,

   conststring32 look_behind_to,

   conststring32 match_till);






int SubstituteRE (
   const regexp *prog,
   conststring32 source,
   mutablestring32 dest,
   int max,
   int *errorType);



void EnableCountingQuantifier (int is_enabled);
# 150 "../melder/melder.h" 2
# 1 "../melder/PAIRWISE_SUM.h" 1
# 151 "../melder/melder.h" 2

# 1 "../melder/NUM.h" 1
       
# 25 "../melder/NUM.h"
template <typename T>
bool NUMisEmpty (vector<T> const& x) noexcept {
 return x.size == 0;
}
template <typename T>
bool NUMisEmpty (vectorview<T> const& x) noexcept {
 return x.size == 0;
}
template <typename T>
bool NUMisEmpty (constvector<T> const& x) noexcept {
 return x.size == 0;
}
template <typename T>
bool NUMisEmpty (constvectorview<T> const& x) noexcept {
 return x.size == 0;
}

template <typename T>
bool NUMisEmpty (matrix<T> const& x) noexcept {
 const integer numberOfCells = x.nrow * x.ncol;
 return numberOfCells == 0;
}
template <typename T>
bool NUMisEmpty (constmatrix<T> const& x) noexcept {
 const integer numberOfCells = x.nrow * x.ncol;
 return numberOfCells == 0;
}
template <typename T>
bool NUMisEmpty (matrixview<T> const& x) noexcept {
 const integer numberOfCells = x.nrow * x.ncol;
 return numberOfCells == 0;
}
template <typename T>
bool NUMisEmpty (constmatrixview<T> const& x) noexcept {
 const integer numberOfCells = x.nrow * x.ncol;
 return numberOfCells == 0;
}

inline MelderRealRange NUMextrema (const constVECVU& vec) {
 if (NUMisEmpty (vec))
  return { undefined, undefined };
 double minimum = vec [1], maximum = minimum;
 for (integer i = 2; i <= vec.size; i ++) {
  const double value = vec [i];
  if (value < minimum) minimum = value;
  if (value > maximum) maximum = value;
 }
 return { minimum, maximum };
}
inline MelderRealRange NUMextrema (const constMATVU& mat) {
 if (NUMisEmpty (mat))
  return { undefined, undefined };
 double minimum = mat [1] [1], maximum = minimum;
 for (integer irow = 1; irow <= mat.nrow; irow ++) {
  for (integer icol = 1; icol <= mat.ncol; icol ++) {
   const double value = mat [irow] [icol];
   if (value < minimum)
    minimum = value;
   if (value > maximum)
    maximum = value;
  }
 }
 return { minimum, maximum };
}
inline MelderIntegerRange NUMextrema (const constINTVECVU& vec) {
 if (NUMisEmpty (vec))
  return { ( sizeof (integer) == 4 ? 
# 91 "../melder/NUM.h" 3 4
          (-2147483647-1) 
# 91 "../melder/NUM.h"
          : 
# 91 "../melder/NUM.h" 3 4
          (-9223372036854775807L -1) 
# 91 "../melder/NUM.h"
          ), ( sizeof (integer) == 4 ? 
# 91 "../melder/NUM.h" 3 4
                       (2147483647) 
# 91 "../melder/NUM.h"
                       : 
# 91 "../melder/NUM.h" 3 4
                       (9223372036854775807L) 
# 91 "../melder/NUM.h"
                       ) };
 integer minimum = vec [1], maximum = minimum;
 for (integer i = 2; i <= vec.size; i ++) {
  const integer value = vec [i];
  if (value < minimum)
   minimum = value;
  if (value > maximum)
   maximum = value;
 }
 return { minimum, maximum };
}





extern double NUMcenterOfGravity (constVECVU const& x) noexcept;

inline bool NUMdefined (constVECVU const& vec) noexcept {
 for (integer i = 1; i <= vec.size; i ++)
  if (isundef (vec [i]))
   return false;
 return true;
}
inline bool NUMdefined (constMATVU const& mat) noexcept {
 for (integer irow = 1; irow <= mat.nrow; irow ++)
  for (integer icol = 1; icol <= mat.ncol; icol ++)
   if (isundef (mat [irow] [icol]))
    return false;
 return true;
}

inline bool NUMequal (double x, double y) {





 return x == y || isundef (x) && isundef (y);
}
inline bool NUMequal (integer x, integer y) {
 return x == y;
}
inline bool NUMequal (bool x, bool y) {
 return x == y;
}
inline bool NUMequal (byte x, byte y) {
 return x == y;
}
inline bool NUMequal (dcomplex x, dcomplex y) {
 return x.real() == y.real() && x.imag() == y.imag();
}
template <typename T>
bool NUMequal (constvector<T> const& x, constvector<T> const& y) noexcept {
 const integer n = x.size;
 if (y.size != n)
  return false;
 for (integer i = 1; i <= n; i ++)
  if (! NUMequal (x [i], y [i]))
   return false;
 return true;
}
template <typename T>
bool NUMequal (vector<T> const& x, constvector<T> const& y) noexcept {
 return NUMequal (constvector<T> (x), y);
}
template <typename T>
bool NUMequal (constvector<T> const& x, vector<T> const& y) noexcept {
 return NUMequal (x, constvector<T> (y));
}
template <typename T>
bool NUMequal (vector<T> const& x, vector<T> const& y) noexcept {
 return NUMequal (constvector<T> (x), constvector<T> (y));
}

template <typename T>
bool NUMequal (constmatrix<T> const& x, constmatrix<T> const& y) noexcept {
 const integer nrow = x.nrow, ncol = x.ncol;
 if (y.nrow != nrow || y.ncol != ncol)
  return false;
 for (integer irow = 1; irow <= nrow; irow ++)
  for (integer icol = 1; icol <= ncol; icol ++)
   if (! NUMequal (x [irow] [icol], y [irow] [icol]))
    return false;
 return true;
}
template <typename T>
bool NUMequal (matrix<T> const& x, constmatrix<T> const& y) noexcept {
 return NUMequal (constmatrix<T> (x), y);
}
template <typename T>
bool NUMequal (constmatrix<T> const& x, matrix<T> const& y) noexcept {
 return NUMequal (x, constmatrix<T> (y));
}
template <typename T>
bool NUMequal (matrix<T> const& x, matrix<T> const& y) noexcept {
 return NUMequal (constmatrix<T> (x), constmatrix<T> (y));
}

inline bool NUMequal (constSTRVEC x, constSTRVEC y) noexcept {
 const integer n = x.size;
 if (y.size != n)
  return false;
 for (integer i = 1; i <= n; i ++)
  if (! ! Melder_cmp (x [i], y [i]))
   return false;
 return true;
}

inline double NUMextremum (constVECVU const& vec) noexcept {
 double extremum = 0.0;
 for (integer i = 1; i <= vec.size; i ++)
  if (fabs (vec [i]) > extremum)
   extremum = fabs (vec [i]);
 return extremum;
}
inline double NUMextremum (constMATVU const& mat) {
 MelderRealRange range = NUMextrema (mat);
 return std::max (fabs (range.min), fabs (range.max));
}

extern double NUMinner (constVECVU const& x, constVECVU const& y) noexcept;

inline bool NUMisSymmetric (constMATVU const& x) noexcept {
 if (x.nrow != x.ncol)
  return false;
 const integer n = x.nrow;
 for (integer irow = 1; irow <= n; irow ++)
  for (integer icol = irow + 1; icol < n; icol ++)
   if (x [irow] [icol] != x [icol] [irow])
    return false;
 return true;
}

inline integer NUMlength (conststring32 str) {
 return str ? str32len (str) : 0;
}

inline double NUMlog2 (double x) {
 return log (x) * NUMlog2e;
}

inline double NUMmax (constVECVU const& vec) {
 if (NUMisEmpty (vec))
  return undefined;
 double maximum = vec [1];
 for (integer i = 2; i <= vec.size; i ++) {
  const double value = vec [i];
  if (value > maximum)
   maximum = value;
 }
 return maximum;
}
inline integer NUMmax (const constINTVECVU& vec) {
 if (NUMisEmpty (vec))
  return ( sizeof (integer) == 4 ? 
# 246 "../melder/NUM.h" 3 4
        (-2147483647-1) 
# 246 "../melder/NUM.h"
        : 
# 246 "../melder/NUM.h" 3 4
        (-9223372036854775807L -1) 
# 246 "../melder/NUM.h"
        );
 integer maximum = vec [1];
 for (integer i = 2; i <= vec.size; i ++) {
  const integer value = vec [i];
  if (value > maximum)
   maximum = value;
 }
 return maximum;
}
inline double NUMmax (constMATVU const& mat) {
 if (NUMisEmpty (mat))
  return undefined;
 double maximum = NUMmax (mat [1]);
 for (integer irow = 2; irow <= mat.nrow; irow ++) {
  const double value = NUMmax (mat [irow]);
  if (value > maximum)
   maximum = value;
 }
 return maximum;
}

extern double NUMmean (constVECVU const& vec);
extern double NUMmean (constMATVU const& mat) noexcept;

extern MelderGaussianStats NUMmeanStdev (constVECVU const& vec) noexcept;
extern MelderGaussianStats NUMmeanStdev (constMATVU const& mat) noexcept;

inline double NUMmin (constVECVU const& vec) {
 if (NUMisEmpty (vec))
  return undefined;
 double minimum = vec [1];
 for (integer i = 2; i <= vec.size; i ++) {
  const double value = vec [i];
  if (value < minimum)
   minimum = value;
 }
 return minimum;
}
inline integer NUMmin (const constINTVECVU& vec) {
 if (NUMisEmpty (vec))
  return ( sizeof (integer) == 4 ? 
# 286 "../melder/NUM.h" 3 4
        (2147483647) 
# 286 "../melder/NUM.h"
        : 
# 286 "../melder/NUM.h" 3 4
        (9223372036854775807L) 
# 286 "../melder/NUM.h"
        );
 integer minimum = vec [1];
 for (integer i = 2; i <= vec.size; i ++) {
  const integer value = vec [i];
  if (value < minimum)
   minimum = value;
 }
 return minimum;
}
inline double NUMmin (constMATVU const& mat) {
 if (NUMisEmpty (mat))
  return undefined;
 double minimum = NUMmin (mat [1]);
 for (integer irow = 2; irow <= mat.nrow; irow ++) {
  const double value = NUMmin (mat [irow]);
  if (value < minimum)
   minimum = value;
 }
 return minimum;
}

double NUMnorm (constVECVU const& x, double power) noexcept;
double NUMnorm (constMATVU const& x, double power) noexcept;

integer NUMnumberOfTokens (conststring32 str) noexcept;




inline double NUMpow (double base, double exponent) {
 return base <= 0.0 ? 0.0 : pow (base, exponent);
}

inline double NUMsqrt (double x) {



 return sqrt (x);
}

extern double NUMstdev (constVECVU const& vec) noexcept;
extern double NUMstdev (constMATVU const& mat) noexcept;

extern double NUMsum (constVECVU const& vec) noexcept;
extern double NUMsum (constMATVU const& mat) noexcept;

extern double NUMsum2 (constVECVU const& vec);
extern double NUMsum2 (constMATVU const& mat);

extern double NUMsumOfSquaredDifferences (constVECVU const& vec, double mean);

extern double NUMvariance (constVECVU const& vec) noexcept;
extern double NUMvariance (constMATVU const& mat) noexcept;
# 153 "../melder/melder.h" 2
# 1 "../melder/STR.h" 1
       
# 20 "../melder/STR.h"
autostring32 newSTRleft (conststring32 str, integer newLength = 1);

autostring32 newSTRmid (conststring32 str, integer startingPosition_1, integer numberOfCharacters = 1);




autostring32 newSTRreplace (conststring32 str, conststring32 search,
 conststring32 replace, integer maximumNumberOfReplacements,
 integer *out_numberOfReplacements = nullptr);
# 39 "../melder/STR.h"
autostring32 newSTRreplace_regex (conststring32 string, regexp *search_compiled,
 conststring32 replace_regex, integer maximumNumberOfReplacements,
 integer *out_numberOfReplacements = nullptr);

autostring32 newSTRright (conststring32 str, integer newLength = 1);
# 154 "../melder/melder.h" 2
# 1 "../melder/VEC.h" 1
       
# 32 "../melder/VEC.h"
inline void operator<<= (VECVU const& target, double number) noexcept { for (integer i = 1; i <= target.size; i ++) target [i] = number; } inline void operator+= (VECVU const& target, double number) noexcept { for (integer i = 1; i <= target.size; i ++) target [i] += number; } inline void operator-= (VECVU const& target, double number) noexcept { for (integer i = 1; i <= target.size; i ++) target [i] -= number; } inline void operator*= (VECVU const& target, double number) noexcept { for (integer i = 1; i <= target.size; i ++) target [i] *= number; } inline void operator/= (VECVU const& target, double number) noexcept { for (integer i = 1; i <= target.size; i ++) target [i] /= number; }
# 41 "../melder/VEC.h"
inline void operator<<= (VECVU const& target, constVECVU const& x) { ((target.size == x.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 41, "target.size == x.size"), abort ())); for (integer i = 1; i <= target.size; i ++) target [i] = x [i]; } inline void operator+= (VECVU const& target, constVECVU const& x) { ((target.size == x.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 41, "target.size == x.size"), abort ())); for (integer i = 1; i <= target.size; i ++) target [i] += x [i]; } inline void operator-= (VECVU const& target, constVECVU const& x) { ((target.size == x.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 41, "target.size == x.size"), abort ())); for (integer i = 1; i <= target.size; i ++) target [i] -= x [i]; } inline void operator*= (VECVU const& target, constVECVU const& x) { ((target.size == x.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 41, "target.size == x.size"), abort ())); for (integer i = 1; i <= target.size; i ++) target [i] *= x [i]; } inline void operator/= (VECVU const& target, constVECVU const& x) { ((target.size == x.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 41, "target.size == x.size"), abort ())); for (integer i = 1; i <= target.size; i ++) target [i] /= x [i]; }


struct TypeVECadd_VEC_NUM { constVECVU const& x; double number; };
inline TypeVECadd_VEC_NUM operator+ (constVECVU const& x, double number) { return { x, number }; }






inline void operator<<= (VECVU const& target, TypeVECadd_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 52, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] = expr.x [i] + expr.number; } inline void operator+= (VECVU const& target, TypeVECadd_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 52, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] += expr.x [i] + expr.number; } inline void operator-= (VECVU const& target, TypeVECadd_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 52, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] -= expr.x [i] + expr.number; } inline void operator*= (VECVU const& target, TypeVECadd_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 52, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] *= expr.x [i] + expr.number; } inline void operator/= (VECVU const& target, TypeVECadd_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 52, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] /= expr.x [i] + expr.number; }

inline autoVEC newVECadd (constVECVU const& x, double number) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= x + number;
 return result;
}

struct TypeVECsubtract_VEC_NUM { constVECVU const& x; double number; };
inline TypeVECsubtract_VEC_NUM operator- (constVECVU const& x, double number) { return { x, number }; }






inline void operator<<= (VECVU const& target, TypeVECsubtract_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 68, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] = expr.x [i] - expr.number; } inline void operator+= (VECVU const& target, TypeVECsubtract_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 68, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] += expr.x [i] - expr.number; } inline void operator-= (VECVU const& target, TypeVECsubtract_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 68, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] -= expr.x [i] - expr.number; } inline void operator*= (VECVU const& target, TypeVECsubtract_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 68, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] *= expr.x [i] - expr.number; } inline void operator/= (VECVU const& target, TypeVECsubtract_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 68, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] /= expr.x [i] - expr.number; }

inline autoVEC newVECsubtract (constVECVU const& x, double number) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= x - number;
 return result;
}

struct TypeVECmultiply_VEC_NUM { constVECVU const& x; double number; };
inline TypeVECmultiply_VEC_NUM operator* (constVECVU const& x, double number) { return { x, number }; }






inline void operator<<= (VECVU const& target, TypeVECmultiply_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 84, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] = expr.x [i] * expr.number; } inline void operator+= (VECVU const& target, TypeVECmultiply_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 84, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] += expr.x [i] * expr.number; } inline void operator-= (VECVU const& target, TypeVECmultiply_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 84, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] -= expr.x [i] * expr.number; } inline void operator*= (VECVU const& target, TypeVECmultiply_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 84, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] *= expr.x [i] * expr.number; } inline void operator/= (VECVU const& target, TypeVECmultiply_VEC_NUM const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 84, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] /= expr.x [i] * expr.number; }

inline autoVEC newVECmultiply (constVECVU const& x, double factor) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= x * factor;
 return result;
}

struct TypeVECadd_NUM_VEC { double number; constVECVU const& x; };
inline TypeVECadd_NUM_VEC operator+ (double number, constVECVU const& x) { return { number, x }; }






inline void operator<<= (VECVU const& target, TypeVECadd_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 100, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] = expr.number + expr.x [i]; } inline void operator+= (VECVU const& target, TypeVECadd_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 100, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] += expr.number + expr.x [i]; } inline void operator-= (VECVU const& target, TypeVECadd_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 100, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] -= expr.number + expr.x [i]; } inline void operator*= (VECVU const& target, TypeVECadd_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 100, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] *= expr.number + expr.x [i]; } inline void operator/= (VECVU const& target, TypeVECadd_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 100, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] /= expr.number + expr.x [i]; }

inline autoVEC newVECadd (double number, constVECVU const& x) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= number + x;
 return result;
}

struct TypeVECsubtract_NUM_VEC { double number; constVECVU const& x; };
inline TypeVECsubtract_NUM_VEC operator- (double number, constVECVU const& x) { return { number, x }; }






inline void operator<<= (VECVU const& target, TypeVECsubtract_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 116, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] = expr.number - expr.x [i]; } inline void operator+= (VECVU const& target, TypeVECsubtract_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 116, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] += expr.number - expr.x [i]; } inline void operator-= (VECVU const& target, TypeVECsubtract_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 116, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] -= expr.number - expr.x [i]; } inline void operator*= (VECVU const& target, TypeVECsubtract_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 116, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] *= expr.number - expr.x [i]; } inline void operator/= (VECVU const& target, TypeVECsubtract_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 116, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] /= expr.number - expr.x [i]; }

inline autoVEC newVECsubtract (double number, constVECVU const& x) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= number - x;
 return result;
}

struct TypeVECmultiply_NUM_VEC { double number; constVECVU const& x; };
inline TypeVECmultiply_NUM_VEC operator* (double number, constVECVU const& x) { return { number, x }; }






inline void operator<<= (VECVU const& target, TypeVECmultiply_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 132, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] = expr.number * expr.x [i]; } inline void operator+= (VECVU const& target, TypeVECmultiply_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 132, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] += expr.number * expr.x [i]; } inline void operator-= (VECVU const& target, TypeVECmultiply_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 132, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] -= expr.number * expr.x [i]; } inline void operator*= (VECVU const& target, TypeVECmultiply_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 132, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] *= expr.number * expr.x [i]; } inline void operator/= (VECVU const& target, TypeVECmultiply_NUM_VEC const& expr) noexcept { ((expr.x.size == target.size) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 132, "expr.x.size == target.size"), abort ())); for (integer i = 1; i <= expr.x.size; i ++) target [i] /= expr.number * expr.x [i]; }

inline autoVEC newVECmultiply (double number, constVECVU const& x) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= number * x;
 return result;
}

struct TypeVECadd_VEC_VEC { constVECVU const& x; constVECVU const& y; };
inline TypeVECadd_VEC_VEC operator+ (constVECVU const& x, constVECVU const& y) { return { x, y }; }
# 150 "../melder/VEC.h"
inline void operator<<= (const VECVU& target, TypeVECadd_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] = expr.x [i] + expr.y [i]; } inline void operator+= (const VECVU& target, TypeVECadd_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] += expr.x [i] + expr.y [i]; } inline void operator-= (const VECVU& target, TypeVECadd_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] -= expr.x [i] + expr.y [i]; } inline void operator*= (const VECVU& target, TypeVECadd_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] *= expr.x [i] + expr.y [i]; } inline void operator/= (const VECVU& target, TypeVECadd_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 150, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] /= expr.x [i] + expr.y [i]; }

inline autoVEC newVECadd (constVECVU const& x, constVECVU const& y) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= x + y;
 return result;
}

struct TypeVECsubtract_VEC_VEC { constVECVU const& x; constVECVU const& y; };
inline TypeVECsubtract_VEC_VEC operator- (constVECVU const& x, constVECVU const& y) { return { x, y }; }
# 168 "../melder/VEC.h"
inline void operator<<= (const VECVU& target, TypeVECsubtract_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] = expr.x [i] - expr.y [i]; } inline void operator+= (const VECVU& target, TypeVECsubtract_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] += expr.x [i] - expr.y [i]; } inline void operator-= (const VECVU& target, TypeVECsubtract_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] -= expr.x [i] - expr.y [i]; } inline void operator*= (const VECVU& target, TypeVECsubtract_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] *= expr.x [i] - expr.y [i]; } inline void operator/= (const VECVU& target, TypeVECsubtract_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 168, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] /= expr.x [i] - expr.y [i]; }

inline autoVEC newVECsubtract (constVECVU const& x, constVECVU const& y) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= x - y;
 return result;
}

struct TypeVECmultiply_VEC_VEC { constVECVU const& x; constVECVU const& y; };
inline TypeVECmultiply_VEC_VEC operator* (constVECVU const& x, constVECVU const& y) { return { x, y }; }
# 186 "../melder/VEC.h"
inline void operator<<= (const VECVU& target, TypeVECmultiply_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] = expr.x [i] * expr.y [i]; } inline void operator+= (const VECVU& target, TypeVECmultiply_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] += expr.x [i] * expr.y [i]; } inline void operator-= (const VECVU& target, TypeVECmultiply_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] -= expr.x [i] * expr.y [i]; } inline void operator*= (const VECVU& target, TypeVECmultiply_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] *= expr.x [i] * expr.y [i]; } inline void operator/= (const VECVU& target, TypeVECmultiply_VEC_VEC expr) noexcept { integer n = target.size; ((expr.x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.x.size == n"), abort ())); ((expr.y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 186, "expr.y.size == n"), abort ())); for (integer i = 1; i <= n; i ++) target [i] /= expr.x [i] * expr.y [i]; }

inline autoVEC newVECmultiply (constVECVU const& x, constVECVU const& y) {
 autoVEC result = newVECraw (x.size);
 result.all() <<= x * y;
 return result;
}

extern void VECadd_macfast_ (const VECVU& target, const constVECVU& x, const constVECVU& y) noexcept;
inline void VECadd (const VECVU& target, const constVECVU& x, const constVECVU& y) noexcept {
 integer n = target.size;
 ((x.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 197, "x.size == n"), abort ()));
 ((y.size == n) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 198, "y.size == n"), abort ()));




 for (integer i = 1; i <= n; i ++)
  target [i] = x [i] + y [i];
}

inline void VECcentre_inplace (VECVU const& x, double *out_mean = nullptr) noexcept {
 double xmean = NUMmean (x);
 for (integer i = 1; i <= x.size; i ++)
  x [i] -= xmean;
 if (out_mean)
  *out_mean = xmean;
}

inline autoVEC newVECcolumn (constMATVU const& source, integer columnNumber) {
 autoVEC target = newVECraw (source.nrow);
 target.all() <<= source.column (columnNumber);
 return target;
}

inline void VECcolumnMeans (VECVU const& target, constMATVU const& x) noexcept {
 ((target.size == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 222, "target.size == x.ncol"), abort ()));
 for (integer icol = 1; icol <= x.ncol; icol ++)
  target [icol] = NUMmean (x.column (icol));
}
inline autoVEC newVECcolumnMeans (constMATVU const& x) {
 autoVEC result = newVECraw (x.ncol);
 VECcolumnMeans (result.get(), x);
 return result;
}

extern void VECmul (VECVU const& target, constVECVU const& vec, constMATVU const& mat) noexcept;
extern void VECmul (VECVU const& target, constMATVU const& mat, constVECVU const& vec) noexcept;
extern autoVEC newVECmul (constVECVU const& vec, constMATVU const& mat);
extern autoVEC newVECmul (constMATVU const& mat, constVECVU const& vec);

extern void VECpower (VECVU const& target, constVECVU const& vec, double power);
inline autoVEC newVECpower (constVECVU const& vec, double power) {
 autoVEC result = newVECraw (vec.size);
 VECpower (result.all(), vec, power);
 return result;
}

inline void VECrandomGauss (VECVU const& target, double mu, double sigma) noexcept {
 for (integer i = 1; i <= target.size; i ++)
  target [i] = NUMrandomGauss (mu, sigma);
}
inline autoVEC newVECrandomGauss (integer size, double mu, double sigma) {
 autoVEC result = newVECraw (size);
 VECrandomGauss (result.all(), mu, sigma);
 return result;
}
inline autoVEC newVECrandomGauss (constVECVU const& model, double mu, double sigma) {
 autoVEC result = newVECraw (model.size);
 VECrandomGauss (result.all(), mu, sigma);
 return result;
}

inline void VECrandomUniform (VECVU const& target, double lowest, double highest) noexcept {
 for (integer i = 1; i <= target.size; i ++)
  target [i] = NUMrandomUniform (lowest, highest);
}
inline autoVEC newVECrandomUniform (integer size, double lowest, double highest) {
 autoVEC result = newVECraw (size);
 VECrandomUniform (result.all(), lowest, highest);
 return result;
}
inline autoVEC newVECrandomUniform (constVECVU const& model, double lowest, double highest) {
 autoVEC result = newVECraw (model.size);
 VECrandomUniform (result.all(), lowest, highest);
 return result;
}

inline void VECrowInners (VECVU const& target, constMATVU const& x, constMATVU const& y) {
 ((y.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 275, "y.nrow == x.nrow"), abort ()));
 ((y.ncol == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 276, "y.ncol == x.ncol"), abort ()));
 ((target.size == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/VEC.h", 277, "target.size == x.nrow"), abort ()));
 for (integer irow = 1; irow <= target.size; irow ++)
  target [irow] = NUMinner (x.row (irow), y.row (irow));
}
inline autoVEC newVECrowInners (constMATVU const& x, constMATVU const& y) {
 autoVEC result = newVECraw (x.nrow);
 VECrowInners (result.all(), x, y);
 return result;
}

inline void VECsin_inplace (VECVU const& vec) noexcept {
 for (integer i = 1; i <= vec.size; i ++)
  vec [i] = sin (vec [i]);
}

extern void VECsort_inplace (VECVU const& x) noexcept;
extern void INTVECsort_inplace (INTVECVU const& x) noexcept;

inline autoVEC newVECsort (constVECVU const& x) {
 autoVEC result = newVECcopy (x);
 VECsort_inplace (result.get());
 return result;
}

inline autoINTVEC newINTVECsort (constINTVECVU const& x) {
 autoINTVEC result = newINTVECcopy (x);
 INTVECsort_inplace (result.get());
 return result;
}

inline autoVEC newVECrowSums (constMATVU const& x) {
 autoVEC result = newVECraw (x.nrow);
 for (integer irow = 1; irow <= x.nrow; irow ++)
  result [irow] = NUMsum (x.row (irow));
 return result;
}

inline autoVEC newVECcolumnSums (constMATVU const& x) {
 autoVEC result = newVECraw (x.ncol);
 for (integer icol = 1; icol <= x.ncol; icol ++)
  result [icol] = NUMsum (x.column (icol));
 return result;
}

extern autoVEC newVECfrom_to (double from, double to);
extern autoVEC newVECfrom_to_by (double from, double to, double by);
extern autoVEC newVECbetween_by (double from, double to, double by);
extern autoVEC newVECto (double to);
# 155 "../melder/melder.h" 2
# 1 "../melder/MAT.h" 1
       
# 32 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, double number) noexcept { integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] = number; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] = number; } inline void operator+= (MATVU const& target, double number) noexcept { integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] += number; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] += number; } inline void operator-= (MATVU const& target, double number) noexcept { integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] -= number; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] -= number; } inline void operator*= (MATVU const& target, double number) noexcept { integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] *= number; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] *= number; } inline void operator/= (MATVU const& target, double number) noexcept { integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] /= number; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] /= number; }
# 49 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, constMATVU const& x) { ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.nrow == x.nrow"), abort ())); ((target.ncol == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.ncol == x.ncol"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] = x [irow] [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] = x [irow] [icol]; } inline void operator+= (MATVU const& target, constMATVU const& x) { ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.nrow == x.nrow"), abort ())); ((target.ncol == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.ncol == x.ncol"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] += x [irow] [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] += x [irow] [icol]; } inline void operator-= (MATVU const& target, constMATVU const& x) { ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.nrow == x.nrow"), abort ())); ((target.ncol == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.ncol == x.ncol"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] -= x [irow] [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] -= x [irow] [icol]; } inline void operator*= (MATVU const& target, constMATVU const& x) { ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.nrow == x.nrow"), abort ())); ((target.ncol == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.ncol == x.ncol"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] *= x [irow] [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] *= x [irow] [icol]; } inline void operator/= (MATVU const& target, constMATVU const& x) { ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.nrow == x.nrow"), abort ())); ((target.ncol == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 49, "target.ncol == x.ncol"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] /= x [irow] [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] /= x [irow] [icol]; }
# 65 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, constVECVU const& x) { ((target.ncol == x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 65, "target.ncol == x.size"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] = x [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] = x [icol]; } inline void operator+= (MATVU const& target, constVECVU const& x) { ((target.ncol == x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 65, "target.ncol == x.size"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] += x [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] += x [icol]; } inline void operator-= (MATVU const& target, constVECVU const& x) { ((target.ncol == x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 65, "target.ncol == x.size"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] -= x [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] -= x [icol]; } inline void operator*= (MATVU const& target, constVECVU const& x) { ((target.ncol == x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 65, "target.ncol == x.size"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] *= x [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] *= x [icol]; } inline void operator/= (MATVU const& target, constVECVU const& x) { ((target.ncol == x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 65, "target.ncol == x.size"), abort ())); integer mindim = ( target.rowStride < target.colStride ? 1 : 2 ); if (mindim == 1) for (integer icol = 1; icol <= target.ncol; icol ++) for (integer irow = 1; irow <= target.nrow; irow ++) target [irow] [icol] /= x [icol]; else for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] /= x [icol]; }


struct TypeMATadd_MAT_NUM { constMATVU const& x; double number; };
inline TypeMATadd_MAT_NUM operator+ (constMATVU const& x, double number) { return { x, number }; }
inline TypeMATadd_MAT_NUM operator+ (double number, constMATVU const& x) { return { x, number }; }
# 79 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATadd_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] + expr.number; } inline void operator+= (MATVU const& target, TypeMATadd_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] + expr.number; } inline void operator-= (MATVU const& target, TypeMATadd_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] + expr.number; } inline void operator*= (MATVU const& target, TypeMATadd_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] + expr.number; } inline void operator/= (MATVU const& target, TypeMATadd_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 79, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] + expr.number; }

inline autoMAT newMATadd (constMATVU const& x, double number) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x + number;
 return result;
}

struct TypeMATmultiply_MAT_NUM { constMATVU const& x; double number; };
inline TypeMATmultiply_MAT_NUM operator* (constMATVU const& x, double number) { return { x, number }; }
inline TypeMATmultiply_MAT_NUM operator* (double number, constMATVU const& x) { return { x, number }; }
# 98 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATmultiply_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] * expr.number; } inline void operator+= (MATVU const& target, TypeMATmultiply_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] * expr.number; } inline void operator-= (MATVU const& target, TypeMATmultiply_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] * expr.number; } inline void operator*= (MATVU const& target, TypeMATmultiply_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] * expr.number; } inline void operator/= (MATVU const& target, TypeMATmultiply_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 98, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] * expr.number; }

inline autoMAT newMATmultiply (constMATVU const& x, double number) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x * number;
 return result;
}

struct TypeMATsubtract_MAT_NUM { constMATVU const& x; double number; };
inline TypeMATsubtract_MAT_NUM operator- (constMATVU const& x, double number) { return { x, number }; }
# 116 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATsubtract_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] - expr.number; } inline void operator+= (MATVU const& target, TypeMATsubtract_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] - expr.number; } inline void operator-= (MATVU const& target, TypeMATsubtract_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] - expr.number; } inline void operator*= (MATVU const& target, TypeMATsubtract_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] - expr.number; } inline void operator/= (MATVU const& target, TypeMATsubtract_MAT_NUM const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 116, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] - expr.number; }

inline autoMAT newMATsubtract (constMATVU const& x, double number) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x - number;
 return result;
}

struct TypeMATsubtract_NUM_MAT { double number; constMATVU const& x; };
inline TypeMATsubtract_NUM_MAT operator- (double number, constMATVU const& x) { return { number, x }; }
# 134 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATsubtract_NUM_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.number - expr.x [irow] [icol]; } inline void operator+= (MATVU const& target, TypeMATsubtract_NUM_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.number - expr.x [irow] [icol]; } inline void operator-= (MATVU const& target, TypeMATsubtract_NUM_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.number - expr.x [irow] [icol]; } inline void operator*= (MATVU const& target, TypeMATsubtract_NUM_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.number - expr.x [irow] [icol]; } inline void operator/= (MATVU const& target, TypeMATsubtract_NUM_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 134, "expr.x.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.number - expr.x [irow] [icol]; }

inline autoMAT newMATsubtract (double number, constMATVU const& x) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= number - x;
 return result;
}

struct TypeMATadd_MAT_VEC { constMATVU const& x; constVECVU const& y; };
inline TypeMATadd_MAT_VEC operator+ (constMATVU const& x, constVECVU const& y) { return { x, y }; }
# 153 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATadd_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] + expr.y [icol]; } inline void operator+= (MATVU const& target, TypeMATadd_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] + expr.y [icol]; } inline void operator-= (MATVU const& target, TypeMATadd_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] + expr.y [icol]; } inline void operator*= (MATVU const& target, TypeMATadd_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] + expr.y [icol]; } inline void operator/= (MATVU const& target, TypeMATadd_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 153, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] + expr.y [icol]; }

inline autoMAT newMATadd (constMATVU const& x, constVECVU const& y) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x + y;
 return result;
}

struct TypeMATmultiply_MAT_VEC { constMATVU const& x; constVECVU const& y; };
inline TypeMATmultiply_MAT_VEC operator* (constMATVU const& x, constVECVU const& y) { return { x, y }; }
# 172 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATmultiply_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] * expr.y [icol]; } inline void operator+= (MATVU const& target, TypeMATmultiply_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] * expr.y [icol]; } inline void operator-= (MATVU const& target, TypeMATmultiply_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] * expr.y [icol]; } inline void operator*= (MATVU const& target, TypeMATmultiply_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] * expr.y [icol]; } inline void operator/= (MATVU const& target, TypeMATmultiply_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 172, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] * expr.y [icol]; }

inline autoMAT newMATmultiply (constMATVU const& x, constVECVU const& y) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x * y;
 return result;
}

struct TypeMATsubtract_MAT_VEC { constMATVU const& x; constVECVU const& y; };
inline TypeMATsubtract_MAT_VEC operator- (constMATVU const& x, constVECVU const& y) { return { x, y }; }
# 191 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATsubtract_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] - expr.y [icol]; } inline void operator+= (MATVU const& target, TypeMATsubtract_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] - expr.y [icol]; } inline void operator-= (MATVU const& target, TypeMATsubtract_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] - expr.y [icol]; } inline void operator*= (MATVU const& target, TypeMATsubtract_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] - expr.y [icol]; } inline void operator/= (MATVU const& target, TypeMATsubtract_MAT_VEC const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.ncol == expr.y.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 191, "expr.x.ncol == expr.y.size"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] - expr.y [icol]; }

inline autoMAT newMATsubtract (constMATVU const& x, constVECVU const& y) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x - y;
 return result;
}

struct TypeMATadd_VEC_MAT { constVECVU const& x; constMATVU const& y; };
inline TypeMATadd_VEC_MAT operator+ (constVECVU const& x, constMATVU const& y) { return { x, y }; }
# 210 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATadd_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] = expr.x [irow] + expr.y [irow] [icol]; } inline void operator+= (MATVU const& target, TypeMATadd_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] += expr.x [irow] + expr.y [irow] [icol]; } inline void operator-= (MATVU const& target, TypeMATadd_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] -= expr.x [irow] + expr.y [irow] [icol]; } inline void operator*= (MATVU const& target, TypeMATadd_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] *= expr.x [irow] + expr.y [irow] [icol]; } inline void operator/= (MATVU const& target, TypeMATadd_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 210, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] /= expr.x [irow] + expr.y [irow] [icol]; }

inline autoMAT newMATadd (constVECVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (y.nrow, y.ncol);
 result.all() <<= x + y;
 return result;
}

struct TypeMATmultiply_VEC_MAT { constVECVU const& x; constMATVU const& y; };
inline TypeMATmultiply_VEC_MAT operator* (constVECVU const& x, constMATVU const& y) { return { x, y }; }
# 229 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATmultiply_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] = expr.x [irow] * expr.y [irow] [icol]; } inline void operator+= (MATVU const& target, TypeMATmultiply_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] += expr.x [irow] * expr.y [irow] [icol]; } inline void operator-= (MATVU const& target, TypeMATmultiply_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] -= expr.x [irow] * expr.y [irow] [icol]; } inline void operator*= (MATVU const& target, TypeMATmultiply_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] *= expr.x [irow] * expr.y [irow] [icol]; } inline void operator/= (MATVU const& target, TypeMATmultiply_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 229, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] /= expr.x [irow] * expr.y [irow] [icol]; }

inline autoMAT newMATmultiply (constVECVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (y.nrow, y.ncol);
 result.all() <<= x * y;
 return result;
}

struct TypeMATsubtract_VEC_MAT { constVECVU const& x; constMATVU const& y; };
inline TypeMATsubtract_VEC_MAT operator- (constVECVU const& x, constMATVU const& y) { return { x, y }; }
# 248 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATsubtract_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] = expr.x [irow] - expr.y [irow] [icol]; } inline void operator+= (MATVU const& target, TypeMATsubtract_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] += expr.x [irow] - expr.y [irow] [icol]; } inline void operator-= (MATVU const& target, TypeMATsubtract_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] -= expr.x [irow] - expr.y [irow] [icol]; } inline void operator*= (MATVU const& target, TypeMATsubtract_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] *= expr.x [irow] - expr.y [irow] [icol]; } inline void operator/= (MATVU const& target, TypeMATsubtract_VEC_MAT const& expr) noexcept { ((expr.y.nrow == expr.x.size) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == expr.x.size"), abort ())); ((expr.y.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.nrow == target.nrow"), abort ())); ((expr.y.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 248, "expr.y.ncol == target.ncol"), abort ())); for (integer irow = 1; irow <= target.nrow; irow ++) for (integer icol = 1; icol <= target.ncol; icol ++) target [irow] [icol] /= expr.x [irow] - expr.y [irow] [icol]; }

inline autoMAT newMATsubtract (constVECVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (y.nrow, y.ncol);
 result.all() <<= x - y;
 return result;
}

struct TypeMATadd_MAT_MAT { constMATVU const& x; constMATVU const& y; };
inline TypeMATadd_MAT_MAT operator+ (constMATVU const& x, constMATVU const& y) { return { x, y }; }
# 268 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATadd_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] + expr.y [irow] [icol]; } inline void operator+= (MATVU const& target, TypeMATadd_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] + expr.y [irow] [icol]; } inline void operator-= (MATVU const& target, TypeMATadd_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] + expr.y [irow] [icol]; } inline void operator*= (MATVU const& target, TypeMATadd_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] + expr.y [irow] [icol]; } inline void operator/= (MATVU const& target, TypeMATadd_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 268, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] + expr.y [irow] [icol]; }

inline autoMAT newMATadd (constMATVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x + y;
 return result;
}

struct TypeMATmultiply_MAT_MAT { constMATVU const& x; constMATVU const& y; };
inline TypeMATmultiply_MAT_MAT operator* (constMATVU const& x, constMATVU const& y) { return { x, y }; }
# 288 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATmultiply_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] * expr.y [irow] [icol]; } inline void operator+= (MATVU const& target, TypeMATmultiply_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] * expr.y [irow] [icol]; } inline void operator-= (MATVU const& target, TypeMATmultiply_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] * expr.y [irow] [icol]; } inline void operator*= (MATVU const& target, TypeMATmultiply_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] * expr.y [irow] [icol]; } inline void operator/= (MATVU const& target, TypeMATmultiply_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 288, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] * expr.y [irow] [icol]; }

inline autoMAT newMATmultiply (constMATVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x * y;
 return result;
}

struct TypeMATsubtract_MAT_MAT { constMATVU const& x; constMATVU const& y; };
inline TypeMATsubtract_MAT_MAT operator- (constMATVU const& x, constMATVU const& y) { return { x, y }; }
# 308 "../melder/MAT.h"
inline void operator<<= (MATVU const& target, TypeMATsubtract_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] = expr.x [irow] [icol] - expr.y [irow] [icol]; } inline void operator+= (MATVU const& target, TypeMATsubtract_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] += expr.x [irow] [icol] - expr.y [irow] [icol]; } inline void operator-= (MATVU const& target, TypeMATsubtract_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] -= expr.x [irow] [icol] - expr.y [irow] [icol]; } inline void operator*= (MATVU const& target, TypeMATsubtract_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] *= expr.x [irow] [icol] - expr.y [irow] [icol]; } inline void operator/= (MATVU const& target, TypeMATsubtract_MAT_MAT const& expr) noexcept { ((expr.x.nrow == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == target.nrow"), abort ())); ((expr.x.ncol == target.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == target.ncol"), abort ())); ((expr.x.nrow == expr.y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.nrow == expr.y.nrow"), abort ())); ((expr.x.ncol == expr.y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 308, "expr.x.ncol == expr.y.ncol"), abort ())); for (integer irow = 1; irow <= expr.x.nrow; irow ++) for (integer icol = 1; icol <= expr.x.ncol; icol ++) target [irow] [icol] /= expr.x [irow] [icol] - expr.y [irow] [icol]; }

inline autoMAT newMATsubtract (constMATVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (x.nrow, x.ncol);
 result.all() <<= x - y;
 return result;
}





extern void MATcentreEachColumn_inplace (MATVU const& x) noexcept;





extern void MATcentreEachRow_inplace (MATVU const& x) noexcept;





extern void MATdoubleCentre_inplace (MATVU const& x) noexcept;

extern void MATmtm (MATVU const& target, constMATVU const& x) noexcept;
inline autoMAT newMATmtm (constMATVU const& x) {
 autoMAT result = newMATraw (x.ncol, x.ncol);
 MATmtm (result.get(), x);
 return result;
}




extern void MATmul_ (MATVU const& target, constMATVU const& x, constMATVU const& y) noexcept;
inline void MATmul (MATVU const& target, constMATVU const& x, constMATVU const& y) noexcept {
 ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 346, "target.nrow == x.nrow"), abort ()));
 ((target.ncol == y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 347, "target.ncol == y.ncol"), abort ()));
 ((x.ncol == y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 348, "x.ncol == y.nrow"), abort ()));
 MATmul_ (target, x, y);
}
inline autoMAT newMATmul (constMATVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (x.nrow, y.ncol);
 MATmul (result.all(), x, y);
 return result;
}






extern void MATmul_forceAllocation_ (MATVU const& target, constMATVU x, constMATVU y);
inline void MATmul_forceAllocation (MATVU const& target, constMATVU x, constMATVU y) {
 ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 364, "target.nrow == x.nrow"), abort ()));
 ((target.ncol == y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 365, "target.ncol == y.ncol"), abort ()));
 ((x.ncol == y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 366, "x.ncol == y.nrow"), abort ()));
 MATmul_forceAllocation_ (target, x, y);
}
inline autoMAT newMATmul_forceAllocation (constMATVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (x.nrow, y.ncol);
 MATmul_forceAllocation (result.all(), x, y);
 return result;
}




extern void MATmul_allowAllocation_ (MATVU const& target, constMATVU x, constMATVU y);
inline void MATmul_allowAllocation (MATVU const& target, constMATVU x, constMATVU y) {
 ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 380, "target.nrow == x.nrow"), abort ()));
 ((target.ncol == y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 381, "target.ncol == y.ncol"), abort ()));
 ((x.ncol == y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 382, "x.ncol == y.nrow"), abort ()));
 MATmul_allowAllocation_ (target, x, y);
}
inline autoMAT newMATmul_allowAllocation (constMATVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (x.nrow, y.ncol);
 MATmul_allowAllocation (result.all(), x, y);
 return result;
}



extern void MATmul_fast_ (MATVU const& target, constMATVU const& x, constMATVU const& y) noexcept;
inline void MATmul_fast (MATVU const& target, constMATVU const& x, constMATVU const& y) noexcept {
 ((target.nrow == x.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 395, "target.nrow == x.nrow"), abort ()));
 ((target.ncol == y.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 396, "target.ncol == y.ncol"), abort ()));
 ((x.ncol == y.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 397, "x.ncol == y.nrow"), abort ()));
 MATmul_fast_ (target, x, y);
}
inline autoMAT newMATmul_fast (constMATVU const& x, constMATVU const& y) {
 autoMAT result = newMATraw (x.nrow, y.ncol);
 MATmul_fast (result.all(), x, y);
 return result;
}
void MATmul_forceMetal_ (MATVU const& target, constMATVU const& x, constMATVU const& y);
void MATmul_forceOpenCL_ (MATVU const& target, constMATVU const& x, constMATVU const& y);

void MATouter (MATVU const& target, constVECVU const& x, constVECVU const& y);
extern autoMAT newMATouter (constVECVU const& x, constVECVU const& y);

extern autoMAT newMATpeaks (constVECVU const& x, bool includeEdges, int interpolate, bool sortByHeight);

void MATpower (MATVU const& target, constMATVU const& mat, double power);
inline autoMAT newMATpower (constMATVU const& mat, double power) {
 autoMAT result = newMATraw (mat.nrow, mat.ncol);
 MATpower (result.all(), mat, power);
 return result;
}

inline void MATrandomGauss (MATVU const& target, double mu, double sigma) noexcept {
 for (integer irow = 1; irow <= target.nrow; irow ++)
  for (integer icol = 1; icol <= target.ncol; icol ++)
   target [irow] [icol] = NUMrandomGauss (mu, sigma);
}
inline autoMAT newMATrandomGauss (integer nrow, integer ncol, double mu, double sigma) {
 autoMAT result = newMATraw (nrow, ncol);
 MATrandomGauss (result.all(), mu, sigma);
 return result;
}
inline autoMAT newMATrandomGauss (constMATVU const& model, double mu, double sigma) {
 autoMAT result = newMATraw (model.nrow, model.ncol);
 MATrandomGauss (result.all(), mu, sigma);
 return result;
}

inline void MATrandomUniform (MATVU const& target, double lowest, double highest) noexcept {
 for (integer irow = 1; irow <= target.nrow; irow ++)
  for (integer icol = 1; icol <= target.ncol; icol ++)
   target [irow] [icol] = NUMrandomUniform (lowest, highest);
}
inline autoMAT newMATrandomUniform (integer nrow, integer ncol, double lowest, double highest) {
 autoMAT result = newMATraw (nrow, ncol);
 MATrandomUniform (result.all(), lowest, highest);
 return result;
}
inline autoMAT newMATrandomUniform (constMATVU const& model, double lowest, double highest) {
 autoMAT result = newMATraw (model.nrow, model.ncol);
 MATrandomUniform (result.all(), lowest, highest);
 return result;
}

inline void MATsin_inplace (MATVU const& mat) noexcept {
 for (integer irow = 1; irow <= mat.nrow; irow ++)
  for (integer icol = 1; icol <= mat.ncol; icol ++)
   mat [irow] [icol] = sin (mat [irow] [icol]);
}

inline void MATsubtractReversed_inplace (MATVU const& x, double number) noexcept {
 for (integer irow = 1; irow <= x.nrow; irow ++)
  for (integer icol = 1; icol <= x.ncol; icol ++)
   x [irow] [icol] = number - x [irow] [icol];
}
inline void MATsubtractReversed_inplace (MATVU const& x, constMATVU const& y) noexcept {
 ((y.nrow == x.nrow && y.ncol == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 464, "y.nrow == x.nrow && y.ncol == x.ncol"), abort ()));
 for (integer irow = 1; irow <= x.nrow; irow ++)
  for (integer icol = 1; icol <= x.ncol; icol ++)
   x [irow] [icol] = y [irow] [icol] - x [irow] [icol];
}

inline void MATtranspose_inplace_mustBeSquare (MATVU const& x) noexcept {
 ((x.nrow == x.ncol) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 471, "x.nrow == x.ncol"), abort ()));
 integer n = x.nrow;
 for (integer i = 1; i < n; i ++)
  for (integer j = i + 1; j <= n; j ++)
   std::swap (x [i] [j], x [j] [i]);
}
inline void MATtranspose (MATVU const& target, constMATVU const& x) noexcept {
 ((x.nrow == target.ncol && x.ncol == target.nrow) ? (void) (0) : (Melder_assert_ ("../melder/MAT.h", 478, "x.nrow == target.ncol && x.ncol == target.nrow"), abort ()));
 for (integer irow = 1; irow <= target.nrow; irow ++)
  for (integer icol = 1; icol <= target.ncol; icol ++)
   target [irow] [icol] = x [icol] [irow];
}
inline autoMAT newMATtranspose (constMATVU const& x) {
 autoMAT result = newMATraw (x.ncol, x.nrow);
 MATtranspose (result.get(), x);
 return result;
}
# 156 "../melder/melder.h" 2
# 1 "../melder/STRVEC.h" 1
       
# 20 "../melder/STRVEC.h"
inline STRVEC STRVECfromTo (STRVEC strvec, integer fromIndex, integer toIndex) {
 integer offsetIndex = fromIndex - 1;
 ((offsetIndex >= 0) ? (void) (0) : (Melder_assert_ ("../melder/STRVEC.h", 22, "offsetIndex >= 0"), abort ()));
 ((toIndex <= strvec.size) ? (void) (0) : (Melder_assert_ ("../melder/STRVEC.h", 23, "toIndex <= strvec.size"), abort ()));
 integer rangeSize = toIndex - offsetIndex;
 if (rangeSize <= 0)
  return STRVEC();
 return STRVEC (& strvec [fromIndex], toIndex - offsetIndex);
}

inline constSTRVEC STRVECfromTo (constSTRVEC strvec, integer fromIndex, integer toIndex) {
 integer offsetIndex = fromIndex - 1;
 ((offsetIndex >= 0) ? (void) (0) : (Melder_assert_ ("../melder/STRVEC.h", 32, "offsetIndex >= 0"), abort ()));
 ((toIndex <= strvec.size) ? (void) (0) : (Melder_assert_ ("../melder/STRVEC.h", 33, "toIndex <= strvec.size"), abort ()));
 integer rangeSize = toIndex - offsetIndex;
 if (rangeSize <= 0)
  return constSTRVEC();
 return constSTRVEC (& strvec [fromIndex], rangeSize);
}

void STRVECsort_inplace (STRVEC const& a);






autoSTRVEC newSTRVECtokenize (conststring32 string);
# 157 "../melder/melder.h" 2
# 25 "../sys/Thing.h" 2

# 1 "../sys/oo.h" 1
# 27 "../sys/Thing.h" 2



typedef struct structClassInfo *ClassInfo;
struct structClassInfo {



 conststring32 className;
 ClassInfo semanticParent;
 integer size;
 Thing (* _new) ();
 integer version;



 integer sequentialUniqueIdOfReadableClass;



 Thing dummyObject;
};
# 70 "../sys/Thing.h"
typedef struct structThing *Thing;
extern ClassInfo classThing;
extern struct structClassInfo theClassInfo_Thing;
struct structThing {
 ClassInfo classInfo;
 autostring32 name;
 void * operator new (size_t size) { return (char *) _Melder_calloc ((int64) size, sizeof (char)); }
 void operator delete (void *ptr, size_t ) { _Melder_free ((void **) & (ptr)); }
# 86 "../sys/Thing.h"
 virtual ~structThing () noexcept { }

 virtual void v_destroy () noexcept { };



 virtual void v_info ();







 virtual void v_checkConstraints () { };



 virtual void v_nameChanged () { };



 virtual void v_copyPreferencesToInstance () { };



};
# 129 "../sys/Thing.h"
conststring32 Thing_className (Thing me);


bool Thing_isa (Thing me, ClassInfo klas);






bool Thing_isSubclass (ClassInfo klas, ClassInfo ancestor);






void Thing_info (Thing me);
void Thing_infoWithIdAndFile (Thing me, integer id, MelderFile file);

void Thing_recognizeClassesByName (ClassInfo readableClass, ...);
# 167 "../sys/Thing.h"
void Thing_recognizeClassByOtherName (ClassInfo readableClass, conststring32 otherName);
integer Thing_listReadableClasses ();

ClassInfo Thing_classFromClassName (conststring32 className, int *formatVersion);
# 183 "../sys/Thing.h"
Thing _Thing_dummyObject (ClassInfo classInfo);

conststring32 Thing_getName (Thing me);

conststring32 Thing_messageName (Thing me);

void Thing_setName (Thing me, conststring32 name );
# 201 "../sys/Thing.h"
void Thing_swap (Thing me, Thing thee);
# 216 "../sys/Thing.h"
void _Thing_forget (Thing me);
void _Thing_forget_nozero (Thing me);



extern integer theTotalNumberOfThings;


template <class T>
class autoSomeThing {
 T *ptr;
public:





 autoSomeThing () : ptr (nullptr) {



 }
 autoSomeThing (ClassInfo classInfo) {
  this -> ptr = classInfo -> _new ();
 }






 ~autoSomeThing () noexcept {




  if (this -> ptr) {
   _Thing_forget (this -> ptr);
   this -> ptr = nullptr;
  }
 }
 T* get () const noexcept {
  return this -> ptr;
 }
# 271 "../sys/Thing.h"
 T* operator-> () const noexcept {
  return this -> ptr;
 }
# 294 "../sys/Thing.h"
 void releaseToUser () noexcept {
  this -> ptr = nullptr;
 }







 void adoptFromAmbiguousOwner (T* newPtr) noexcept {
  this -> reset();
  this -> ptr = newPtr;
 }
 T* releaseToAmbiguousOwner () noexcept {
  T* temp = this -> ptr;
  this -> ptr = nullptr;
  return temp;
 }
 void reset () noexcept {
  _Thing_forget (this -> ptr);
  this -> ptr = nullptr;
 }
 void _zero () noexcept {
  this -> ptr = nullptr;
 }
 explicit operator bool () const noexcept {
  return !! this -> ptr;
 }
 bool operator== (autoSomeThing<T> other) const noexcept {
  return other. ptr == this -> ptr;
 }
 bool operator!= (autoSomeThing<T> other) const noexcept {
  return other. ptr != this -> ptr;
 }
# 339 "../sys/Thing.h"
 autoSomeThing<T> (const autoSomeThing<T>&) = delete;
 template <class Y> autoSomeThing<T> (const autoSomeThing<Y>&) = delete;
# 351 "../sys/Thing.h"
 autoSomeThing<T>& operator= (const autoSomeThing<T>&) = delete;
 template <class Y> autoSomeThing<T>& operator= (const autoSomeThing<Y>&) = delete;






 autoSomeThing<T> (autoSomeThing<T>&& other) noexcept : ptr (other. ptr) {





  other. ptr = nullptr;
 }
 template <class Y> autoSomeThing<T> (autoSomeThing<Y>&& other) noexcept : ptr (other.get()) {





  other. _zero();
 }







 autoSomeThing<T>& operator= (autoSomeThing<T>&& other) noexcept {
  if (other. ptr != this -> ptr) {




   if (this -> ptr) _Thing_forget (this -> ptr);
   this -> ptr = other. ptr;




   other. ptr = nullptr;
  }
  return *this;
 }
 template <class Y> autoSomeThing<T>& operator= (autoSomeThing<Y>&& other) noexcept {
  if (other.get() != this -> ptr) {




   if (this -> ptr) _Thing_forget (this -> ptr);
   this -> ptr = other.get();




   other. _zero();
  }
  return *this;
 }






 autoSomeThing<T>&& move () noexcept { return static_cast <autoSomeThing<T>&&> (*this); }
# 448 "../sys/Thing.h"
 template <class Y> autoSomeThing<Y> static_cast_move () noexcept {
  T* nakedPointer_oldType = this -> releaseToAmbiguousOwner();
  Y* nakedPointer_newType = static_cast<Y*> (nakedPointer_oldType);
  autoSomeThing<Y> newObject;
  newObject. adoptFromAmbiguousOwner (nakedPointer_newType);
  return newObject;
 }
};

typedef autoSomeThing<structThing> autoThing;
# 468 "../sys/Thing.h"
autoThing Thing_newFromClass (ClassInfo klas);
# 477 "../sys/Thing.h"
autoThing Thing_newFromClassName (conststring32 className, int *out_formatVersion);
# 24 "../sys/Data.h" 2

typedef struct structData_Description {
 conststring32 name;
 int type;
 int offset;
 int size;
 conststring32 tagName;
 void *tagType;
 int rank;
 conststring32 min1, max1;
 conststring32 min2, max2;
} *Data_Description;






typedef struct structDaata *Daata; typedef autoSomeThing <structDaata> autoDaata; extern struct structClassInfo theClassInfo_Daata; extern ClassInfo classDaata; typedef structThing Daata_Parent; struct structDaata : public structThing {
 virtual void v_copy (Daata data_to);
 virtual bool v_equal (Daata otherData);
 virtual Data_Description v_description () { return nullptr; }
 virtual bool v_writable () { return true; }
 virtual bool v_canWriteAsEncoding (int outputEncoding);
 virtual void v_writeText (MelderFile openFile);
 virtual void v_readText (MelderReadText text, int formatVersion);
 virtual void v_writeBinary (FILE *f);
 virtual void v_readBinary (FILE *f, int formatVersion);
 virtual void v_repair () { }

 virtual bool v_hasGetNrow () { return false; } virtual double v_getNrow () { return undefined; }
 virtual bool v_hasGetNcol () { return false; } virtual double v_getNcol () { return undefined; }
 virtual bool v_hasGetXmin () { return false; } virtual double v_getXmin () { return undefined; }
 virtual bool v_hasGetXmax () { return false; } virtual double v_getXmax () { return undefined; }
 virtual bool v_hasGetYmin () { return false; } virtual double v_getYmin () { return undefined; }
 virtual bool v_hasGetYmax () { return false; } virtual double v_getYmax () { return undefined; }
 virtual bool v_hasGetNx () { return false; } virtual double v_getNx () { return undefined; }
 virtual bool v_hasGetNy () { return false; } virtual double v_getNy () { return undefined; }
 virtual bool v_hasGetDx () { return false; } virtual double v_getDx () { return undefined; }
 virtual bool v_hasGetDy () { return false; } virtual double v_getDy () { return undefined; }
 virtual bool v_hasGetX () { return false; } virtual double v_getX (integer ) { return undefined; }
 virtual bool v_hasGetY () { return false; } virtual double v_getY (integer ) { return undefined; }
 virtual bool v_hasGetRowStr () { return false; } virtual conststring32 v_getRowStr (integer ) { return nullptr; }
 virtual bool v_hasGetColStr () { return false; } virtual conststring32 v_getColStr (integer ) { return nullptr; }
 virtual bool v_hasGetCell () { return false; } virtual double v_getCell () { return undefined; }
 virtual bool v_hasGetCellStr () { return false; } virtual conststring32 v_getCellStr () { return nullptr; }
 virtual bool v_hasGetVector () { return false; } virtual double v_getVector (integer , integer ) { return undefined; }
 virtual bool v_hasGetVectorStr () { return false; } virtual conststring32 v_getVectorStr (integer ) { return nullptr; }
 virtual bool v_hasGetMatrix () { return false; } virtual double v_getMatrix (integer , integer ) { return undefined; }
 virtual bool v_hasGetMatrixStr () { return false; } virtual conststring32 v_getMatrixStr (integer , integer ) { return nullptr; }
 virtual bool v_hasGetFunction0 () { return false; } virtual double v_getFunction0 () { return undefined; }
 virtual bool v_hasGetFunction1 () { return false; } virtual double v_getFunction1 (integer , double ) { return undefined; }
 virtual bool v_hasGetFunction2 () { return false; } virtual double v_getFunction2 (double , double ) { return undefined; }
 virtual bool v_hasGetRowIndex () { return false; } virtual double v_getRowIndex (conststring32 ) { return undefined; }
 virtual bool v_hasGetColIndex () { return false; } virtual double v_getColIndex (conststring32 ) { return undefined; }
};

template <class T> autoSomeThing<T> Data_copy (T* data) {
 return _Data_copy (data).template static_cast_move <T> ();
}
autoDaata _Data_copy (Daata me);







bool Data_equal (Daata data1, Daata data2);
# 101 "../sys/Data.h"
typedef MelderCompareHook<structDaata> Data_CompareHook;

bool Data_canWriteAsEncoding (Daata me, int outputEncoding);






bool Data_canWriteText (Daata me);






MelderFile Data_createTextFile (
 Daata me,
 MelderFile file,
 bool verbose
);

void Data_writeText (Daata me, MelderFile openFile);
# 136 "../sys/Data.h"
void Data_writeToTextFile (Daata me, MelderFile file);
# 147 "../sys/Data.h"
void Data_writeToShortTextFile (Daata me, MelderFile file);
# 158 "../sys/Data.h"
bool Data_canWriteBinary (Daata me);






void Data_writeBinary (Daata me, FILE *f);
# 178 "../sys/Data.h"
void Data_writeToBinaryFile (Daata me, MelderFile file);
# 188 "../sys/Data.h"
bool Data_canReadText (Daata me);







void Data_readText (Daata me, MelderReadText text, int formatVersion);
# 209 "../sys/Data.h"
autoDaata Data_readFromTextFile (MelderFile file);
# 225 "../sys/Data.h"
bool Data_canReadBinary (Daata me);







void Data_readBinary (Daata me, FILE *f, int formatVersion);
# 246 "../sys/Data.h"
autoDaata Data_readFromBinaryFile (MelderFile file);
# 262 "../sys/Data.h"
using Data_FileTypeRecognizer = autoDaata (*) (integer numberOfBytesRead, const char *header, MelderFile file);

void Data_recognizeFileType (Data_FileTypeRecognizer recognizer);
# 306 "../sys/Data.h"
autoDaata Data_readFromFile (MelderFile file);
# 322 "../sys/Data.h"
extern structMelderDir Data_directoryBeingRead;

int Data_publish (autoDaata me);

void Data_setPublishProc (int (*publish) (autoDaata));
# 356 "../sys/Data.h"
int Data_Description_countMembers (Data_Description structDescription);


Data_Description Data_Description_findMatch (Data_Description structDescription, conststring32 member);



Data_Description Data_Description_findNumberUse (Data_Description structDescription, conststring32 string);




int64 Data_Description_integer (void *structAddress, Data_Description description);


int Data_Description_evaluateInteger (void *structAddress, Data_Description structDescription,
 conststring32 formula, integer *result);
# 22 "../sys/Simple.h" 2

# 1 "../sys/Simple_def.h" 1
# 20 "../sys/Simple_def.h"
typedef struct structSimpleInteger *SimpleInteger; typedef autoSomeThing <structSimpleInteger> autoSimpleInteger; typedef structDaata SimpleInteger_Parent; extern struct structClassInfo theClassInfo_SimpleInteger; extern ClassInfo classSimpleInteger; struct structSimpleInteger : public structDaata {
 integer number;
void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };



typedef struct structSimpleDouble *SimpleDouble; typedef autoSomeThing <structSimpleDouble> autoSimpleDouble; typedef structDaata SimpleDouble_Parent; extern struct structClassInfo theClassInfo_SimpleDouble; extern ClassInfo classSimpleDouble; struct structSimpleDouble : public structDaata {
 double number;
void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };



typedef struct structSimpleString *SimpleString; typedef autoSomeThing <structSimpleString> autoSimpleString; typedef structDaata SimpleString_Parent; extern struct structClassInfo theClassInfo_SimpleString; extern ClassInfo classSimpleString; struct structSimpleString : public structDaata {
 autostring32 string;
void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 24 "../sys/Simple.h" 2

autoSimpleInteger SimpleInteger_create (integer number);
autoSimpleDouble SimpleDouble_create (double number);
autoSimpleString SimpleString_create (conststring32 string);

int SimpleString_compare (SimpleString me, SimpleString thee) noexcept;
# 26 "../sys/Collection.h" 2


#pragma mark - class Collection
# 40 "../sys/Collection.h"
template <typename T> struct CollectionOf;

typedef CollectionOf<structDaata> _CollectionOfDaata;
extern void _CollectionOfDaata_v_copy (_CollectionOfDaata* me, _CollectionOfDaata* thee);
extern bool _CollectionOfDaata_v_equal (_CollectionOfDaata* me, _CollectionOfDaata* thee);
extern bool _CollectionOfDaata_v_canWriteAsEncoding (_CollectionOfDaata* me, int outputEncoding);
extern void _CollectionOfDaata_v_writeText (_CollectionOfDaata* me, MelderFile openFile);
extern void _CollectionOfDaata_v_readText (_CollectionOfDaata* me, MelderReadText text, int formatVersion);
extern void _CollectionOfDaata_v_writeBinary (_CollectionOfDaata* me, FILE *f);
extern void _CollectionOfDaata_v_readBinary (_CollectionOfDaata* me, FILE *f, int formatVersion);
extern struct structData_Description theCollectionOfDaata_v_description [3];

template <typename T >
struct ArrayOf {
 T** _elements { nullptr };
 T*& operator[] (integer i) const {
  return this -> _elements [i];
 }
};

template <typename T >
struct CollectionOf : structDaata {
 ArrayOf <T> at;
 integer size { 0 };
 integer _capacity { 0 };
 bool _ownItems { true };
 bool _ownershipInitialized { false };

 CollectionOf () {
  extern ClassInfo classCollection;
  this -> classInfo = classCollection;
  this -> name. reset();
 }
 virtual ~ CollectionOf () {
# 83 "../sys/Collection.h"
  if (this -> at._elements) {
   if (this -> _ownItems) {
    for (integer i = 1; i <= this -> size; i ++) {
     _Thing_forget (this -> at [i]);
    }
   }
   this -> at._elements ++;
   _Melder_free ((void **) & (this -> at._elements));
  }
 }



 CollectionOf<T>& operator= (const CollectionOf<T>&) = delete;
 template <class Y> CollectionOf<T>& operator= (const CollectionOf<Y>&) = delete;
 CollectionOf<T> (CollectionOf<T>&& other) noexcept :
  at (other. at),
  size (other. size),
  _capacity (other. _capacity),
  _ownItems (other. _ownItems),
  _ownershipInitialized (other. _ownershipInitialized)
 {
  other. at._elements = nullptr;
  other. size = 0;
  other. _capacity = 0;
  other. _ownItems = false;
  other. _ownershipInitialized = false;
 }
 template <class Y> CollectionOf<T> (CollectionOf<Y>&& other) noexcept :
  at (other. at),
  size (other. size),
  _capacity (other. _capacity),
  _ownItems (other. _ownItems),
  _ownershipInitialized (other. _ownershipInitialized)
 {
  other. at._elements = nullptr;
  other. size = 0;
  other. _capacity = 0;
  other. _ownItems = false;
  other. _ownershipInitialized = false;
 }
 CollectionOf<T>& operator= (CollectionOf<T>&& other) noexcept {
  if (other. at._elements != this -> at._elements) {
   if (this -> at._elements) {
    if (this -> _ownItems) {
     for (integer i = 1; i <= this -> size; i ++) {
      _Thing_forget (this -> at [i]);
     }
    }
    this -> at._elements ++;
    _Melder_free ((void **) & (this -> at._elements));
   }
  }
  this -> at = other. at;
  this -> size = other. size;
  this -> _capacity = other. _capacity;
  this -> _ownItems = other. _ownItems;
  this -> _ownershipInitialized = other. _ownershipInitialized;
  other. at._elements = nullptr;
  other. size = 0;
  other. _capacity = 0;
  other. _ownItems = false;
  other. _ownershipInitialized = false;
  return *this;
 }
 template <class Y> CollectionOf<T>& operator= (CollectionOf<Y>&& other) noexcept {
  if (other. at_elements != this -> at_elements) {
   if (this -> at._elements) {
    if (this -> _ownItems) {
     for (integer i = 1; i <= this -> size; i ++) {
      _Thing_forget (this -> at [i]);
     }
    }
    this -> at._elements ++;
    _Melder_free ((void **) & (this -> at._elements));
   }
  }
  this -> at = other. at;
  this -> size = other. size;
  this -> _capacity = other. _capacity;
  this -> _ownItems = other. _ownItems;
  this -> _ownershipInitialized = other. _ownershipInitialized;
  other. at._elements = nullptr;
  other. size = 0;
  other. _capacity = 0;
  other. _ownItems = false;
  other. _ownershipInitialized = false;
  return *this;
 }
 CollectionOf<T>&& move () noexcept { return static_cast <CollectionOf<T>&&> (*this); }

 void _initializeOwnership (bool ownItems) {
  if (this -> _ownershipInitialized) {
   ((this -> _ownItems == ownItems) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 176, "our _ownItems == ownItems"), abort ()));
  } else {
   this -> _ownItems = ownItems;
   this -> _ownershipInitialized = true;
  }
 }
 void _grow (integer newCapacity) {
  if (newCapacity <= this -> _capacity) return;
  T** oldItem_base0 = ( this -> at._elements ? this -> at._elements + 1 : nullptr );
  T** newItem_base0 = (T**) Melder_realloc (oldItem_base0, newCapacity * (int64) sizeof (T*));
  this -> at._elements = newItem_base0 - 1;
  this -> _capacity = newCapacity;
 }
 void _makeRoomForOneMoreItem (integer pos) {
  if (this -> size >= this -> _capacity) {
   integer newCapacity = 2 * this -> _capacity + 30;
   T** oldItem_base0 = ( this -> at._elements ? this -> at._elements + 1 : nullptr );
   T** newItem_base0 = (T**) Melder_realloc (oldItem_base0, newCapacity * (int64) sizeof (T*));
   this -> at._elements = newItem_base0 - 1;
   this -> _capacity = newCapacity;
  }
  this -> size ++;
  for (integer i = this -> size; i > pos; i --) this -> at [i] = this -> at [i - 1];
 }
 T* _insertItem_move (autoSomeThing <T> data, integer pos) {
  this -> _initializeOwnership (true);
  this -> _makeRoomForOneMoreItem (pos);
  return this -> at [pos] = data.releaseToAmbiguousOwner();
 }
 void _insertItem_ref (T* data, integer pos) {
  this -> _initializeOwnership (false);
  this -> _makeRoomForOneMoreItem (pos);
  this -> at [pos] = data;
 }
# 222 "../sys/Collection.h"
 void addItem_ref (T* thing) {
  ((thing) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 223, "thing"), abort ()));
  integer index = this -> _v_position (thing);
  if (index != 0) {
   this -> _insertItem_ref (thing, index);
  } else {
   this -> _initializeOwnership (false);
  }
 }
# 245 "../sys/Collection.h"
 T* addItem_move (autoSomeThing<T> thing) {
  T* thingRef = thing.get();
  integer index = this -> _v_position (thingRef);
  if (index != 0) {
   return this -> _insertItem_move (thing.move(), index);
  } else {
   this -> _initializeOwnership (true);
   thing.reset();
   return nullptr;
  }
 }
# 266 "../sys/Collection.h"
 void undangleItem (Thing thing) {
  for (integer i = this -> size; i > 0; i --) {
   if (this -> at [i] == thing) {
    for (integer j = i; j < this -> size; j ++) {
     this -> at [j] = this -> at [j + 1];
    }
    this -> size --;
   }
  }
 }
# 288 "../sys/Collection.h"
 autoSomeThing<T> subtractItem_move (integer pos) {
  ((pos >= 1 && pos <= this -> size) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 289, "pos >= 1 && pos <= our size"), abort ()));
  ((this -> _ownItems) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 290, "our _ownItems"), abort ()));
  autoSomeThing<T> result;
  result. adoptFromAmbiguousOwner (this -> at [pos]);
  for (integer i = pos; i < this -> size; i ++)
   this -> at [i] = this -> at [i + 1];
  this -> size --;
  return result;
 }
 T* subtractItem_ref (integer pos) {
  ((pos >= 1 && pos <= this -> size) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 299, "pos >= 1 && pos <= our size"), abort ()));
  ((! this -> _ownItems) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 300, "! our _ownItems"), abort ()));
  T* result = this -> at [pos];
  for (integer i = pos; i < this -> size; i ++)
   this -> at [i] = this -> at [i + 1];
  this -> size --;
  return result;
 }
 void replaceItem_ref (T* data, integer pos) {
  ((pos >= 1 && pos <= this -> size) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 308, "pos >= 1 && pos <= our size"), abort ()));
  ((! this -> _ownItems) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 309, "! our _ownItems"), abort ()));
  this -> at [pos] = data;
 }
 T* replaceItem_move (autoSomeThing <T> data, integer pos) {
  ((pos >= 1 && pos <= this -> size) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 313, "pos >= 1 && pos <= our size"), abort ()));
  ((this -> _ownItems) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 314, "our _ownItems"), abort ()));
  _Thing_forget (this -> at [pos]);
  return this -> at [pos] = data.releaseToAmbiguousOwner();
 }
# 327 "../sys/Collection.h"
 void removeItem (integer pos) {
  ((pos >= 1 && pos <= this -> size) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 328, "pos >= 1 && pos <= our size"), abort ()));
  if (this -> _ownItems) _Thing_forget (this -> at [pos]);
  for (integer i = pos; i < this -> size; i ++)
   this -> at [i] = this -> at [i + 1];
  this -> size --;
 }







 void removeAllItems () {
  if (this -> _ownItems) {
   for (integer i = 1; i <= this -> size; i ++)
    _Thing_forget (this -> at [i]);
  }
  this -> size = 0;
 }






 void shrinkToFit () {
  this -> _capacity = ( this -> size > 0 ? this -> size : 1 );
  this -> at ++;
  this -> at = (T**) Melder_realloc (this -> at, this -> _capacity * (int64) sizeof (Thing));
  this -> at --;
 }
 void sort (int (*compare) (T*, T*)) {
  integer l, r, j, i;
  T* k;
  T** a = this -> at._elements;
  integer n = this -> size;
  if (n < 2) return;
  l = (n >> 1) + 1;
  r = n;
  for (;;) {
   if (l > 1) {
    l --;
    k = a [l];
   } else {
    k = a [r];
    a [r] = a [1];
    r --;
    if (r == 1) { a [1] = k; return; }
   }
   j = l;
   for (;;) {
    i = j;
    j = j << 1;
    if (j > r) break;
    if (j < r && compare (a [j], a [j + 1]) < 0) j ++;
    if (compare (k, a [j]) >= 0) break;
    a [i] = a [j];
   }
   a [i] = k;
  }
 }







 void merge (CollectionOf<T>* thee) {
  try {
   if (this -> classInfo != thee -> classInfo)
    do { Melder_appendError (U"The two collections are of different classes."); throw MelderError (); } while (false);
   if (this -> _ownershipInitialized && thee -> _ownershipInitialized && this -> _ownItems != thee -> _ownItems)
    do { Melder_appendError (U"Cannot mix data and references."); throw MelderError (); } while (false);
   if (! this -> _ownershipInitialized && ! thee -> _ownershipInitialized) {
    ((this -> size == 0 && thee -> size == 0) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 404, "our size == 0 && thy size == 0"), abort ()));
    return;
   }
   this -> _ownItems = ( this -> _ownershipInitialized ? this -> _ownItems : thee -> _ownItems );
   for (integer i = 1; i <= thee -> size; i ++) {
    T* item = thee -> at [i];
    if (this -> _ownItems) {
     if (! Thing_isa (item, classDaata))
      do { Melder_appendError (U"Cannot copy item of class ", Thing_className (item), U"."); throw MelderError (); } while (false);
     this -> addItem_move (Data_copy (item));
    } else {
     this -> addItem_ref (item);
    }
   }
  } catch (MelderError) {
   do { Melder_appendError (this, U" and ", thee, U" not merged."); throw MelderError (); } while (false);
  }
 }
# 430 "../sys/Collection.h"
 void v_info () override {
  MelderInfo_writeLine (this -> size, U" items");
 }

 void v_destroy () noexcept override {






  structDaata::v_destroy ();
 }


 void v_copy (Daata data_to) override {
  _CollectionOfDaata_v_copy (reinterpret_cast<_CollectionOfDaata*> (this), reinterpret_cast<_CollectionOfDaata*> (data_to));
 }
 bool v_equal (Daata data2) override {
  return _CollectionOfDaata_v_equal (reinterpret_cast<_CollectionOfDaata*> (this), reinterpret_cast<_CollectionOfDaata*> (data2));
 }
 bool v_canWriteAsEncoding (int outputEncoding) override {
  return _CollectionOfDaata_v_canWriteAsEncoding (reinterpret_cast<_CollectionOfDaata*> (this), outputEncoding);
 }
 void v_writeText (MelderFile openFile) override {
  _CollectionOfDaata_v_writeText (reinterpret_cast<_CollectionOfDaata*> (this), openFile);
 }
 void v_readText (MelderReadText text, int formatVersion) override {
  _CollectionOfDaata_v_readText (reinterpret_cast<_CollectionOfDaata*> (this), text, formatVersion);
 }
 void v_writeBinary (FILE *f) override {
  _CollectionOfDaata_v_writeBinary (reinterpret_cast<_CollectionOfDaata*> (this), f);
 }
 void v_readBinary (FILE *f, int formatVersion) override {
  _CollectionOfDaata_v_readBinary (reinterpret_cast<_CollectionOfDaata*> (this), f, formatVersion);
 }
 Data_Description v_description () override {
  return & theCollectionOfDaata_v_description [0];
 }




 virtual integer _v_position (T* ) {
  return this -> size + 1;
 };
};
# 492 "../sys/Collection.h"
typedef CollectionOf<structThing> structCollection; typedef CollectionOf<structThing> *Collection; typedef autoSomeThing <CollectionOf<structThing>> autoCollection; extern struct structClassInfo theClassInfo_Collection; extern ClassInfo classCollection; static inline autoCollection Collection_create () { autoCollection me; me. adoptFromAmbiguousOwner (new CollectionOf<structThing>); theTotalNumberOfThings += 1; return me; };


#pragma mark - class Ordered





template <typename T>
struct OrderedOf : CollectionOf <T > {

 OrderedOf () {
  extern ClassInfo classOrdered;
  this -> classInfo = classOrdered;
 }







 T* addItemAtPosition_move (autoSomeThing <T> data, integer position) {
  ((data) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 516, "data"), abort ()));
  if (position < 1 || position > this -> size)
   position = this -> size + 1;
  return this -> _insertItem_move (data.move(), position);
 }

 OrderedOf<T>&& move () noexcept { return static_cast <OrderedOf<T>&&> (*this); }
};

typedef OrderedOf<structDaata> structOrdered; typedef OrderedOf<structDaata> *Ordered; typedef autoSomeThing <OrderedOf<structDaata>> autoOrdered; extern struct structClassInfo theClassInfo_Ordered; extern ClassInfo classOrdered; static inline autoOrdered Ordered_create () { autoOrdered me; me. adoptFromAmbiguousOwner (new OrderedOf<structDaata>); theTotalNumberOfThings += 1; return me; };

#pragma mark - class Sorted







template <typename T >
struct SortedOf : CollectionOf <T> {
 SortedOf () {
  extern ClassInfo classSorted;
  this -> classInfo = classSorted;
 }
 SortedOf<T>&& move () noexcept { return static_cast <SortedOf<T>&&> (*this); }
# 558 "../sys/Collection.h"
 void addItem_unsorted_move (autoSomeThing <T> data) {
  this -> _insertItem_move (data.move(), this -> size + 1);
 }


 void sort () {
  this -> CollectionOf<T>::sort (this -> v_getCompareHook ());
 }

 integer _v_position (T* data) override {
  typename SortedOf<T>::CompareHook compare = this -> v_getCompareHook ();
  if (this -> size == 0 || compare (data, this -> at [this -> size]) >= 0) return this -> size + 1;
  if (compare (data, this -> at [1]) < 0) return 1;

  integer left = 1, right = this -> size;
  while (left < right - 1) {
   integer mid = (left + right) / 2;
   if (compare (data, this -> at [mid]) >= 0) left = mid; else right = mid;
  }
  ((right == left + 1) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 577, "right == left + 1"), abort ()));
  return right;
 }

 static int s_compareHook (T* , T* ) noexcept { return 0; }
 typedef int (*CompareHook) (T*, T*);
 virtual CompareHook v_getCompareHook () { return s_compareHook; }

};

typedef SortedOf<structDaata> structSorted; typedef SortedOf<structDaata> *Sorted; typedef autoSomeThing <SortedOf<structDaata>> autoSorted; extern struct structClassInfo theClassInfo_Sorted; extern ClassInfo classSorted; static inline autoSorted Sorted_create () { autoSorted me; me. adoptFromAmbiguousOwner (new SortedOf<structDaata>); theTotalNumberOfThings += 1; return me; };


#pragma mark - class SortedSet




template <typename T >
struct SortedSetOf : SortedOf <T> {

 SortedSetOf () {
  extern ClassInfo classSortedSet;
  this -> classInfo = classSortedSet;
 }

 SortedSetOf<T>&& move () noexcept { return static_cast <SortedSetOf<T>&&> (*this); }





 integer _v_position (T* data) override {
  typename SortedOf<T>::CompareHook compare = this -> v_getCompareHook ();
  if (this -> size == 0) return 1;
  int where = compare (data, this -> at [this -> size]);
  if (where > 0) return this -> size + 1;
  if (where == 0) return 0;
  if (compare (data, this -> at [1]) < 0) return 1;
  integer left = 1, right = this -> size;
  while (left < right - 1) {
   integer mid = (left + right) / 2;
   if (compare (data, this -> at [mid]) >= 0)
    left = mid;
   else
    right = mid;
  }
  ((right == left + 1) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 624, "right == left + 1"), abort ()));
  if (! compare (data, this -> at [left]) || ! compare (data, this -> at [right]))
   return 0;
  return right;
 }

 bool hasItem (T* item) {
  return this -> _v_position (item) == 0;
 }






 void unicize () {
  typename SortedOf<T>::CompareHook compare = this -> v_getCompareHook ();
  integer n = 0, ifrom = 1;
  for (integer i = 1; i <= this -> size; i ++) {
   if (i == this -> size || compare (this -> at [i], this -> at [i + 1]))
   {



    n ++;
    integer ito = i;



    ((ifrom >= n) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 653, "ifrom >= n"), abort ()));
    if (ifrom != n) {
     this -> at [n] = this -> at [ifrom];
     this -> at [ifrom] = nullptr;
    }



    if (this -> _ownItems) {
     for (integer j = ifrom + 1; j <= ito; j ++) {
      _Thing_forget (this -> at [j]);
     }
    }
    ifrom = ito + 1;
   }
  }
  this -> size = n;
 }

};







typedef SortedSetOf<structDaata> structSortedSet; typedef SortedSetOf<structDaata> *SortedSet; typedef autoSomeThing <SortedSetOf<structDaata>> autoSortedSet; extern struct structClassInfo theClassInfo_SortedSet; extern ClassInfo classSortedSet; static inline autoSortedSet SortedSet_create () { autoSortedSet me; me. adoptFromAmbiguousOwner (new SortedSetOf<structDaata>); theTotalNumberOfThings += 1; return me; };


#pragma mark - class SortedSetOfInteger

template <typename T , class = typename std::enable_if_t<std::is_base_of<structSimpleInteger,T>::value> >
struct SortedSetOfIntegerOf : SortedSetOf <T> {
 SortedSetOfIntegerOf () {
 }
 SortedSetOfIntegerOf<T>&& move () noexcept { return static_cast <SortedSetOfIntegerOf<T>&&> (*this); }
 static int s_compareHook (SimpleInteger me, SimpleInteger thee) noexcept {
  if (me -> number < thee -> number) return -1;
  if (me -> number > thee -> number) return +1;
  return 0;
 }
 typename SortedOf<T>::CompareHook v_getCompareHook ()
  override { return (typename SortedOf<T>::CompareHook) this -> s_compareHook; }
};


#pragma mark - class SortedSetOfDouble

template <typename T >
struct SortedSetOfDoubleOf : SortedSetOf <T> {
 SortedSetOfDoubleOf () {
 }
 SortedSetOfDoubleOf<T>&& move () noexcept { return static_cast <SortedSetOfDoubleOf<T>&&> (*this); }
 static int s_compareHook (SimpleDouble me, SimpleDouble thee) noexcept {
  if (me -> number < thee -> number) return -1;
  if (me -> number > thee -> number) return +1;
  return 0;
 }
 typename SortedOf<T>::CompareHook v_getCompareHook ()
  override { return (typename SortedOf<T>::CompareHook) this -> s_compareHook; }
};


#pragma mark - class SortedSetOfString

template <typename T , class = typename std::enable_if_t<std::is_base_of<structSimpleString,T>::value> >
struct SortedSetOfStringOf : SortedSetOf <T> {
 SortedSetOfStringOf () {
 }
 SortedSetOfStringOf<T>&& move () noexcept { return static_cast <SortedSetOfStringOf<T>&&> (*this); }
 static int s_compareHook (SimpleString me, SimpleString thee) noexcept {
  return str32cmp (me -> string.get(), thee -> string.get());
 }
 typename SortedOf<T>::CompareHook v_getCompareHook ()
  override { return (typename SortedOf<T>::CompareHook) this -> s_compareHook; }

 integer lookUp (conststring32 string) {
  integer numberOfItems = this -> size;
  integer left = 1, right = numberOfItems;
  int atStart, atEnd;
  if (numberOfItems == 0) return 0;

  atEnd = str32cmp (string, this -> at [numberOfItems] -> string.get());
  if (atEnd > 0) return 0;
  if (atEnd == 0) return numberOfItems;

  atStart = str32cmp (string, this -> at [1] -> string.get());
  if (atStart < 0) return 0;
  if (atStart == 0) return 1;

  while (left < right - 1) {
   integer mid = (left + right) / 2;
   int here = str32cmp (string, this -> at [mid] -> string.get());
   if (here == 0) return mid;
   if (here > 0) left = mid; else right = mid;
  }
  ((right == left + 1) ? (void) (0) : (Melder_assert_ ("../sys/Collection.h", 750, "right == left + 1"), abort ()));
  return 0;
 }

};


#pragma mark - Collections of specific types






#pragma mark class DaataList

typedef struct structDaataList *DaataList; typedef autoSomeThing <structDaataList> autoDaataList; extern struct structClassInfo theClassInfo_DaataList; extern ClassInfo classDaataList; static inline autoDaataList DaataList_create () { return Thing_newFromClass (classDaataList).static_cast_move<structDaataList>(); } struct structDaataList : OrderedOf<structDaata> {
};

#pragma mark class StringList

typedef struct structStringList *StringList; typedef autoSomeThing <structStringList> autoStringList; extern struct structClassInfo theClassInfo_StringList; extern ClassInfo classStringList; static inline autoStringList StringList_create () { return Thing_newFromClass (classStringList).static_cast_move<structStringList>(); } struct structStringList : OrderedOf<structSimpleString> {
};

#pragma mark class StringSet

typedef struct structStringSet *StringSet; typedef autoSomeThing <structStringSet> autoStringSet; extern struct structClassInfo theClassInfo_StringSet; extern ClassInfo classStringSet; static inline autoStringSet StringSet_create () { return Thing_newFromClass (classStringSet).static_cast_move<structStringSet>(); } struct structStringSet : SortedSetOfStringOf<structSimpleString> {
 void addString_copy (conststring32 string) {
  autoSimpleString newSimp = SimpleString_create (string);
  this -> addItem_move (newSimp.move());
 }
};
# 22 "../fon/AnyTier.h" 2
# 1 "../fon/PointProcess.h" 1
# 21 "../fon/PointProcess.h"
# 1 "../fon/Function.h" 1
# 21 "../fon/Function.h"
# 1 "../sys/Data.h" 1
# 22 "../fon/Function.h" 2

# 1 "../fon/Function_def.h" 1
# 21 "../fon/Function_def.h"
typedef struct structFunction *Function; typedef autoSomeThing <structFunction> autoFunction; typedef structDaata Function_Parent; extern struct structClassInfo theClassInfo_Function; extern ClassInfo classFunction; struct structFunction : public structDaata {

 double xmin;
 double xmax;







  void v_info ()
   override;
  bool v_hasGetXmin ()
   override { return true; }
  double v_getXmin ()
   override { return xmin; }
  bool v_hasGetXmax ()
   override { return true; }
  double v_getXmax ()
   override { return xmax; }

  virtual int v_domainQuantity () { return 0; }
  virtual int v_getMinimumUnit (integer ) { return 0; }
  virtual int v_getMaximumUnit (integer ) { return 0; }
  virtual conststring32 v_getUnitText (integer , int , uint32 )
   { return U""; }
  virtual bool v_isUnitLogarithmic (integer , int )
   { return false; }
  virtual double v_convertStandardToSpecialUnit (double value, integer , int )
   { return value; }
  virtual double v_convertSpecialToStandardUnit (double value, integer , int )
   { return value; }
  virtual void v_shiftX (double xfrom, double xto);
  virtual void v_scaleX (double xminfrom, double xmaxfrom, double xminto, double xmaxto);


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 24 "../fon/Function.h" 2
# 32 "../fon/Function.h"
void Function_init (Function me, double xmin, double xmax);
# 41 "../fon/Function.h"
int Function_getDomainQuantity (Function me);
# 51 "../fon/Function.h"
int Function_getMinimumUnit (Function me, integer ilevel);
int Function_getMaximumUnit (Function me, integer ilevel);




conststring32 Function_getUnitText (Function me, integer level, int unit, uint32 flags);

bool Function_isUnitLogarithmic (Function me, integer level, int unit);

double Function_convertStandardToSpecialUnit (Function me, double value, integer level, int unit);
double Function_convertSpecialToStandardUnit (Function me, double value, integer level, int unit);
double Function_convertToNonlogarithmic (Function me, double value, integer level, int unit);
# 78 "../fon/Function.h"
double Function_window (double tim, int windowType);
# 126 "../fon/Function.h"
void Function_unidirectionalAutowindow (Function me, double *xmin, double *xmax);
void Function_bidirectionalAutowindow (Function me, double *x1, double *x2);
bool Function_intersectRangeWithDomain (Function me, double *x1, double *x2);

void Function_shiftXBy (Function me, double shift);
void Function_shiftXTo (Function me, double xfrom, double xto);
void Function_scaleXBy (Function me, double factor);
void Function_scaleXTo (Function me, double xminto, double xmaxto);
# 22 "../fon/PointProcess.h" 2
# 1 "../sys/Graphics.h" 1
# 22 "../sys/Graphics.h"
# 1 "../sys/../kar/longchar.h" 1
# 21 "../sys/../kar/longchar.h"
# 1 "../sys/../kar/../melder/melder.h" 1
# 22 "../sys/../kar/longchar.h" 2
# 51 "../sys/../kar/longchar.h"
char32 * Longchar_nativize (const char32 *generic, char32 *native, bool educateQuotes);

char32 * Longchar_genericize (const char32 *native, char32 *generic);
# 64 "../sys/../kar/longchar.h"
typedef struct structLongchar_Info {
 unsigned char first, second;

 unsigned char alphabet;
 unsigned char isDiacritic;
 struct {
  const char *name;

  short times, timesBold, timesItalic, timesBoldItalic;
  short helvetica, helveticaBold;
  short palatino, palatinoBold, palatinoItalic, palatinoBoldItalic;

 }
  ps;
 unsigned short xwinEncoding;
 unsigned short winEncoding;
 unsigned short macEncoding;
 unsigned short psEncoding;
 char32 unicode;
}
 *Longchar_Info;

Longchar_Info Longchar_getInfo (char32 kar1, char32 kar2);
Longchar_Info Longchar_getInfoFromNative (char32 kar);
# 110 "../sys/../kar/longchar.h"
inline static bool Longchar_Info_isDiacritic (Longchar_Info me) {
 return me -> isDiacritic;
}

void Longchar_init ();
# 23 "../sys/Graphics.h" 2

# 1 "../sys/Graphics_enums.h" 1
# 19 "../sys/Graphics_enums.h"
enum class kGraphics_font { UNDEFINED = -1, MIN = 0,
 HELVETICA = 0,
 TIMES = 1,
 COURIER = 2,
 PALATINO = 3,





MAX = 3, DEFAULT = TIMES }; conststring32 kGraphics_font_getText (kGraphics_font value); kGraphics_font kGraphics_font_getValue (conststring32 text); inline static kGraphics_font& operator++ (kGraphics_font& value) { value = static_cast <kGraphics_font> (static_cast <int> (value) + 1); return value; }

enum class kGraphics_horizontalAlignment { UNDEFINED = -1, MIN = 0,
 LEFT = 0,
 CENTRE = 1,

 RIGHT = 2,





MAX = 2, DEFAULT = CENTRE }; conststring32 kGraphics_horizontalAlignment_getText (kGraphics_horizontalAlignment value); kGraphics_horizontalAlignment kGraphics_horizontalAlignment_getValue (conststring32 text); inline static kGraphics_horizontalAlignment& operator++ (kGraphics_horizontalAlignment& value) { value = static_cast <kGraphics_horizontalAlignment> (static_cast <int> (value) + 1); return value; }

enum class kGraphics_resolution { UNDEFINED = -1, MIN = 0,
 DPI_90 = 0,
 DPI_96 = 1,
 DPI_100 = 2,
 DPI_120 = 3,
 DPI_150 = 4,
 DPI_180 = 5,
 DPI_200 = 6,
 DPI_300 = 7,
 DPI_360 = 8,
 DPI_600 = 9,
 DPI_720 = 10,
 DPI_900 = 11,
 DPI_1200 = 12,
MAX = 12, DEFAULT = DPI_100 }; conststring32 kGraphics_resolution_getText (kGraphics_resolution value); kGraphics_resolution kGraphics_resolution_getValue (conststring32 text); inline static kGraphics_resolution& operator++ (kGraphics_resolution& value) { value = static_cast <kGraphics_resolution> (static_cast <int> (value) + 1); return value; }

enum class kGraphics_colourScale { UNDEFINED = -1, MIN = 0,
 GREY = 0,
 BLUE_TO_RED = 1,





MAX = 1, DEFAULT = GREY }; conststring32 kGraphics_colourScale_getText (kGraphics_colourScale value); kGraphics_colourScale kGraphics_colourScale_getValue (conststring32 text); inline static kGraphics_colourScale& operator++ (kGraphics_colourScale& value) { value = static_cast <kGraphics_colourScale> (static_cast <int> (value) + 1); return value; }

enum class kGraphicsPostscript_spots { UNDEFINED = -1, MIN = 0,
 FINE = 0,
 PHOTOCOPYABLE = 1,
MAX = 1, DEFAULT = FINE }; conststring32 kGraphicsPostscript_spots_getText (kGraphicsPostscript_spots value); kGraphicsPostscript_spots kGraphicsPostscript_spots_getValue (conststring32 text); inline static kGraphicsPostscript_spots& operator++ (kGraphicsPostscript_spots& value) { value = static_cast <kGraphicsPostscript_spots> (static_cast <int> (value) + 1); return value; }

enum class kGraphicsPostscript_paperSize { UNDEFINED = -1, MIN = 0,
 A4 = 0,
 A3 = 1,
 US_LETTER = 2,
MAX = 2, DEFAULT = A4 }; conststring32 kGraphicsPostscript_paperSize_getText (kGraphicsPostscript_paperSize value); kGraphicsPostscript_paperSize kGraphicsPostscript_paperSize_getValue (conststring32 text); inline static kGraphicsPostscript_paperSize& operator++ (kGraphicsPostscript_paperSize& value) { value = static_cast <kGraphicsPostscript_paperSize> (static_cast <int> (value) + 1); return value; }

enum class kGraphicsPostscript_orientation { UNDEFINED = -1, MIN = 0,
 PORTRAIT = 0,
 LANDSCAPE = 1,
MAX = 1, DEFAULT = PORTRAIT }; conststring32 kGraphicsPostscript_orientation_getText (kGraphicsPostscript_orientation value); kGraphicsPostscript_orientation kGraphicsPostscript_orientation_getValue (conststring32 text); inline static kGraphicsPostscript_orientation& operator++ (kGraphicsPostscript_orientation& value) { value = static_cast <kGraphicsPostscript_orientation> (static_cast <int> (value) + 1); return value; }

enum class kGraphicsPostscript_fontChoiceStrategy { UNDEFINED = -1, MIN = 0,
 AUTOMATIC = 0,
 LINOTYPE = 1,
 MONOTYPE = 2,
 PS_MONOTYPE = 3,
MAX = 3, DEFAULT = AUTOMATIC }; conststring32 kGraphicsPostscript_fontChoiceStrategy_getText (kGraphicsPostscript_fontChoiceStrategy value); kGraphicsPostscript_fontChoiceStrategy kGraphicsPostscript_fontChoiceStrategy_getValue (conststring32 text); inline static kGraphicsPostscript_fontChoiceStrategy& operator++ (kGraphicsPostscript_fontChoiceStrategy& value) { value = static_cast <kGraphicsPostscript_fontChoiceStrategy> (static_cast <int> (value) + 1); return value; }

enum class kGraphics_cjkFontStyle { UNDEFINED = -1, MIN = 0,
 CHINESE = 0,
 JAPANESE = 1,
MAX = 1, DEFAULT = CHINESE }; conststring32 kGraphics_cjkFontStyle_getText (kGraphics_cjkFontStyle value); kGraphics_cjkFontStyle kGraphics_cjkFontStyle_getValue (conststring32 text); inline static kGraphics_cjkFontStyle& operator++ (kGraphics_cjkFontStyle& value) { value = static_cast <kGraphics_cjkFontStyle> (static_cast <int> (value) + 1); return value; }
# 25 "../sys/Graphics.h" 2

typedef struct { double x1NDC, x2NDC, y1NDC, y2NDC; } Graphics_Viewport;

typedef struct structGuiDrawingArea *GuiDrawingArea; typedef autoSomeThing <structGuiDrawingArea> autoGuiDrawingArea; extern struct structClassInfo theClassInfo_GuiDrawingArea; extern ClassInfo classGuiDrawingArea;

typedef struct {
 unsigned char link, rightToLeft;
 short style, size, baseline;
 double size_real;
 uint32 code;
 char32 kar;
 Longchar_Info karInfo;
 double width;
 union { integer integer_; const char *string; void *pointer; } font;
 int cell, line, run;
} _Graphics_widechar;

typedef struct structGraphics *Graphics; typedef autoSomeThing <structGraphics> autoGraphics; extern struct structClassInfo theClassInfo_Graphics; extern ClassInfo classGraphics; typedef structThing Graphics_Parent; struct structGraphics : public structThing {

 bool screen;

 bool postScript;

 bool printer;

 bool metafile;

 bool yIsZeroAtTheTop;

 GuiDrawingArea d_drawingArea;

 int resolution;

 enum kGraphics_resolution resolutionNumber;
 integer d_x1DCmin, d_x2DCmax, d_y1DCmin, d_y2DCmax;





 integer d_x1DC, d_x2DC, d_y1DC, d_y2DC;







 double d_x1wNDC, d_x2wNDC, d_y1wNDC, d_y2wNDC;






 double d_x1NDC, d_x2NDC, d_y1NDC, d_y2NDC;







 double d_x1WC, d_x2WC, d_y1WC, d_y2WC;






 double deltaX, deltaY, scaleX, scaleY;


 int lineType;
 MelderColour colour;
 double lineWidth, arrowSize, speckleSize;
 kGraphics_colourScale colourScale;
 int horizontalTextAlignment, verticalTextAlignment;
 double textRotation, wrapWidth, secondIndent, textX, textY;
 kGraphics_font font;
 double fontSize;
 int fontStyle;
 int percentSignIsItalic, numberSignIsBold, circumflexIsSuperscript, underscoreIsSubscript;
 int dollarSignIsCode, atSignIsLink;
 bool recording, duringXor;
 integer irecord, nrecord;
 double *record;
 Graphics_Viewport outerViewport;
 double horTick, vertTick;
 double paperWidth, paperHeight;

 void v_destroy () noexcept
  override;

 virtual void v_polyline (integer , double * , bool ) { }
 virtual void v_fillArea (integer , double * ) { }
 virtual void v_rectangle (double , double , double , double ) { }
 virtual void v_fillRectangle (double , double , double , double ) { }
 virtual void v_circle (double , double , double ) { }
 virtual void v_ellipse (double , double , double , double ) { }
 virtual void v_arc (double , double , double , double , double ) { }
 virtual void v_fillCircle (double , double , double ) { }
 virtual void v_fillEllipse (double , double , double , double ) { }
 virtual void v_button (double a_x1DC, double a_x2DC, double a_y1DC, double a_y2DC)
  {
   v_rectangle (a_x1DC, a_x2DC, a_y1DC, a_y2DC);
  }
 virtual void v_roundedRectangle (double x1DC, double x2DC, double y1DC, double y2DC, double r);
 virtual void v_fillRoundedRectangle (double x1DC, double x2DC, double y1DC, double y2DC, double r);
 virtual void v_arrowHead (double xDC, double yDC, double angle);
 virtual bool v_mouseStillDown () { return false; }
 virtual void v_getMouseLocation (double *xWC, double *yWC) { *xWC = *yWC = undefined; }
 virtual void v_flushWs () { }
 virtual void v_clearWs () { }
 virtual void v_updateWs () { }
};

autoGraphics Graphics_create (int resolution);
autoGraphics Graphics_create_postscriptjob (MelderFile file, int resolution, kGraphicsPostscript_spots spots,
 kGraphicsPostscript_paperSize paperSize, kGraphicsPostscript_orientation rotation, double magnification);
autoGraphics Graphics_create_epsfile (MelderFile file, int resolution, enum kGraphicsPostscript_spots spots,
 double xmin, double xmax, double ymin, double ymax, bool includeFonts, bool useSilipaPS);
autoGraphics Graphics_create_pdffile (MelderFile file, int resolution,
 double x1inches, double x2inches, double y1inches, double y2inches);
autoGraphics Graphics_create_pdf (void *context, int resolution,
 double x1inches, double x2inches, double y1inches, double y2inches);
autoGraphics Graphics_create_pngfile (MelderFile file, int resolution,
 double x1inches, double x2inches, double y1inches, double y2inches);
autoGraphics Graphics_create_postscriptprinter (void);
autoGraphics Graphics_create_screenPrinter (void *display, void *window);
autoGraphics Graphics_create_screen (void *display, void *window, int resolution);
autoGraphics Graphics_create_xmdrawingarea (GuiDrawingArea drawingArea);

int Graphics_getResolution (Graphics me);






void Graphics_setWsViewport (Graphics me, integer x1DC, integer x2DC, integer y1DC, integer y2DC);
void Graphics_resetWsViewport (Graphics me, integer x1DC, integer x2DC, integer y1DC, integer y2DC);
void Graphics_setWsWindow (Graphics me, double x1NDC, double x2NDC, double y1NDC, double y2NDC);
void Graphics_inqWsViewport (Graphics me, integer *x1DC, integer *x2DC, integer *y1DC, integer *y2DC);
void Graphics_inqWsWindow (Graphics me, double *x1NDC, double *x2NDC, double *y1NDC, double *y2NDC);
void Graphics_clearWs (Graphics me);
void Graphics_flushWs (Graphics me);
void Graphics_updateWs (Graphics me);
void Graphics_beginMovieFrame (Graphics me, MelderColour *colour);
void Graphics_endMovieFrame (Graphics me, double frameDuration);
void Graphics_DCtoWC (Graphics me, integer xDC, integer yDC, double *xWC, double *yWC);
void Graphics_WCtoDC (Graphics me, double xWC, double yWC, integer *xDC, integer *yDC);

void Graphics_setViewport (Graphics me, double x1NDC, double x2NDC, double y1NDC, double y2NDC);
Graphics_Viewport Graphics_insetViewport (Graphics me, double x1rel, double x2rel, double y1rel, double y2rel);
void Graphics_resetViewport (Graphics me, Graphics_Viewport viewport);
void Graphics_setWindow (Graphics me, double x1, double x2, double y1, double y2);

void Graphics_polyline (Graphics me, integer numberOfPoints, double *x, double *y);
void Graphics_polyline_closed (Graphics me, integer numberOfPoints, double *x, double *y);

void Graphics_text (Graphics me, double xWC, double yWC, conststring32 txt);
template <typename... Args>
void Graphics_text (Graphics me, double xWC, double yWC, const MelderArg& first, Args... rest) {
 Graphics_text (me, xWC, yWC, Melder_cat (first, rest...));
}

void Graphics_textRect (Graphics me, double x1, double x2, double y1, double y2, conststring32 text );
double Graphics_textWidth (Graphics me, conststring32 text );
double Graphics_textWidth_ps (Graphics me, conststring32 text , bool useSilipaPS);
double Graphics_textWidth_ps_mm (Graphics me, conststring32 text , bool useSilipaPS);
void Graphics_fillArea (Graphics me, integer numberOfPoints, double const *x, double const *y);
void Graphics_cellArray (Graphics me, constMATVU const& z,
 double x1, double x2, double y1, double y2, double minimum, double maximum);
void Graphics_cellArray_colour (Graphics me, constmatrixview <MelderColour> const& z,
 double x1, double x2, double y1, double y2, double minimum, double maximum);
void Graphics_cellArray8 (Graphics me, constmatrixview <unsigned char> const& z,
 double x1, double x2, double y1, double y2, unsigned char minimum, unsigned char maximum);
void Graphics_image (Graphics me, constMATVU const& z,
 double x1, double x2, double y1, double y2, double minimum, double maximum);
void Graphics_image_colour (Graphics me, constmatrixview <MelderColour> const& z,
 double x1, double x2, double y1, double y2, double minimum, double maximum);
void Graphics_image8 (Graphics me, constmatrixview <unsigned char> const& z,
 double x1, double x2, double y1, double y2, uint8 minimum, uint8 maximum);
void Graphics_imageFromFile (Graphics me, conststring32 relativeFileName, double x1, double x2, double y1, double y2);
void Graphics_line (Graphics me, double x1, double y1, double x2, double y2);
void Graphics_rectangle (Graphics me, double x1, double x2, double y1, double y2);
void Graphics_fillRectangle (Graphics me, double x1, double x2, double y1, double y2);
void Graphics_roundedRectangle (Graphics me, double x1, double x2, double y1, double y2, double r_mm);
void Graphics_fillRoundedRectangle (Graphics me, double x1, double x2, double y1, double y2, double r_mm);
void Graphics_function (Graphics me, const double y [], integer ix1, integer ix2, double x1, double x2);
void Graphics_function16 (Graphics me, const int16 y [], integer stride, integer ix1, integer ix2, double x1, double x2);
void Graphics_circle (Graphics me, double x, double y, double r);
void Graphics_fillCircle (Graphics me, double x, double y, double r);
void Graphics_circle_mm (Graphics me, double x, double y, double d);
void Graphics_fillCircle_mm (Graphics me, double x, double y, double d);
void Graphics_speckle (Graphics me, double x, double y);
void Graphics_rectangle_mm (Graphics me, double x, double y, double horizontalSide_mm, double verticalSide_mm);
void Graphics_fillRectangle_mm (Graphics me, double x, double y, double horizontalSide_mm, double verticalSide_mm);
void Graphics_arc (Graphics me, double x, double y, double r, double fromAngle, double toAngle);
void Graphics_fillArc (Graphics me, double x, double y, double r, double fromAngle, double toAngle);
void Graphics_ellipse (Graphics me, double x1, double x2, double y1, double y2);
void Graphics_fillEllipse (Graphics me, double x1, double x2, double y1, double y2);
void Graphics_arrow (Graphics me, double x1, double y1, double x2, double y2);
void Graphics_doubleArrow (Graphics me, double x1, double y1, double x2, double y2);
void Graphics_arcArrow (Graphics me, double x, double y, double r, double fromAngle, double toAngle, int arrowAtStart, int arrowAtEnd);
void Graphics_mark (Graphics me, double x, double y, double size_mm, conststring32 markString );
void Graphics_button (Graphics me, double x1, double x2, double y1, double y2);
void Graphics_innerRectangle (Graphics me, double x1, double x2, double y1, double y2);

void Graphics_setColour (Graphics me, MelderColour colour);
void Graphics_setGrey (Graphics me, double grey);

void Graphics_xorOn (Graphics me, MelderColour colour);
void Graphics_xorOff (Graphics me);
void Graphics_highlight (Graphics me, double x1, double x2, double y1, double y2);
void Graphics_unhighlight (Graphics me, double x1, double x2, double y1, double y2);
void Graphics_highlight2 (Graphics me, double x1, double x2, double y1, double y2,
 double innerX1, double innerX2, double innerY1, double innerY2);
void Graphics_unhighlight2 (Graphics me, double x1, double x2, double y1, double y2,
 double innerX1, double innerX2, double innerY1, double innerY2);
# 255 "../sys/Graphics.h"
void Graphics_setTextAlignment (Graphics me, enum kGraphics_horizontalAlignment horizontal, int vertical);

void Graphics_setFont (Graphics me, enum kGraphics_font font);
void Graphics_setFontSize (Graphics me, double height);






void Graphics_setFontStyle (Graphics me, int style);

void Graphics_setItalic (Graphics me, bool onoff);
void Graphics_setBold (Graphics me, bool onoff);
void Graphics_setCode (Graphics me, bool onoff);
void Graphics_setTextRotation (Graphics me, double angle);
void Graphics_setTextRotation_vector (Graphics me, double dx, double dy);
void Graphics_setWrapWidth (Graphics me, double wrapWidth);
void Graphics_setSecondIndent (Graphics me, double indent);
double Graphics_inqTextX (Graphics me);
double Graphics_inqTextY (Graphics me);
typedef struct { double x1, x2, y1, y2; char32 *name; } Graphics_Link;
int Graphics_getLinks (Graphics_Link **plinks);
void Graphics_setNumberSignIsBold (Graphics me, bool isBold);
void Graphics_setPercentSignIsItalic (Graphics me, bool isItalic);
void Graphics_setCircumflexIsSuperscript (Graphics me, bool isSuperscript);
void Graphics_setUnderscoreIsSubscript (Graphics me, bool isSubscript);
void Graphics_setDollarSignIsCode (Graphics me, bool isCode);
void Graphics_setAtSignIsLink (Graphics me, bool isLink);





void Graphics_setLineType (Graphics me, int lineType);

void Graphics_setLineWidth (Graphics me, double lineWidth);
void Graphics_setArrowSize (Graphics me, double arrowSize);
void Graphics_setSpeckleSize (Graphics me, double speckleSize);

void Graphics_setColourScale (Graphics me, enum kGraphics_colourScale colourScale);

void Graphics_inqViewport (Graphics me, double *x1NDC, double *x2NDC, double *y1NDC, double *y2NDC);
void Graphics_inqWindow (Graphics me, double *x1WC, double *x2WC, double *y1WC, double *y2WC);
enum kGraphics_font Graphics_inqFont (Graphics me);
double Graphics_inqFontSize (Graphics me);
int Graphics_inqFontStyle (Graphics me);
int Graphics_inqLineType (Graphics me);
double Graphics_inqLineWidth (Graphics me);
double Graphics_inqArrowSize (Graphics me);
double Graphics_inqSpeckleSize (Graphics me);
MelderColour Graphics_inqColour (Graphics me);
enum kGraphics_colourScale Graphics_inqColourScale (Graphics me);

void Graphics_contour (Graphics me, constMATVU const& z,
 double x1WC, double x2WC, double y1WC, double y2WC, double height);
void Graphics_altitude (Graphics me, constMATVU const& z,
 double x1WC, double x2WC, double y1WC, double y2WC, int numberOfBorders, double borders []);
void Graphics_grey (Graphics me, constMATVU const& z,
 double x1WC, double x2WC, double y1WC, double y2WC, int numberOfBorders, double borders []);

void Graphics_surface (Graphics me, constMATVU const& z,
 double x1WC, double x2WC, double y1WC, double y2WC,
 double minimum, double maximum, double elevation, double azimuth
);

void Graphics_setInner (Graphics me);
void Graphics_unsetInner (Graphics me);
void Graphics_drawInnerBox (Graphics me);
void Graphics_textLeft (Graphics me, bool farr, conststring32 text );
void Graphics_textRight (Graphics me, bool farr, conststring32 text );
void Graphics_textBottom (Graphics me, bool farr, conststring32 text );
void Graphics_textTop (Graphics me, bool farr, conststring32 text );
void Graphics_marksLeft (Graphics me, int numberOfMarks, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksRight (Graphics me, int numberOfMarks, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksBottom (Graphics me, int numberOfMarks, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksTop (Graphics me, int numberOfMarks, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksLeftLogarithmic (Graphics me, int numberOfMarksPerDecade, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksRightLogarithmic (Graphics me, int numberOfMarksPerDecade, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksBottomLogarithmic (Graphics me, int numberOfMarksPerDecade, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksTopLogarithmic (Graphics me, int numberOfMarksPerDecade, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_markLeft (Graphics me, double yWC, bool hasNumber, bool hasTick, bool hasDottedLine, conststring32 text );
void Graphics_markRight (Graphics me, double yWC, bool hasNumber, bool hasTick, bool hasDottedLine, conststring32 text );
void Graphics_markBottom (Graphics me, double xWC, bool hasNumber, bool hasTick, bool hasDottedLine, conststring32 text );
void Graphics_markTop (Graphics me, double xWC, bool hasNumber, bool hasTick, bool hasDottedLine, conststring32 text );
void Graphics_markLeftLogarithmic (Graphics me, double y, bool hasNumber, bool hasTick, bool hasDottedLine, conststring32 text );
void Graphics_markRightLogarithmic (Graphics me, double y, bool hasNumber, bool hasTick, bool hasDottedLine, conststring32 text );
void Graphics_markBottomLogarithmic (Graphics me, double x, bool hasNumber, bool hasTick, bool hasDottedLine, conststring32 text );
void Graphics_markTopLogarithmic (Graphics me, double x, bool hasNumber, bool hasTick, bool hasDottedLine, conststring32 text );
void Graphics_marksLeftEvery (Graphics me, double units, double distance, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksRightEvery (Graphics me, double units, double distance, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksBottomEvery (Graphics me, double units, double distance, bool haveNumbers, bool haveTicks, bool haveDottedLines);
void Graphics_marksTopEvery (Graphics me, double units, double distance, bool haveNumbers, bool haveTicks, bool haveDottedLines);

void *Graphics_x_getCR (Graphics me);
void Graphics_x_setCR (Graphics me, void *cr);
void *Graphics_x_getGC (Graphics me);

bool Graphics_startRecording (Graphics me);
bool Graphics_stopRecording (Graphics me);
void Graphics_clearRecording (Graphics me);
void Graphics_play (Graphics from, Graphics to);
void Graphics_writeRecordings (Graphics me, FILE *f);
void Graphics_readRecordings (Graphics me, FILE *f);
void Graphics_markGroup (Graphics me);
void Graphics_undoGroup (Graphics me);

double Graphics_dxMMtoWC (Graphics me, double dx_mm);
double Graphics_dyMMtoWC (Graphics me, double dy_mm);
double Graphics_distanceWCtoMM (Graphics me, double x1WC, double y1WC, double x2WC, double y2WC);
double Graphics_dxWCtoMM (Graphics me, double dxWC);
double Graphics_dyWCtoMM (Graphics me, double dyWC);

bool Graphics_mouseStillDown (Graphics me);
void Graphics_waitMouseUp (Graphics me);
void Graphics_getMouseLocation (Graphics me, double *xWC, double *yWC);

void Graphics_nextSheetOfPaper (Graphics me);

void Graphics_prefs ();
# 23 "../fon/PointProcess.h" 2

# 1 "../fon/PointProcess_def.h" 1
# 21 "../fon/PointProcess_def.h"
typedef struct structPointProcess *PointProcess; typedef autoSomeThing <structPointProcess> autoPointProcess; typedef structFunction PointProcess_Parent; extern struct structClassInfo theClassInfo_PointProcess; extern ClassInfo classPointProcess; struct structPointProcess : public structFunction {

 integer nt;
 autovector <double> t;


  void v_info ()
   override;
  int v_domainQuantity ()
   override { return 1; }
  void v_shiftX (double xfrom, double xto)
   override;
  void v_scaleX (double xminfrom, double xmaxfrom, double xminto, double xmaxto)
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 25 "../fon/PointProcess.h" 2

autoPointProcess PointProcess_create (double startingTime, double finishingTime, integer initialMaxnt);
autoPointProcess PointProcess_createPoissonProcess (double startingTime, double finishingTime, double density);
void PointProcess_init (PointProcess me, double startingTime, double finishingTime, integer initialMaxnt);
integer PointProcess_getLowIndex (PointProcess me, double t);
integer PointProcess_getHighIndex (PointProcess me, double t);
integer PointProcess_getNearestIndex (PointProcess me, double t);
integer PointProcess_getWindowPoints (PointProcess me, double tmin, double tmax, integer *p_imin, integer *p_imax);
void PointProcess_addPoint (PointProcess me, double t);
void PointProcess_addPoints (PointProcess me, constVECVU const& times);
integer PointProcess_findPoint (PointProcess me, double t);
void PointProcess_removePoint (PointProcess me, integer index);
void PointProcess_removePointNear (PointProcess me, double t);
void PointProcess_removePoints (PointProcess me, integer first, integer last);
void PointProcess_removePointsBetween (PointProcess me, double fromTime, double toTime);
void PointProcess_draw (PointProcess me, Graphics g, double fromTime, double toTime, bool garnish);
double PointProcess_getInterval (PointProcess me, double t);
autoPointProcess PointProcesses_union (PointProcess me, PointProcess thee);
autoPointProcess PointProcesses_intersection (PointProcess me, PointProcess thee);
autoPointProcess PointProcesses_difference (PointProcess me, PointProcess thee);
void PointProcess_fill (PointProcess me, double tmin, double tmax, double period);
void PointProcess_voice (PointProcess me, double period, double maxT);

integer PointProcess_getNumberOfPeriods (PointProcess me, double tmin, double tmax,
 double minimumPeriod, double maximumPeriod, double maximumPeriodFactor);
double PointProcess_getMeanPeriod (PointProcess me, double tmin, double tmax,
 double minimumPeriod, double maximumPeriod, double maximumPeriodFactor);
double PointProcess_getStdevPeriod (PointProcess me, double tmin, double tmax,
 double minimumPeriod, double maximumPeriod, double maximumPeriodFactor);
# 23 "../fon/AnyTier.h" 2

typedef struct structAnyPoint *AnyPoint; typedef autoSomeThing <structAnyPoint> autoAnyPoint; extern struct structClassInfo theClassInfo_AnyPoint; extern ClassInfo classAnyPoint; typedef structSimpleDouble AnyPoint_Parent; struct structAnyPoint : public structSimpleDouble {
};

typedef struct structAnyTier *AnyTier; typedef autoSomeThing <structAnyTier> autoAnyTier; extern struct structClassInfo theClassInfo_AnyTier; extern ClassInfo classAnyTier; typedef structFunction AnyTier_Parent; struct structAnyTier : public structFunction {
 SortedSetOfDoubleOf <structAnyPoint> points;

 void v_shiftX (double xfrom, double xto)
  override;
 void v_scaleX (double xminfrom, double xmaxfrom, double xminto, double xmaxto)
  override;
};

integer AnyTier_timeToLowIndex (AnyTier me, double time);

integer AnyTier_timeToHighIndex (AnyTier me, double time);

integer AnyTier_getWindowPoints (AnyTier me, double tmin, double tmax, integer *imin, integer *imax);

integer AnyTier_timeToNearestIndex (AnyTier me, double time);

integer AnyTier_hasPoint (AnyTier me, double t);

void AnyTier_addPoint_move (AnyTier me, autoAnyPoint point);

void AnyTier_removePoint (AnyTier me, integer i);

void AnyTier_removePointNear (AnyTier me, double time);

void AnyTier_removePointsBetween (AnyTier me, double tmin, double tmax);

autoPointProcess AnyTier_downto_PointProcess (AnyTier me);
# 22 "../fon/RealTier.h" 2

# 1 "../stat/TableOfReal.h" 1
# 23 "../stat/TableOfReal.h"
# 1 "../sys/Strings_.h" 1
# 23 "../sys/Strings_.h"
# 1 "../sys/Strings_def.h" 1
# 21 "../sys/Strings_def.h"
typedef struct structStrings *Strings; typedef autoSomeThing <structStrings> autoStrings; typedef structDaata Strings_Parent; extern struct structClassInfo theClassInfo_Strings; extern ClassInfo classStrings; struct structStrings : public structDaata {

 integer numberOfStrings;
 autoSTRVEC strings;


  void v_info ()
   override;
  bool v_hasGetVectorStr ()
   override { return true; }
  conststring32 v_getVectorStr (integer icol)
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 24 "../sys/Strings_.h" 2

autoStrings Strings_createAsFileList (conststring32 path );
autoStrings Strings_createAsDirectoryList (conststring32 path );
autoStrings Strings_readFromRawTextFile (MelderFile file);
void Strings_writeToRawTextFile (Strings me, MelderFile file);

void Strings_randomize (Strings me);
void Strings_genericize (Strings me);
void Strings_nativize (Strings me);
void Strings_sort (Strings me);

void Strings_remove (Strings me, integer position);
void Strings_replace (Strings me, integer position, conststring32 text);
void Strings_insert (Strings me, integer position, conststring32 text);
# 24 "../stat/TableOfReal.h" 2
# 1 "../stat/Table.h" 1
# 23 "../stat/Table.h"
typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;

# 1 "../stat/Table_def.h" 1
# 21 "../stat/Table_def.h"
typedef struct structTableCell *TableCell; struct structTableCell {

 autostring32 string;


  double number;


void destroy (); void copy (TableCell data_to); bool equal (TableCell otherData); Data_Description description (); static Data_Description s_description; bool canWriteAsEncoding (int outputEncoding); void writeText (MelderFile openFile); void readText (MelderReadText text, int formatVersion); void writeBinary (FILE *f); void readBinary (FILE *f, int formatVersion); };




typedef struct structTableRow *TableRow; typedef autoSomeThing <structTableRow> autoTableRow; typedef structDaata TableRow_Parent; extern struct structClassInfo theClassInfo_TableRow; extern ClassInfo classTableRow; struct structTableRow : public structDaata {

 integer numberOfColumns;
 autovector <structTableCell> cells;


  integer sortingIndex;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structTableColumnHeader *TableColumnHeader; struct structTableColumnHeader {

 autostring32 label;


  int16 numericized;


void destroy (); void copy (TableColumnHeader data_to); bool equal (TableColumnHeader otherData); Data_Description description (); static Data_Description s_description; bool canWriteAsEncoding (int outputEncoding); void writeText (MelderFile openFile); void readText (MelderReadText text, int formatVersion); void writeBinary (FILE *f); void readBinary (FILE *f, int formatVersion); };




typedef struct structTable *Table; typedef autoSomeThing <structTable> autoTable; typedef structDaata Table_Parent; extern struct structClassInfo theClassInfo_Table; extern ClassInfo classTable; struct structTable : public structDaata {

 integer numberOfColumns;
 autovector <structTableColumnHeader> columnHeaders;
 OrderedOf<structTableRow> rows;


  void v_info ()
   override;
  bool v_hasGetNrow ()
   override { return true; }
  double v_getNrow ()
   override { return rows.size; }
  bool v_hasGetNcol ()
   override { return true; }
  double v_getNcol ()
   override { return numberOfColumns; }
  bool v_hasGetColStr ()
   override { return true; }
  conststring32 v_getColStr (integer columnNumber)
   override;
  bool v_hasGetMatrix ()
   override { return true; }
  double v_getMatrix (integer rowNumber, integer columnNumber)
   override;
  bool v_hasGetMatrixStr ()
   override { return true; }
  conststring32 v_getMatrixStr (integer rowNumber, integer columnNumber)
   override;
  bool v_hasGetColIndex ()
   override { return true; }
  double v_getColIndex (conststring32 columnLabel)
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 26 "../stat/Table.h" 2

void Table_initWithColumnNames (Table me, integer numberOfRows, conststring32 columnNames);
autoTable Table_createWithColumnNames (integer numberOfRows, conststring32 columnNames);
void Table_initWithoutColumnNames (Table me, integer numberOfRows, integer numberOfColumns);
autoTable Table_createWithoutColumnNames (integer numberOfRows, integer numberOfColumns);


autoTable Tables_append (OrderedOf<structTable>* me);
void Table_appendRow (Table me);
void Table_appendColumn (Table me, conststring32 label);
void Table_appendSumColumn (Table me, integer column1, integer column2, conststring32 label);
void Table_appendDifferenceColumn (Table me, integer column1, integer column2, conststring32 label);
void Table_appendProductColumn (Table me, integer column1, integer column2, conststring32 label);
void Table_appendQuotientColumn (Table me, integer column1, integer column2, conststring32 label);
void Table_removeRow (Table me, integer row);
void Table_removeColumn (Table me, integer column);
void Table_insertRow (Table me, integer row);
void Table_insertColumn (Table me, integer column, conststring32 label );
void Table_setColumnLabel (Table me, integer column, conststring32 label );
integer Table_findColumnIndexFromColumnLabel (Table me, conststring32 label) noexcept;
integer Table_getColumnIndexFromColumnLabel (Table me, conststring32 columnLabel);
autoINTVEC Table_getColumnIndicesFromColumnLabelString (Table me, conststring32 string);
integer Table_searchColumn (Table me, integer column, conststring32 value) noexcept;





conststring32 Table_getStringValue_Assert (Table me, integer row, integer column);
double Table_getNumericValue_Assert (Table me, integer row, integer column);





void Table_setStringValue (Table me, integer rowNumber, integer columnNumber, conststring32 value );
void Table_setNumericValue (Table me, integer row, integer column, double value);


void Table_numericize_Assert (Table me, integer columnNumber);

double Table_getQuantile (Table me, integer column, double quantile);
double Table_getMean (Table me, integer column);
double Table_getMaximum (Table me, integer icol);
double Table_getMinimum (Table me, integer icol);
double Table_getGroupMean (Table me, integer column, integer groupColumn, conststring32 group);
double Table_getStdev (Table me, integer column);
integer Table_drawRowFromDistribution (Table me, integer column);
double Table_getCorrelation_pearsonR (Table me, integer column1, integer column2, double significanceLevel,
 double *out_significance, double *out_lowerLimit, double *out_upperLimit);
double Table_getCorrelation_kendallTau (Table me, integer column1, integer column2, double significanceLevel,
 double *out_significance, double *out_lowerLimit, double *out_upperLimit);
double Table_getMean_studentT (Table me, integer column, double significanceLevel,
 double *out_tFromZero, double *out_numberOfDegreesOfFreedom, double *out_significanceFromZero, double *out_lowerLimit, double *out_upperLimit);
double Table_getDifference_studentT (Table me, integer column1, integer column2, double significanceLevel,
 double *out_t, double *out_numberOfDegreesOfFreedom, double *out_significance, double *out_lowerLimit, double *out_upperLimit);
double Table_getGroupMean_studentT (Table me, integer column, integer groupColumn, conststring32 group1, double significanceLevel,
 double *out_tFromZero, double *out_numberOfDegreesOfFreedom, double *out_significanceFromZero, double *out_lowerLimit, double *out_upperLimit);
double Table_getGroupDifference_studentT (Table me, integer column, integer groupColumn, conststring32 group1, conststring32 group2, double significanceLevel,
 double *out_tFromZero, double *out_numberOfDegreesOfFreedom, double *out_significanceFromZero, double *out_lowerLimit, double *out_upperLimit);
double Table_getGroupDifference_wilcoxonRankSum (Table me, integer column, integer groupColumn, conststring32 group1, conststring32 group2,
 double *out_rankSum, double *out_significanceFromZero);
double Table_getVarianceRatio (Table me, integer column1, integer column2, double significanceLevel,
 double *out_significance, double *out_lowerLimit, double *out_upperLimit);
bool Table_getExtrema (Table me, integer icol, double *minimum, double *maximum);

void Table_formula (Table me, integer column, conststring32 formula, Interpreter interpreter);
void Table_formula_columnRange (Table me, integer column1, integer column2, conststring32 expression, Interpreter interpreter);

void Table_sortRows_Assert (Table me, constINTVEC columns);
void Table_sortRows_string (Table me, conststring32 columns_string);
void Table_randomizeRows (Table me) noexcept;
void Table_reflectRows (Table me) noexcept;

void Table_scatterPlot (Table me, Graphics g, integer xcolumn, integer ycolumn,
 double xmin, double xmax, double ymin, double ymax, integer markColumn, double fontSize, bool garnish);
void Table_scatterPlot_mark (Table me, Graphics g, integer xcolumn, integer ycolumn,
 double xmin, double xmax, double ymin, double ymax, double markSize_mm, conststring32 mark, bool garnish);
void Table_drawEllipse_e (Table me, Graphics g, integer xcolumn, integer ycolumn,
 double xmin, double xmax, double ymin, double ymax, double numberOfSigmas, bool garnish);

void Table_list (Table me, bool includeRowNumbers);
void Table_writeToTabSeparatedFile (Table me, MelderFile file);
void Table_writeToCommaSeparatedFile (Table me, MelderFile file);
void Table_writeToSemicolonSeparatedFile (Table me, MelderFile file);
autoTable Table_readFromTableFile (MelderFile file);
autoTable Table_readFromCharacterSeparatedTextFile (MelderFile file, char32 separator, bool interpretQuotes);

autoTable Table_extractRowsWhereColumn_number (Table me, integer column, kMelder_number which, double criterion);
autoTable Table_extractRowsWhereColumn_string (Table me, integer column, kMelder_string which, conststring32 criterion);
autoTable Table_collapseRows (Table me, conststring32 factors_string, conststring32 columnsToSum_string,
 conststring32 columnsToAverage_string, conststring32 columnsToMedianize_string,
 conststring32 columnsToAverageLogarithmically_string, conststring32 columnsToMedianizeLogarithmically_string);
autoTable Table_rowsToColumns (Table me, conststring32 factors_string, integer columnToTranspose, conststring32 columnsToExpand_string);
autoTable Table_transpose (Table me);

void Table_checkSpecifiedRowNumberWithinRange (Table me, integer rowNumber);
void Table_checkSpecifiedColumnNumberWithinRange (Table me, integer columnNumber);
bool Table_isCellNumeric_ErrorFalse (Table me, integer rowNumber, integer columnNumber);
bool Table_isColumnNumeric_ErrorFalse (Table me, integer columnNumber);

conststring32 Table_messageColumn (Table me, integer column);
# 25 "../stat/TableOfReal.h" 2
typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;

# 1 "../stat/TableOfReal_def.h" 1
# 21 "../stat/TableOfReal_def.h"
typedef struct structTableOfReal *TableOfReal; typedef autoSomeThing <structTableOfReal> autoTableOfReal; typedef structDaata TableOfReal_Parent; extern struct structClassInfo theClassInfo_TableOfReal; extern ClassInfo classTableOfReal; struct structTableOfReal : public structDaata {

 integer numberOfRows;
 integer numberOfColumns;
 autoSTRVEC rowLabels;
 autoSTRVEC columnLabels;
 automatrix <double> data;


  void v_info ()
   override;
  bool v_hasGetNrow ()
   override { return true; }
  double v_getNrow ()
   override { return numberOfRows; }
  bool v_hasGetNcol ()
   override { return true; }
  double v_getNcol ()
   override { return numberOfColumns; }
  bool v_hasGetRowStr ()
   override { return true; }
  conststring32 v_getRowStr (integer irow)
   override;
  bool v_hasGetColStr ()
   override { return true; }
  conststring32 v_getColStr (integer icol)
   override;
  bool v_hasGetMatrix ()
   override { return true; }
  double v_getMatrix (integer irow, integer icol)
   override;
  bool v_hasGetRowIndex ()
   override { return true; }
  double v_getRowIndex (conststring32 rowLabel)
   override;
  bool v_hasGetColIndex ()
   override { return true; }
  double v_getColIndex (conststring32 columnLabel)
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 28 "../stat/TableOfReal.h" 2

void TableOfReal_init (TableOfReal me, integer numberOfRows, integer numberOfColumns);
autoTableOfReal TableOfReal_create (integer numberOfRows, integer numberOfColumns);
void TableOfReal_removeRow (TableOfReal me, integer rowNumber);
void TableOfReal_removeColumn (TableOfReal me, integer columnNumber);
void TableOfReal_insertRow (TableOfReal me, integer rowNumber);
void TableOfReal_insertColumn (TableOfReal me, integer columnNumber);
void TableOfReal_setRowLabel (TableOfReal me, integer rowNumber, conststring32 label );
void TableOfReal_setColumnLabel (TableOfReal me, integer columnNumber, conststring32 label );
integer TableOfReal_rowLabelToIndex (TableOfReal me, conststring32 label );
integer TableOfReal_columnLabelToIndex (TableOfReal me, conststring32 label );
double TableOfReal_getColumnMean (TableOfReal me, integer columnNumber);
double TableOfReal_getColumnStdev (TableOfReal me, integer columnNumber);

autoTableOfReal Table_to_TableOfReal (Table me, integer labelColumn);
autoTable TableOfReal_to_Table (TableOfReal me, conststring32 labelOfFirstColumn);
void TableOfReal_formula (TableOfReal me, conststring32 expression, Interpreter interpreter, TableOfReal target);
void TableOfReal_drawAsNumbers (TableOfReal me, Graphics g, integer rowmin, integer rowmax, int iformat, int precision);
void TableOfReal_drawAsNumbers_if (TableOfReal me, Graphics g, integer rowmin, integer rowmax, int iformat, int precision,
 conststring32 conditionFormula, Interpreter interpreter);
void TableOfReal_drawAsSquares (TableOfReal me, Graphics g, integer rowmin, integer rowmax,
 integer colmin, integer colmax, bool garnish);
void TableOfReal_drawVerticalLines (TableOfReal me, Graphics g, integer rowmin, integer rowmax);
void TableOfReal_drawHorizontalLines (TableOfReal me, Graphics g, integer rowmin, integer rowmax);
void TableOfReal_drawLeftAndRightLines (TableOfReal me, Graphics g, integer rowmin, integer rowmax);
void TableOfReal_drawTopAndBottomLines (TableOfReal me, Graphics g, integer rowmin, integer rowmax);

autoTableOfReal TablesOfReal_append (TableOfReal me, TableOfReal thee);
autoTableOfReal TablesOfReal_appendMany (OrderedOf<structTableOfReal>* me);
void TableOfReal_sortByLabel (TableOfReal me, integer column1, integer column2);
void TableOfReal_sortByColumn (TableOfReal me, integer column1, integer column2);

void TableOfReal_writeToHeaderlessSpreadsheetFile (TableOfReal me, MelderFile file);
autoTableOfReal TableOfReal_readFromHeaderlessSpreadsheetFile (MelderFile file);

autoTableOfReal TableOfReal_extractRowRanges (TableOfReal me, conststring32 ranges);
autoTableOfReal TableOfReal_extractColumnRanges (TableOfReal me, conststring32 ranges);

autoTableOfReal TableOfReal_extractRowsWhereColumn (TableOfReal me, integer icol, kMelder_number which, double criterion);
autoTableOfReal TableOfReal_extractColumnsWhereRow (TableOfReal me, integer icol, kMelder_number which, double criterion);

autoTableOfReal TableOfReal_extractRowsWhereLabel (TableOfReal me, kMelder_string which, conststring32 criterion);
autoTableOfReal TableOfReal_extractColumnsWhereLabel (TableOfReal me, kMelder_string which, conststring32 criterion);

autoTableOfReal TableOfReal_extractRowsWhere (TableOfReal me, conststring32 condition, Interpreter interpreter);
autoTableOfReal TableOfReal_extractColumnsWhere (TableOfReal me, conststring32 condition, Interpreter interpreter);

autoStrings TableOfReal_extractRowLabelsAsStrings (TableOfReal me);
autoStrings TableOfReal_extractColumnLabelsAsStrings (TableOfReal me);

#pragma mark - class TableOfRealList

typedef struct structTableOfRealList *TableOfRealList; typedef autoSomeThing <structTableOfRealList> autoTableOfRealList; extern struct structClassInfo theClassInfo_TableOfRealList; extern ClassInfo classTableOfRealList; static inline autoTableOfRealList TableOfRealList_create () { return Thing_newFromClass (classTableOfRealList).static_cast_move<structTableOfRealList>(); } struct structTableOfRealList : OrderedOf<structTableOfReal> {
};
# 24 "../fon/RealTier.h" 2
# 1 "../fon/Vector.h" 1
# 24 "../fon/Vector.h"
# 1 "../fon/Matrix.h" 1
# 21 "../fon/Matrix.h"
# 1 "../fon/SampledXY.h" 1
# 21 "../fon/SampledXY.h"
# 1 "../fon/Sampled.h" 1
# 25 "../fon/Sampled.h"
# 1 "../fon/Sampled_def.h" 1
# 21 "../fon/Sampled_def.h"
typedef struct structSampled *Sampled; typedef autoSomeThing <structSampled> autoSampled; typedef structFunction Sampled_Parent; extern struct structClassInfo theClassInfo_Sampled; extern ClassInfo classSampled; struct structSampled : public structFunction {

 integer nx;
 double dx;
 double x1;
# 37 "../fon/Sampled_def.h"
  bool v_hasGetNx ()
   override { return true; }
  double v_getNx ()
   override { return nx; }
  bool v_hasGetDx ()
   override { return true; }
  double v_getDx ()
   override { return dx; }
  bool v_hasGetX ()
   override { return true; }
  double v_getX (integer ix)
   override { return x1 + (ix - 1) * dx; }
  void v_shiftX (double xfrom, double xto)
   override;
  void v_scaleX (double xminfrom, double xmaxfrom, double xminto, double xmaxto)
   override;

  virtual double v_getValueAtSample (integer , integer , int )
   { return undefined; }
  virtual conststring32 v_getIndexText () const
   { return U"index"; }
  virtual conststring32 v_getNxText () const
   { return U"nx"; }
  virtual void checkIndex (integer index) {
   do { if (! (index >= 1)) do { Melder_appendError (U"The ", this -> v_getIndexText (), U" should be at least 1, but is ", index, U" instead."); throw MelderError (); } while (false); } while (false)
                                                                                           ;
   do { if (! (index <= this -> nx)) do { Melder_appendError (U"The ", this -> v_getIndexText (), U" should be at most ", this -> v_getNxText (), U" (", this -> nx, U"), but is ", index, U" instead."); throw MelderError (); } while (false); } while (false)


    ;
  }



void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 26 "../fon/Sampled.h" 2






template <typename T> static inline double Sampled_indexToX (Sampled me, T index) { return me -> x1 + (index - (T) 1) * me -> dx; }
static inline double Sampled_xToIndex (Sampled me, double x) { return (x - me -> x1) / me -> dx + 1.0; }
static inline integer Sampled_xToLowIndex (Sampled me, double x) { return Melder_iroundDown ((x - me -> x1) / me -> dx + 1.0); }
static inline integer Sampled_xToHighIndex (Sampled me, double x) { return Melder_iroundUp ((x - me -> x1) / me -> dx + 1.0); }
static inline integer Sampled_xToNearestIndex (Sampled me, double x) { return Melder_iround_tieUp ((x - me -> x1) / me -> dx + 1.0); }

static inline autoVEC Sampled_listAllXValues (Sampled me) {
 autoVEC result = newVECraw (me -> nx);
 for (integer i = 1; i <= me -> nx; i ++)
  result [i] = me -> x1 + (i - 1) * me -> dx;
 return result;
}

integer Sampled_getWindowSamples (Sampled me, double xmin, double xmax, integer *ixmin, integer *ixmax);

void Sampled_init (Sampled me, double xmin, double xmax, integer nx, double dx, double x1);

void Sampled_shortTermAnalysis (Sampled me, double windowDuration, double timeStep,
 integer *numberOfFrames, double *firstTime);
# 81 "../fon/Sampled.h"
double Sampled_getValueAtSample (Sampled me, integer sampleNumber, integer levelNumber, int unit);
autoVEC Sampled_listValuesOfAllSamples (Sampled me, integer levelNumber, int unit);
double Sampled_getValueAtX (Sampled me, double x, integer levelNumber, int unit, bool interpolate);
autoVEC Sampled_listValuesAtXes (Sampled me, constVECVU const& xes, integer levelNumber, int unit, bool interpolate);

integer Sampled_countDefinedSamples
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit);
autoVEC Sampled_getSortedValues
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit);

double Sampled_getQuantile
 (Sampled me, double xmin, double xmax, double quantile, integer levelNumber, int unit);
double Sampled_getMean
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate);
double Sampled_getMean_standardUnit
 (Sampled me, double xmin, double xmax, integer levelNumber, int averagingUnit, bool interpolate);
double Sampled_getIntegral
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate);
double Sampled_getIntegral_standardUnit
 (Sampled me, double xmin, double xmax, integer levelNumber, int averagingUnit, bool interpolate);
double Sampled_getStandardDeviation
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate);
double Sampled_getStandardDeviation_standardUnit
 (Sampled me, double xmin, double xmax, integer levelNumber, int averagingUnit, bool interpolate);

void Sampled_getMinimumAndX
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate,
  double *return_minimum, double *return_xOfMinimum);
double Sampled_getMinimum
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate);
double Sampled_getXOfMinimum
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate);
void Sampled_getMaximumAndX
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate,
  double *return_maximum, double *return_xOfMaximum);
double Sampled_getMaximum
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate);
double Sampled_getXOfMaximum
 (Sampled me, double xmin, double xmax, integer levelNumber, int unit, bool interpolate);

void Sampled_drawInside
 (Sampled me, Graphics g, double xmin, double xmax, double ymin, double ymax, bool speckle, integer levelNumber, int unit);
# 22 "../fon/SampledXY.h" 2

# 1 "../fon/SampledXY_def.h" 1
# 21 "../fon/SampledXY_def.h"
typedef struct structSampledXY *SampledXY; typedef autoSomeThing <structSampledXY> autoSampledXY; typedef structSampled SampledXY_Parent; extern struct structClassInfo theClassInfo_SampledXY; extern ClassInfo classSampledXY; struct structSampledXY : public structSampled {

 double ymin;
 double ymax;
 integer ny;
 double dy;
 double y1;
# 42 "../fon/SampledXY_def.h"
  bool v_hasGetYmin ()
   override { return true; }
  double v_getYmin ()
   override { return ymin; }
  bool v_hasGetYmax ()
   override { return true; }
  double v_getYmax ()
   override { return ymax; }
  bool v_hasGetNy ()
   override { return true; }
  double v_getNy ()
   override { return ny; }
  bool v_hasGetDy ()
   override { return true; }
  double v_getDy ()
   override { return dy; }
  bool v_hasGetY ()
   override { return true; }
  double v_getY (integer iy)
   override { return y1 + (iy - 1) * dy; }


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 24 "../fon/SampledXY.h" 2

void SampledXY_init (SampledXY me, double xmin, double xmax, integer nx, double dx, double x1,
                                   double ymin, double ymax, integer ny, double dy, double y1);

template <typename T> static inline double SampledXY_indexToY (SampledXY me, T index) { return me -> y1 + (index - (T) 1) * me -> dy; }
static inline double SampledXY_yToIndex (SampledXY me, double y) { return (y - me -> y1) / me -> dy + 1.0; }
static inline integer SampledXY_yToLowIndex (SampledXY me, double y) { return Melder_iroundDown ((y - me -> y1) / me -> dy + 1.0); }
static inline integer SampledXY_yToHighIndex (SampledXY me, double y) { return Melder_iroundUp ((y - me -> y1) / me -> dy + 1.0); }
static inline integer SampledXY_yToNearestIndex (SampledXY me, double y) { return Melder_iround_tieUp ((y - me -> y1) / me -> dy + 1.0); }

integer SampledXY_getWindowSamplesY (SampledXY me, double ymin, double ymax, integer *iymin, integer *iymax);
# 22 "../fon/Matrix.h" 2

# 1 "../fon/../stat/Table.h" 1
# 24 "../fon/Matrix.h" 2
# 1 "../fon/../stat/TableOfReal.h" 1
# 25 "../fon/Matrix.h" 2
typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;

# 1 "../fon/Matrix_def.h" 1
# 21 "../fon/Matrix_def.h"
typedef struct structMatrix *Matrix; typedef autoSomeThing <structMatrix> autoMatrix; typedef structSampledXY Matrix_Parent; extern struct structClassInfo theClassInfo_Matrix; extern ClassInfo classMatrix; struct structMatrix : public structSampledXY {
# 34 "../fon/Matrix_def.h"
  automatrix <double> z;



  void v_info ()
   override;
  bool v_hasGetNrow ()
   override { return true; }
  double v_getNrow ()
   override { return ny; }
  bool v_hasGetNcol ()
   override { return true; }
  double v_getNcol ()
   override { return nx; }
  bool v_hasGetMatrix ()
   override { return true; }
  double v_getMatrix (integer irow, integer icol)
   override;
  bool v_hasGetFunction2 ()
   override { return true; }
  double v_getFunction2 (double x, double y)
   override;
  double v_getValueAtSample (integer sampleNumber, integer level, int unit)
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 28 "../fon/Matrix.h" 2


template <typename T, typename... Args>
 autoSomeThing <T> Thing_create (Args ... args) {
  autoSomeThing <T> me (new T);
  me -> T::init (args...);
  return me;
 }

template <typename... ArgumentTypes>
autoMatrix CreateMatrix (ArgumentTypes... arguments) {
 try {
  autoMatrix me = Thing_newFromClass (classMatrix).static_cast_move<structMatrix>();
  Matrix_init (me.get(), arguments...);
  return me;
 } catch (MelderError) {
  do { Melder_appendError (U"Matrix object not created."); throw MelderError (); } while (false);
 }
}


void Matrix_init
 (Matrix me, double xmin, double xmax, integer nx, double dx, double x1,
             double ymin, double ymax, integer ny, double dy, double y1);

autoMatrix Matrix_create
 (double xmin, double xmax, integer nx, double dx, double x1,
  double ymin, double ymax, integer ny, double dy, double y1);
# 80 "../fon/Matrix.h"
autoMatrix Matrix_createSimple (integer numberOfRows, integer numberOfColumns);
# 122 "../fon/Matrix.h"
integer Matrix_getWindowSamplesX (Matrix me, double xmin, double xmax, integer *ixmin, integer *ixmax);
# 135 "../fon/Matrix.h"
double Matrix_getValueAtXY (Matrix me, double x, double y);






double Matrix_getSum (Matrix me);
double Matrix_getNorm (Matrix me);

double Matrix_columnToX (Matrix me, double column);

double Matrix_rowToY (Matrix me, double row);

double Matrix_xToColumn (Matrix me, double x);

integer Matrix_xToLowColumn (Matrix me, double x);

integer Matrix_xToHighColumn (Matrix me, double x);

integer Matrix_xToNearestColumn (Matrix me, double x);

double Matrix_yToRow (Matrix me, double y);

integer Matrix_yToLowRow (Matrix me, double y);

integer Matrix_yToHighRow (Matrix me, double x);

integer Matrix_yToNearestRow (Matrix me, double y);

integer Matrix_getWindowSamplesY (Matrix me, double ymin, double ymax, integer *iymin, integer *iymax);

integer Matrix_getWindowExtrema (Matrix me, integer ixmin, integer ixmax, integer iymin, integer iymax,
 double *minimum, double *maximum);
# 180 "../fon/Matrix.h"
void Matrix_formula (Matrix me, conststring32 expression, Interpreter interpreter, Matrix target);
# 195 "../fon/Matrix.h"
void Matrix_formula_part (Matrix me, double xmin, double xmax, double ymin, double ymax,
 conststring32 expression, Interpreter interpreter, Matrix target);
# 210 "../fon/Matrix.h"
void Matrix_drawRows (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax,
 double minimum, double maximum);






void Matrix_drawOneContour (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax,
 double height);

void Matrix_drawContours (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax,
 double minimum, double maximum);


void Matrix_paintContours (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax,
 double minimum, double maximum);


void Matrix_paintImage (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax,
 double minimum, double maximum);





void Matrix_paintCells (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax,
 double minimum, double maximum);





void Matrix_paintSurface (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax,
 double minimum, double maximum, double elevation, double azimuth);





void Matrix_playMovie (Matrix me, Graphics g);

autoMatrix Matrix_readFromRawTextFile (MelderFile file);
autoMatrix Matrix_readAP (MelderFile file);
autoMatrix Matrix_appendRows (Matrix me, Matrix thee, ClassInfo klas);

void Matrix_eigen (Matrix me, autoMatrix *eigenvectors, autoMatrix *eigenvalues);
autoMatrix Matrix_power (Matrix me, integer power);

void Matrix_scaleAbsoluteExtremum (Matrix me, double scale);

autoMatrix Table_to_Matrix (Table me);
void Matrix_writeToMatrixTextFile (Matrix me, MelderFile file);
void Matrix_writeToHeaderlessSpreadsheetFile (Matrix me, MelderFile file);

autoMatrix TableOfReal_to_Matrix (TableOfReal me);
autoTableOfReal Matrix_to_TableOfReal (Matrix me);
# 25 "../fon/Vector.h" 2

typedef struct structVector *Vector; typedef autoSomeThing <structVector> autoVector; extern struct structClassInfo theClassInfo_Vector; extern ClassInfo classVector; typedef structMatrix Vector_Parent; struct structVector : public structMatrix {
 bool v_hasGetVector ()
  override { return true; }
 double v_getVector (integer irow, integer icol)
  override;
 bool v_hasGetFunction1 ()
  override { return true; }
 double v_getFunction1 (integer irow, double x)
  override;
 bool v_hasGetMatrix ()
  override { return false; }
 bool v_hasGetFunction2 ()
  override { return false; }
 double v_getValueAtSample (integer isamp, integer ilevel, int unit)
  override;

 VEC channel (integer channelNumber) { return z.row (channelNumber); }
};
# 53 "../fon/Vector.h"
double Vector_getValueAtX (Vector me, double x, integer channel, int interpolation);

void Vector_getMinimumAndX (Vector me, double xmin, double xmax, integer channel, int interpolation,
 double *return_minimum, double *return_xOfMinimum);
void Vector_getMinimumAndXAndChannel (Vector me, double xmin, double xmax, int interpolation,
 double *return_minimum, double *return_xOfMinimum, integer *return_channelOfMinimum);
void Vector_getMaximumAndX (Vector me, double xmin, double xmax, integer channel, int interpolation,
 double *return_maximum, double *return_xOfMaximum);
void Vector_getMaximumAndXAndChannel (Vector me, double xmin, double xmax, int interpolation,
 double *return_maximum, double *return_xOfMaximum, integer *return_channelOfMaximum);
double Vector_getMinimum (Vector me, double xmin, double xmax, int interpolation);
double Vector_getMaximum (Vector me, double xmin, double xmax, int interpolation);
double Vector_getAbsoluteExtremum (Vector me, double xmin, double xmax, int interpolation);
double Vector_getXOfMinimum (Vector me, double xmin, double xmax, int interpolation);
double Vector_getXOfMaximum (Vector me, double xmin, double xmax, int interpolation);
integer Vector_getChannelOfMinimum (Vector me, double xmin, double xmax, int interpolation);
integer Vector_getChannelOfMaximum (Vector me, double xmin, double xmax, int interpolation);

double Vector_getMean (Vector me, double xmin, double xmax, integer channel);
double Vector_getStandardDeviation (Vector me, double xmin, double xmax, integer channel);

void Vector_addScalar (Vector me, double scalar);
void Vector_subtractMean (Vector me);
void Vector_multiplyByScalar (Vector me, double scalar);
void Vector_scale (Vector me, double scale);

void Vector_draw (Vector me, Graphics g, double *pxmin, double *pxmax, double *pymin, double *pymax,
 double defaultDy, conststring32 method);
# 25 "../fon/RealTier.h" 2
typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;



# 1 "../fon/RealTier_def.h" 1
# 21 "../fon/RealTier_def.h"
typedef struct structRealPoint *RealPoint; typedef autoSomeThing <structRealPoint> autoRealPoint; typedef structAnyPoint RealPoint_Parent; extern struct structClassInfo theClassInfo_RealPoint; extern ClassInfo classRealPoint; struct structRealPoint : public structAnyPoint {

 double value;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 35 "../fon/RealTier_def.h"
typedef struct structRealTier *RealTier; typedef autoSomeThing <structRealTier> autoRealTier; typedef structFunction RealTier_Parent; extern struct structClassInfo theClassInfo_RealTier; extern ClassInfo classRealTier; struct structRealTier : public structFunction {

 SortedSetOfDoubleOf<structRealPoint> points;


  AnyTier asAnyTier () { return reinterpret_cast <AnyTier> (this); } void v_shiftX (double xfrom, double xto) override { ((AnyTier) this) -> structAnyTier::v_shiftX (xfrom, xto); } void v_scaleX (double xminfrom, double xmaxfrom, double xminto, double xmaxto) override { ((AnyTier) this) -> structAnyTier::v_scaleX (xminfrom, xmaxfrom, xminto, xmaxto); };

  void v_info ()
   override;
  bool v_hasGetNx ()
   override { return true; }
  double v_getNx ()
   override { return points.size; }
  bool v_hasGetX ()
   override { return true; }
  double v_getX (integer ix)
   override { return points.at [ix] -> number; }
  bool v_hasGetNcol ()
   override { return true; }
  double v_getNcol ()
   override { return points.size; }
  bool v_hasGetVector ()
   override { return true; }
  double v_getVector (integer irow, integer icol)
   override;
  bool v_hasGetFunction1 ()
   override { return true; }
  double v_getFunction1 (integer irow, double x)
   override;
  conststring32 v_getUnitText (integer , int , uint32 )
   override { return U"Time (s)"; }


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 30 "../fon/RealTier.h" 2

autoRealPoint RealPoint_create (double time, double value);
# 40 "../fon/RealTier.h"
void RealTier_init (RealTier me, double tmin, double tmax);
autoRealTier RealTier_create (double tmin, double tmax);
autoRealTier RealTier_createWithClass (double tmin, double tmax, ClassInfo klas);







double RealTier_getValueAtIndex (RealTier me, integer point);


double RealTier_getValueAtTime (RealTier me, double t);




double RealTier_getMinimumValue (RealTier me);
double RealTier_getMaximumValue (RealTier me);
double RealTier_getArea (RealTier me, double tmin, double tmax);
double RealTier_getMean_curve (RealTier me, double tmin, double tmax);
double RealTier_getMean_points (RealTier me, double tmin, double tmax);
double RealTier_getStandardDeviation_curve (RealTier me, double tmin, double tmax);
double RealTier_getStandardDeviation_points (RealTier me, double tmin, double tmax);

void RealTier_addPoint (RealTier me, double t, double value);
void RealTier_draw (RealTier me, Graphics g, double tmin, double tmax,
 double ymin, double ymax, int garnish, conststring32 method, conststring32 quantity);
autoTableOfReal RealTier_downto_TableOfReal (RealTier me, conststring32 timeLabel, conststring32 valueLabel);

void RealTier_interpolateQuadratically (RealTier me, integer numberOfPointsPerParabola, int logarithmically);

autoTable RealTier_downto_Table (RealTier me, conststring32 indexText, conststring32 timeText, conststring32 valueText);
autoRealTier Vector_to_RealTier (Vector me, integer channel, ClassInfo klas);
autoRealTier Vector_to_RealTier_peaks (Vector me, integer channel, ClassInfo klas);
autoRealTier Vector_to_RealTier_valleys (Vector me, integer channel, ClassInfo klas);
autoRealTier PointProcess_upto_RealTier (PointProcess me, double value, ClassInfo klas);

void RealTier_formula (RealTier me, conststring32 expression, Interpreter interpreter, RealTier thee);
void RealTier_multiplyPart (RealTier me, double tmin, double tmax, double factor);
void RealTier_removePointsBelow (RealTier me, double level);
# 22 "../fon/FormantGrid.h" 2
# 1 "../fon/Sound.h" 1
# 26 "../fon/Sound.h"
# 1 "../fon/Sound_enums.h" 1
# 19 "../fon/Sound_enums.h"
enum class kSound_windowShape { UNDEFINED = -1, MIN = 0,
 RECTANGULAR = 0,
 TRIANGULAR = 1,
 PARABOLIC = 2,
 HANNING = 3,
 HAMMING = 4,
 GAUSSIAN_1 = 5,
 GAUSSIAN_2 = 6,
 GAUSSIAN_3 = 7,
 GAUSSIAN_4 = 8,
 GAUSSIAN_5 = 9,
 KAISER_1 = 10,
 KAISER_2 = 11,
MAX = 11, DEFAULT = RECTANGULAR }; conststring32 kSound_windowShape_getText (kSound_windowShape value); kSound_windowShape kSound_windowShape_getValue (conststring32 text); inline static kSound_windowShape& operator++ (kSound_windowShape& value) { value = static_cast <kSound_windowShape> (static_cast <int> (value) + 1); return value; }

enum class kSounds_convolve_scaling { UNDEFINED = -1, MIN = 1,
 INTEGRAL = 1,
 SUM = 2,
 NORMALIZE = 3,
 PEAK_099 = 4,
MAX = 4, DEFAULT = PEAK_099 }; conststring32 kSounds_convolve_scaling_getText (kSounds_convolve_scaling value); kSounds_convolve_scaling kSounds_convolve_scaling_getValue (conststring32 text); inline static kSounds_convolve_scaling& operator++ (kSounds_convolve_scaling& value) { value = static_cast <kSounds_convolve_scaling> (static_cast <int> (value) + 1); return value; }

enum class kSounds_convolve_signalOutsideTimeDomain { UNDEFINED = -1, MIN = 1,
 ZERO = 1,
 SIMILAR = 2,

MAX = 2, DEFAULT = ZERO }; conststring32 kSounds_convolve_signalOutsideTimeDomain_getText (kSounds_convolve_signalOutsideTimeDomain value); kSounds_convolve_signalOutsideTimeDomain kSounds_convolve_signalOutsideTimeDomain_getValue (conststring32 text); inline static kSounds_convolve_signalOutsideTimeDomain& operator++ (kSounds_convolve_signalOutsideTimeDomain& value) { value = static_cast <kSounds_convolve_signalOutsideTimeDomain> (static_cast <int> (value) + 1); return value; }
# 27 "../fon/Sound.h" 2

typedef struct structSound *Sound; typedef autoSomeThing <structSound> autoSound; extern struct structClassInfo theClassInfo_Sound; extern ClassInfo classSound; typedef structVector Sound_Parent; struct structSound : public structVector {
 void v_info ()
  override;
 bool v_hasGetMatrix ()
  override { return true; }
 double v_getMatrix (integer irow, integer icol)
  override;
 bool v_hasGetFunction2 ()
  override { return true; }
 double v_getFunction2 (double x, double y)
  override;
 int v_domainQuantity ()
  override { return 1; }
};
# 57 "../fon/Sound.h"
autoSound Sound_create (integer numberOfChannels, double xmin, double xmax, integer nx, double dx, double x1);
# 79 "../fon/Sound.h"
autoSound Sound_createSimple (integer numberOfChannels, double duration, double samplingFrequency);
# 100 "../fon/Sound.h"
autoSound Sound_convertToMono (Sound me);
autoSound Sound_convertToStereo (Sound me);
autoSound Sound_extractChannel (Sound me, integer ichannel);
autoSound Sound_extractChannels (Sound me, constVECVU const& channelNumbers);
autoSound Sounds_combineToStereo (OrderedOf<structSound>* me);






autoSound Sound_upsample (Sound me);

autoSound Sound_resample (Sound me, double samplingFrequency, integer precision);






autoSound Sounds_append (Sound me, double silenceDuration, Sound thee);
# 138 "../fon/Sound.h"
autoSound Sounds_convolve (Sound me, Sound thee, kSounds_convolve_scaling scaling, kSounds_convolve_signalOutsideTimeDomain signalOutsideTimeDomain);
# 154 "../fon/Sound.h"
autoSound Sounds_crossCorrelate (Sound me, Sound thee, kSounds_convolve_scaling scaling, kSounds_convolve_signalOutsideTimeDomain signalOutsideTimeDomain);
autoSound Sounds_crossCorrelate_short (Sound me, Sound thee, double tmin, double tmax, bool normalize);
autoSound Sound_autoCorrelate (Sound me, kSounds_convolve_scaling scaling, kSounds_convolve_signalOutsideTimeDomain signalOutsideTimeDomain);

double Sound_getRootMeanSquare (Sound me, double xmin, double xmax);
double Sound_getEnergy (Sound me, double xmin, double xmax);
double Sound_getPower (Sound me, double xmin, double xmax);
double Sound_getEnergyInAir (Sound me);
double Sound_getPowerInAir (Sound me);
double Sound_getIntensity_dB (Sound me);

double Sound_getNearestZeroCrossing (Sound me, double position, integer ichannel);
void Sound_setZero (Sound me, double tmin, double tmax, bool roundTimesToNearestZeroCrossing);

autoSound Sound_createAsPureTone (integer numberOfChannels, double startingTime, double endTime,
 double sampleRate, double frequency, double amplitude, double fadeInDuration, double fadeOutDuration);
autoSound Sound_createAsToneComplex (double startingTime, double endTime,
 double sampleRate, int phase, double frequencyStep,
 double firstFrequency, double ceiling, integer numberOfComponents);




autoSound Sounds_concatenate (OrderedOf<structSound>& list, double overlapTime);
void Sound_multiplyByWindow (Sound me, kSound_windowShape windowShape);
void Sound_scaleIntensity (Sound me, double newAverageIntensity);
void Sound_overrideSamplingFrequency (Sound me, double newSamplingFrequency);
autoSound Sound_extractPart (Sound me, double t1, double t2, kSound_windowShape windowShape, double relativeWidth, bool preserveTimes);
autoSound Sound_extractPartForOverlap (Sound me, double t1, double t2, double overlap);
void Sound_filterWithFormants (Sound me, double tmin, double tmax,
 int numberOfFormants, double formant [], double bandwidth []);
autoSound Sound_filter_oneFormant (Sound me, double frequency, double bandwidth);
void Sound_filterWithOneFormantInplace (Sound me, double frequency, double bandwidth);
autoSound Sound_filter_preemphasis (Sound me, double frequency);
autoSound Sound_filter_deemphasis (Sound me, double frequency);

void Sound_reverse (Sound me, double tmin, double tmax);

void Sound_draw (Sound me, Graphics g,
 double tmin, double tmax, double minimum, double maximum, bool garnish, conststring32 method);


autoMatrix Sound_to_Matrix (Sound me);





autoSound Matrix_to_Sound (Matrix me);

autoSound Matrix_to_Sound_mono (Matrix me, integer row);
# 221 "../fon/Sound.h"
extern autoSound Sound_clipboard;



autoSound Sound_record_fixedTime (int inputSource,
 double gain, double balance, double samplingFrequency, double duration);
# 262 "../fon/Sound.h"
typedef MelderCallback <int, structThing , int , double , double , double > Sound_PlayCallback;

void Sound_playPart (Sound me, double tmin, double tmax, Sound_PlayCallback playCallback, Thing playBoss);
# 297 "../fon/Sound.h"
void Sound_play (Sound me, Sound_PlayCallback playCallback, Thing playBoss);






void Sound_saveAsAudioFile (Sound me, MelderFile file, int audioFileType, int numberOfBitsPerSamplePoint);
void Sound_saveAsKayFile (Sound me, MelderFile file);
void Sound_saveAsSesamFile (Sound me, MelderFile file);

autoSound Sound_readFromSoundFile (MelderFile file);
autoSound Sound_readFromKayFile (MelderFile file);
autoSound Sound_readFromSesamFile (MelderFile file);
autoSound Sound_readFromBellLabsFile (MelderFile file);
autoSound Sound_readFromRawAlawFile (MelderFile file);
autoSound Sound_readFromMovieFile (MelderFile file);

autoSound Sound_readFromRawSoundFile (MelderFile file, int encoding, int numberOfChannels, double sampleRate);
# 327 "../fon/Sound.h"
void Sound_saveAsRawSoundFile (Sound me, MelderFile file, int encoding);
# 339 "../fon/Sound.h"
autoSound Sound_lengthen_overlapAdd (Sound me, double fmin, double fmax, double factor);
autoSound Sound_deepenBandModulation (Sound me, double enhancement_dB,
 double flow, double fhigh, double slowModulation, double fastModulation, double bandSmoothing);




typedef struct structSoundList *SoundList; typedef autoSomeThing <structSoundList> autoSoundList; extern struct structClassInfo theClassInfo_SoundList; extern ClassInfo classSoundList; static inline autoSoundList SoundList_create () { return Thing_newFromClass (classSoundList).static_cast_move<structSoundList>(); } struct structSoundList : OrderedOf<structSound> {
};
# 23 "../fon/FormantGrid.h" 2
# 1 "../fon/Formant.h" 1
# 22 "../fon/Formant.h"
# 1 "../stat/Table.h" 1
# 23 "../fon/Formant.h" 2
typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;

# 1 "../fon/Formant_enums.h" 1
# 19 "../fon/Formant_enums.h"
enum class kFormant_unit { UNDEFINED = -1, MIN = 0,
 HERTZ = 0,
 BARK = 1,
MAX = 1, DEFAULT = HERTZ }; conststring32 kFormant_unit_getText (kFormant_unit value); kFormant_unit kFormant_unit_getValue (conststring32 text); inline static kFormant_unit& operator++ (kFormant_unit& value) { value = static_cast <kFormant_unit> (static_cast <int> (value) + 1); return value; }
# 26 "../fon/Formant.h" 2
# 1 "../fon/Formant_def.h" 1
# 21 "../fon/Formant_def.h"
typedef struct structFormant_Formant *Formant_Formant; struct structFormant_Formant {
# 32 "../fon/Formant_def.h"
  double frequency;
  double bandwidth;


void destroy (); void copy (Formant_Formant data_to); bool equal (Formant_Formant otherData); Data_Description description (); static Data_Description s_description; bool canWriteAsEncoding (int outputEncoding); void writeText (MelderFile openFile); void readText (MelderReadText text, int formatVersion); void writeBinary (FILE *f); void readBinary (FILE *f, int formatVersion); };





typedef struct structFormant_Frame *Formant_Frame; struct structFormant_Frame {


  double intensity;


 integer numberOfFormants;
 autovector <structFormant_Formant> formant;

void destroy (); void copy (Formant_Frame data_to); bool equal (Formant_Frame otherData); Data_Description description (); static Data_Description s_description; bool canWriteAsEncoding (int outputEncoding); void writeText (MelderFile openFile); void readText (MelderReadText text, int formatVersion); void writeBinary (FILE *f); void readBinary (FILE *f, int formatVersion); };





typedef struct structFormant *Formant; typedef autoSomeThing <structFormant> autoFormant; typedef structSampled Formant_Parent; extern struct structClassInfo theClassInfo_Formant; extern ClassInfo classFormant; struct structFormant : public structSampled {

 int16 maxnFormants;
 autovector <structFormant_Frame> frames;


  void v_info ()
   override;
  int v_domainQuantity ()
   override { return 1; }
  double v_getValueAtSample (integer iframe, integer which, int units)
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 27 "../fon/Formant.h" 2

autoFormant Formant_create (double tmin, double tmax, integer nt, double dt, double t1, integer maximumNumberOfFormants);
# 48 "../fon/Formant.h"
integer Formant_getMinNumFormants (Formant me);
integer Formant_getMaxNumFormants (Formant me);

double Formant_getValueAtTime (Formant me, integer formantNumber, double time, kFormant_unit unit);
double Formant_getBandwidthAtTime (Formant me, integer formantNumber, double time, kFormant_unit unit);

void Formant_getExtrema (Formant me, integer formantNumber, double tmin, double tmax, double *fmin, double *fmax);
void Formant_getMinimumAndTime (Formant me, integer formantNumber, double tmin, double tmax, kFormant_unit unit, int interpolate,
 double *return_minimum, double *return_timeOfMinimum);
void Formant_getMaximumAndTime (Formant me, integer formantNumber, double tmin, double tmax, kFormant_unit unit, int interpolate,
 double *return_maximum, double *return_timeOfMaximum);
double Formant_getMinimum (Formant me, integer formantNumber, double tmin, double tmax, kFormant_unit unit, int interpolate);
double Formant_getMaximum (Formant me, integer formantNumber, double tmin, double tmax, kFormant_unit unit, int interpolate);
double Formant_getTimeOfMaximum (Formant me, integer formantNumber, double tmin, double tmax, kFormant_unit unit, int interpolate);
double Formant_getTimeOfMinimum (Formant me, integer formantNumber, double tmin, double tmax, kFormant_unit unit, int interpolate);

double Formant_getQuantile (Formant me, integer formantNumber, double quantile, double tmin, double tmax, kFormant_unit unit);
double Formant_getQuantileOfBandwidth (Formant me, integer formantNumber, double quantile, double tmin, double tmax, kFormant_unit unit);
double Formant_getMean (Formant me, integer formantNumber, double tmin, double tmax, kFormant_unit unit);
double Formant_getStandardDeviation (Formant me, integer formantNumber, double tmin, double tmax, kFormant_unit unit);

void Formant_sort (Formant me);

void Formant_drawTracks (Formant me, Graphics graphics, double tmin, double tmax, double fmax, bool garnish);
void Formant_drawSpeckles_inside (Formant me, Graphics graphics, double tmin, double tmax, double fmin, double fmax,
 double suppress_dB);
void Formant_drawSpeckles (Formant me, Graphics graphics, double tmin, double tmax, double fmax,
 double suppress_dB, bool garnish);
void Formant_scatterPlot (Formant me, Graphics graphics, double tmin, double tmax,
 integer iformant1, double fmin1, double fmax1, integer iformant2, double fmin2, double fmax2,
 double size_mm, conststring32 mark, bool garnish);

autoMatrix Formant_to_Matrix (Formant me, integer iformant);
autoMatrix Formant_to_Matrix_bandwidths (Formant me, integer iformant);
void Formant_formula_frequencies (Formant me, conststring32 formula, Interpreter interpreter);
void Formant_formula_bandwidths (Formant me, conststring32 formula, Interpreter interpreter);

autoFormant Formant_tracker (Formant me, integer numberOfTracks,
 double refF1, double refF2, double refF3, double refF4, double refF5,
 double dfCost,
 double bfCost, double octaveJumpCost);

autoTable Formant_downto_Table (Formant me, bool includeFrameNumbers,
 bool includeTimes, integer timeDecimals,
 bool includeIntensity, integer intensityDecimals,
 bool includeNumberOfFormants, integer frequencyDecimals,
 bool includeBandwidths);
void Formant_list (Formant me, bool includeFrameNumbers,
 bool includeTimes, integer timeDecimals,
 bool includeIntensity, integer intensityDecimals,
 bool includeNumberOfFormants, integer frequencyDecimals,
 bool includeBandwidths);
# 24 "../fon/FormantGrid.h" 2

typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;

# 1 "../fon/FormantGrid_def.h" 1
# 20 "../fon/FormantGrid_def.h"
typedef struct structFormantGrid *FormantGrid; typedef autoSomeThing <structFormantGrid> autoFormantGrid; typedef structFunction FormantGrid_Parent; extern struct structClassInfo theClassInfo_FormantGrid; extern ClassInfo classFormantGrid; struct structFormantGrid : public structFunction {

 OrderedOf<structRealTier> formants;
 OrderedOf<structRealTier> bandwidths;


  bool v_hasGetVector ()
   override { return true; }
  double v_getVector (integer irow, integer icol)
   override;
  bool v_hasGetFunction1 ()
   override { return true; }
  double v_getFunction1 (integer irow, double x)
   override;
  conststring32 v_getUnitText (integer ilevel, int , uint32 )
   override { return ilevel & 1 ? U"Formant (Hz)" : U"Bandwidth (Hz)"; }
  void v_shiftX (double xfrom, double xto)
   override;
  void v_scaleX (double xminfrom, double xmaxfrom, double xminto, double xmaxto)
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 28 "../fon/FormantGrid.h" 2

void FormantGrid_init (FormantGrid me, double tmin, double tmax, integer numberOfFormants);
autoFormantGrid FormantGrid_createEmpty (double tmin, double tmax, integer numberOfFormants);

autoFormantGrid FormantGrid_create (double tmin, double tmax, integer numberOfFormants,
 double initialFirstFormant, double initialFormantSpacing,
 double initialFirstBandwidth, double initialBandwidthSpacing);

double FormantGrid_getFormantAtTime (FormantGrid me, integer formantNumber, double time);
double FormantGrid_getBandwidthAtTime (FormantGrid me, integer formantNumber, double time);

void FormantGrid_addFormantPoint (FormantGrid me, integer formantNumber, double time, double value);
void FormantGrid_addBandwidthPoint (FormantGrid me, integer formantNumber, double time, double value);
void FormantGrid_removeFormantPointsBetween (FormantGrid me, integer formantNumber, double tmin, double tmax);
void FormantGrid_removeBandwidthPointsBetween (FormantGrid me, integer formantNumber, double tmin, double tmax);

void Sound_FormantGrid_filter_inplace (Sound me, FormantGrid formantGrid);
autoSound Sound_FormantGrid_filter (Sound me, FormantGrid formantGrid);
autoSound Sound_FormantGrid_filter_noscale (Sound me, FormantGrid formantGrid);

autoSound FormantGrid_to_Sound (FormantGrid me, double samplingFrequency,
 double tStart, double f0Start, double tMid, double f0Mid, double tEnd, double f0End,
 double adaptFactor, double maximumPeriod, double openPhase, double collisionPhase, double power1, double power2);
void FormantGrid_playPart (FormantGrid me, double tmin, double tmax, double samplingFrequency,
 double tStart, double f0Start, double tMid, double f0Mid, double tEnd, double f0End,
 double adaptFactor, double maximumPeriod, double openPhase, double collisionPhase, double power1, double power2,
 Sound_PlayCallback playCallback, Thing playBoss);

void FormantGrid_formula_frequencies (FormantGrid me, conststring32 expression, Interpreter interpreter, FormantGrid thee);
void FormantGrid_formula_bandwidths (FormantGrid me, conststring32 expression, Interpreter interpreter, FormantGrid thee);

autoFormantGrid Formant_downto_FormantGrid (Formant me);
autoFormant FormantGrid_to_Formant (FormantGrid me, double dt, double intensity);

autoSound Sound_Formant_filter (Sound me, Formant formant);
autoSound Sound_Formant_filter_noscale (Sound me, Formant formant);
# 47 "VowelEditor.cpp" 2
# 1 "KlattGrid.h" 1
# 22 "KlattGrid.h"
# 1 "../fon/PointProcess.h" 1
# 23 "KlattGrid.h" 2
# 1 "../fon/Sound.h" 1
# 24 "KlattGrid.h" 2
# 1 "../fon/IntensityTier.h" 1
# 22 "../fon/IntensityTier.h"
# 1 "../fon/Intensity.h" 1
# 33 "../fon/Intensity.h"
typedef struct structIntensity *Intensity; typedef autoSomeThing <structIntensity> autoIntensity; extern struct structClassInfo theClassInfo_Intensity; extern ClassInfo classIntensity; typedef structVector Intensity_Parent; struct structIntensity : public structVector {
 void v_info ()
  override;
 int v_domainQuantity ()
  override { return 1; }
 double v_convertStandardToSpecialUnit (double value, integer level, int unit)
  override;
 double v_convertSpecialToStandardUnit (double value, integer level, int unit)
  override;
};

autoIntensity Intensity_create (double tmin, double tmax, integer nt, double dt, double t1);

void Intensity_init (Intensity me, double tmin, double tmax, integer nt, double dt, double t1);

autoMatrix Intensity_to_Matrix (Intensity me);

autoIntensity Matrix_to_Intensity (Matrix me);

void Intensity_drawInside (Intensity me, Graphics g, double tmin, double tmax,
 double minimum, double maximum);

void Intensity_draw (Intensity me, Graphics g, double tmin, double tmax,
 double minimum, double maximum, bool garnish);

double Intensity_getQuantile (Intensity me, double tmin, double tmax, double quantile);
# 68 "../fon/Intensity.h"
double Intensity_getAverage (Intensity me, double tmin, double tmax, int averagingMethod);
# 23 "../fon/IntensityTier.h" 2



typedef struct structIntensityTier *IntensityTier; typedef autoSomeThing <structIntensityTier> autoIntensityTier; extern struct structClassInfo theClassInfo_IntensityTier; extern ClassInfo classIntensityTier; typedef structRealTier IntensityTier_Parent; struct structIntensityTier : public structRealTier {
 int v_domainQuantity ()
  override { return 1; }
};

autoIntensityTier IntensityTier_create (double tmin, double tmax);

void IntensityTier_draw (IntensityTier me, Graphics g, double tmin, double tmax,
 double ymin, double ymax, conststring32 method, int garnish);

autoIntensityTier PointProcess_upto_IntensityTier (PointProcess me, double intensity);
autoIntensityTier Intensity_downto_IntensityTier (Intensity me);
autoIntensityTier Intensity_to_IntensityTier_peaks (Intensity me);
autoIntensityTier Intensity_to_IntensityTier_valleys (Intensity me);
autoIntensityTier Intensity_PointProcess_to_IntensityTier (Intensity me, PointProcess pp);
autoIntensityTier IntensityTier_PointProcess_to_IntensityTier (IntensityTier me, PointProcess pp);
autoTableOfReal IntensityTier_downto_TableOfReal (IntensityTier me);
void Sound_IntensityTier_multiply_inplace (Sound me, IntensityTier intensity);
autoSound Sound_IntensityTier_multiply (Sound me, IntensityTier intensity, int scale);
# 25 "KlattGrid.h" 2
# 1 "../fon/PitchTier.h" 1
# 24 "../fon/PitchTier.h"
# 1 "../fon/Pitch.h" 1
# 24 "../fon/Pitch.h"
typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;

# 1 "../fon/Pitch_enums.h" 1
# 19 "../fon/Pitch_enums.h"
enum class kPitch_unit { UNDEFINED = -1, MIN = 0,
 HERTZ = 0,
 HERTZ_LOGARITHMIC = 1,
 MEL = 2,
 LOG_HERTZ = 3,
 SEMITONES_1 = 4,
 SEMITONES_100 = 5,
 SEMITONES_200 = 6,
 SEMITONES_440 = 7,
 ERB = 8,
MAX = 8, DEFAULT = HERTZ }; conststring32 kPitch_unit_getText (kPitch_unit value); kPitch_unit kPitch_unit_getValue (conststring32 text); inline static kPitch_unit& operator++ (kPitch_unit& value) { value = static_cast <kPitch_unit> (static_cast <int> (value) + 1); return value; }
# 27 "../fon/Pitch.h" 2
# 1 "../fon/Pitch_def.h" 1
# 44 "../fon/Pitch_def.h"
typedef struct structPitch_Candidate *Pitch_Candidate; struct structPitch_Candidate {

 double frequency;
 double strength;

void destroy (); void copy (Pitch_Candidate data_to); bool equal (Pitch_Candidate otherData); Data_Description description (); static Data_Description s_description; bool canWriteAsEncoding (int outputEncoding); void writeText (MelderFile openFile); void readText (MelderReadText text, int formatVersion); void writeBinary (FILE *f); void readBinary (FILE *f, int formatVersion); };




typedef struct structPitch_Frame *Pitch_Frame; struct structPitch_Frame {
# 68 "../fon/Pitch_def.h"
  double intensity;
  integer nCandidates;


 autovector <structPitch_Candidate> candidates;

void destroy (); void copy (Pitch_Frame data_to); bool equal (Pitch_Frame otherData); Data_Description description (); static Data_Description s_description; bool canWriteAsEncoding (int outputEncoding); void writeText (MelderFile openFile); void readText (MelderReadText text, int formatVersion); void writeBinary (FILE *f); void readBinary (FILE *f, int formatVersion); };




typedef struct structPitch *Pitch; typedef autoSomeThing <structPitch> autoPitch; typedef structSampled Pitch_Parent; extern struct structClassInfo theClassInfo_Pitch; extern ClassInfo classPitch; struct structPitch : public structSampled {

 double ceiling;
 int16 maxnCandidates;
 autovector <structPitch_Frame> frames;


  void v_info ()
   override;
  int v_domainQuantity ()
   override { return 1; }
  int v_getMinimumUnit (integer level)
   override;
  int v_getMaximumUnit (integer level)
   override;
  conststring32 v_getUnitText (integer level, int unit, uint32 flags)
   override;
  bool v_isUnitLogarithmic (integer level, int unit)
   override;
  double v_convertStandardToSpecialUnit (double value, integer level, int unit)
   override;
  double v_convertSpecialToStandardUnit (double value, integer level, int unit)
   override;
  double v_getValueAtSample (integer sampleNumber, integer level, int unit)
   override;
  conststring32 v_getIndexText () const
   override { return U"frame number"; }
  conststring32 v_getNxText () const
   override { return U"the number of frames"; }


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 28 "../fon/Pitch.h" 2

autoPitch Pitch_create (double tmin, double tmax, integer nt, double dt, double t1,
 double ceiling, integer maxnCandidates);
# 53 "../fon/Pitch.h"
void Pitch_Frame_init (Pitch_Frame me, integer nCandidates);
# 66 "../fon/Pitch.h"
inline static bool Pitch_util_frequencyIsVoiced (double f, double ceiling) {
 return f > 0.0 && f < ceiling;
}

bool Pitch_isVoiced_i (Pitch me, integer index);
# 79 "../fon/Pitch.h"
bool Pitch_isVoiced_t (Pitch me, double t);
# 97 "../fon/Pitch.h"
double Pitch_getValueAtTime (Pitch me, double time, kPitch_unit unit, bool interpolate);
double Pitch_getStrengthAtTime (Pitch me, double time, kPitch_unit unit, bool interpolate);

integer Pitch_countVoicedFrames (Pitch me);

double Pitch_getMean (Pitch me, double tmin, double tmax, kPitch_unit unit);
double Pitch_getMeanStrength (Pitch me, double tmin, double tmax, int strengthUnit);
double Pitch_getQuantile (Pitch me, double tmin, double tmax, double quantile, kPitch_unit unit);
double Pitch_getStandardDeviation (Pitch me, double tmin, double tmax, kPitch_unit unit);
void Pitch_getMaximumAndTime (Pitch me, double tmin, double tmax, kPitch_unit unit, bool interpolate,
 double *return_maximum, double *return_timeOfMaximum);
double Pitch_getMaximum (Pitch me, double tmin, double tmax, kPitch_unit unit, bool interpolate);
double Pitch_getTimeOfMaximum (Pitch me, double tmin, double tmax, kPitch_unit unit, bool interpolate);
void Pitch_getMinimumAndTime (Pitch me, double tmin, double tmax, kPitch_unit unit, bool interpolate,
 double *return_minimum, double *return_timeOfMinimum);
double Pitch_getMinimum (Pitch me, double tmin, double tmax, kPitch_unit unit, bool interpolate);
double Pitch_getTimeOfMinimum (Pitch me, double tmin, double tmax, kPitch_unit unit, bool interpolate);

integer Pitch_getMaxnCandidates (Pitch me);




void Pitch_setCeiling (Pitch me, double ceiling);





autoMAT Pitch_Frame_getAllCandidates (Pitch_Frame me);
autoMAT Pitch_getAllCandidatesInFrame (Pitch me, integer frameNumber);

void Pitch_pathFinder (Pitch me, double silenceThreshold, double voicingThreshold,
 double octaveCost, double octaveJumpCost, double voicedUnvoicedCost,
 double ceiling, int pullFormants);




void Pitch_drawInside (Pitch me, Graphics g, double tmin, double tmax, double fmin, double fmax,
 bool speckle, kPitch_unit yscale);
void Pitch_draw (Pitch me, Graphics g, double tmin, double tmax, double fmin, double fmax, bool garnish,
 bool speckle, kPitch_unit yscale);





void Pitch_difference (Pitch me, Pitch thee);


integer Pitch_getMeanAbsSlope_hertz (Pitch me, double *slope);
integer Pitch_getMeanAbsSlope_mel (Pitch me, double *slope);
integer Pitch_getMeanAbsSlope_semitones (Pitch me, double *slope);
integer Pitch_getMeanAbsSlope_erb (Pitch me, double *slope);
integer Pitch_getMeanAbsSlope_noOctave (Pitch me, double *slope);
# 162 "../fon/Pitch.h"
autoPitch Pitch_killOctaveJumps (Pitch me);







autoPitch Pitch_interpolate (Pitch me);



autoPitch Pitch_subtractLinearFit (Pitch me, kPitch_unit unit);

autoPitch Pitch_smooth (Pitch me, double bandWidth);
# 194 "../fon/Pitch.h"
void Pitch_step (Pitch me, double step, double precision, double tmin, double tmax);
# 205 "../fon/Pitch.h"
void Pitch_formula (Pitch me, conststring32 formula, Interpreter interpreter);

autoVEC Pitch_listValuesInAllFrames (Pitch me);

autoTable Pitch_tabulateCandidatesInFrame (Pitch me, integer frameNumber);
autoTable Pitch_tabulateCandidates (Pitch me);
# 25 "../fon/PitchTier.h" 2



typedef struct structPitchTier *PitchTier; typedef autoSomeThing <structPitchTier> autoPitchTier; extern struct structClassInfo theClassInfo_PitchTier; extern ClassInfo classPitchTier; typedef structRealTier PitchTier_Parent; struct structPitchTier : public structRealTier {
 void v_info ()
  override;
 int v_domainQuantity ()
  override { return 1; }
};

autoPitchTier PitchTier_create (double tmin, double tmax);







void PitchTier_shiftFrequencies (PitchTier me, double tmin, double tmax, double shift, kPitch_unit units);
void PitchTier_multiplyFrequencies (PitchTier me, double tmin, double tmax, double factor);

void PitchTier_draw (PitchTier me, Graphics g, double tmin, double tmax,
 double fmin, double fmax, bool garnish, conststring32 method);

autoPitchTier PointProcess_upto_PitchTier (PointProcess me, double frequency);
void PitchTier_stylize (PitchTier me, double frequencyResolution, bool useSemitones);

void PitchTier_writeToPitchTierSpreadsheetFile (PitchTier me, MelderFile file);
void PitchTier_writeToHeaderlessSpreadsheetFile (PitchTier me, MelderFile file);
# 26 "KlattGrid.h" 2

# 1 "KlattTable.h" 1
# 30 "KlattTable.h"
typedef struct structKlattTable *KlattTable; typedef autoSomeThing <structKlattTable> autoKlattTable; extern struct structClassInfo theClassInfo_KlattTable; extern ClassInfo classKlattTable; typedef structTable KlattTable_Parent; struct structKlattTable : public structTable {
};

autoKlattTable KlattTable_create (double frameDuration, double totalDuration);
# 96 "KlattTable.h"
autoSound KlattTable_to_Sound (KlattTable me, double samplingFrequency, int synthesisModel, int numberOfFormants, double frameDuration, int voicing, double flutter, int outputType);

autoSound KlattTable_Sound_to_Sound (KlattTable me, Sound thee);

autoKlattTable KlattTable_createExample ();

autoKlattTable Table_to_KlattTable (Table me);

autoTable KlattTable_to_Table (KlattTable me);

autoKlattTable KlattTable_readFromRawTextFile (MelderFile fs);
# 28 "KlattGrid.h" 2
typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;

# 1 "KlattGrid_enums.h" 1
# 19 "KlattGrid_enums.h"
enum class kKlattGridFormantType { UNDEFINED = -1, MIN = 1,
 ORAL = 1,
 NASAL = 2,
 FRICATION = 3,
 TRACHEAL = 4,
 NASAL_ANTI = 5,
 TRACHEALANTI = 6,
 DELTA = 7,
MAX = 7, DEFAULT = ORAL }; conststring32 kKlattGridFormantType_getText (kKlattGridFormantType value); kKlattGridFormantType kKlattGridFormantType_getValue (conststring32 text); inline static kKlattGridFormantType& operator++ (kKlattGridFormantType& value) { value = static_cast <kKlattGridFormantType> (static_cast <int> (value) + 1); return value; }

enum class kKlattGridFilterModel { UNDEFINED = -1, MIN = 1,
 CASCADE = 1,
 PARALLEL = 2,
MAX = 2, DEFAULT = CASCADE }; conststring32 kKlattGridFilterModel_getText (kKlattGridFilterModel value); kKlattGridFilterModel kKlattGridFilterModel_getValue (conststring32 text); inline static kKlattGridFilterModel& operator++ (kKlattGridFilterModel& value) { value = static_cast <kKlattGridFilterModel> (static_cast <int> (value) + 1); return value; }
# 31 "KlattGrid.h" 2

# 1 "KlattGrid_def.h" 1
# 20 "KlattGrid_def.h"
typedef struct structPhonationPoint *PhonationPoint; typedef autoSomeThing <structPhonationPoint> autoPhonationPoint; typedef structAnyPoint PhonationPoint_Parent; extern struct structClassInfo theClassInfo_PhonationPoint; extern ClassInfo classPhonationPoint; struct structPhonationPoint : public structAnyPoint {

 double period;
 double openPhase;
 double collisionPhase;
 double te;
 double power1;
 double power2;
 double pulseScale;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structPhonationTier *PhonationTier; typedef autoSomeThing <structPhonationTier> autoPhonationTier; typedef structFunction PhonationTier_Parent; extern struct structClassInfo theClassInfo_PhonationTier; extern ClassInfo classPhonationTier; struct structPhonationTier : public structFunction {

 SortedSetOfDoubleOf<structPhonationPoint> points;


  AnyTier asAnyTier () { return reinterpret_cast <AnyTier> (this); } void v_shiftX (double xfrom, double xto) override { ((AnyTier) this) -> structAnyTier::v_shiftX (xfrom, xto); } void v_scaleX (double xminfrom, double xmaxfrom, double xminto, double xmaxto) override { ((AnyTier) this) -> structAnyTier::v_scaleX (xminfrom, xmaxfrom, xminto, xmaxto); };


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structPhonationGridPlayOptions *PhonationGridPlayOptions; typedef autoSomeThing <structPhonationGridPlayOptions> autoPhonationGridPlayOptions; typedef structDaata PhonationGridPlayOptions_Parent; extern struct structClassInfo theClassInfo_PhonationGridPlayOptions; extern ClassInfo classPhonationGridPlayOptions; struct structPhonationGridPlayOptions : public structDaata {

 int voicing;
 int aspiration;
 int breathiness;
 int flutter;
 int doublePulsing;
 int collisionPhase;
 int spectralTilt;
 int flowFunction;
 int flowDerivative;
 double maximumPeriod;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structPhonationGrid *PhonationGrid; typedef autoSomeThing <structPhonationGrid> autoPhonationGrid; typedef structFunction PhonationGrid_Parent; extern struct structClassInfo theClassInfo_PhonationGrid; extern ClassInfo classPhonationGrid; struct structPhonationGrid : public structFunction {

 autoPitchTier pitch;
 autoRealTier flutter;
 autoIntensityTier voicingAmplitude;
 autoRealTier doublePulsing;
 autoRealTier openPhase;
 autoRealTier collisionPhase;
 autoRealTier power1;
 autoRealTier power2;
 autoIntensityTier spectralTilt;
 autoIntensityTier aspirationAmplitude;
 autoIntensityTier breathinessAmplitude;


  autoPhonationGridPlayOptions options;
# 90 "KlattGrid_def.h"
  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structVocalTractGridPlayOptions *VocalTractGridPlayOptions; typedef autoSomeThing <structVocalTractGridPlayOptions> autoVocalTractGridPlayOptions; typedef structDaata VocalTractGridPlayOptions_Parent; extern struct structClassInfo theClassInfo_VocalTractGridPlayOptions; extern ClassInfo classVocalTractGridPlayOptions; struct structVocalTractGridPlayOptions : public structDaata {

 kKlattGridFilterModel filterModel;
 integer startOralFormant;
 integer endOralFormant;
 integer startNasalFormant;
 integer endNasalFormant;
 integer startNasalAntiFormant;
 integer endNasalAntiFormant;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structVocalTractGrid *VocalTractGrid; typedef autoSomeThing <structVocalTractGrid> autoVocalTractGrid; typedef structFunction VocalTractGrid_Parent; extern struct structClassInfo theClassInfo_VocalTractGrid; extern ClassInfo classVocalTractGrid; struct structVocalTractGrid : public structFunction {

 autoFormantGrid oral_formants;
 autoFormantGrid nasal_formants;
 autoFormantGrid nasal_antiformants;

 OrderedOf<structIntensityTier> oral_formants_amplitudes;
 OrderedOf<structIntensityTier> nasal_formants_amplitudes;


  autoVocalTractGridPlayOptions options;
# 133 "KlattGrid_def.h"
  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structCouplingGridPlayOptions *CouplingGridPlayOptions; typedef autoSomeThing <structCouplingGridPlayOptions> autoCouplingGridPlayOptions; typedef structDaata CouplingGridPlayOptions_Parent; extern struct structClassInfo theClassInfo_CouplingGridPlayOptions; extern ClassInfo classCouplingGridPlayOptions; struct structCouplingGridPlayOptions : public structDaata {

 integer startTrachealFormant;
 integer endTrachealFormant;
 integer startTrachealAntiFormant;
 integer endTrachealAntiFormant;
 integer startDeltaFormant;
 integer endDeltaFormant;
 integer startDeltaBandwidth;
 integer endDeltaBandwidth;
 int openglottis;
 double fadeFraction;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structCouplingGrid *CouplingGrid; typedef autoSomeThing <structCouplingGrid> autoCouplingGrid; typedef structFunction CouplingGrid_Parent; extern struct structClassInfo theClassInfo_CouplingGrid; extern ClassInfo classCouplingGrid; struct structCouplingGrid : public structFunction {

 autoFormantGrid tracheal_formants;
 autoFormantGrid tracheal_antiformants;
 OrderedOf<structIntensityTier> tracheal_formants_amplitudes;
 autoFormantGrid delta_formants;


  autoPhonationTier glottis;
  autoCouplingGridPlayOptions options;
# 179 "KlattGrid_def.h"
  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structFricationGridPlayOptions *FricationGridPlayOptions; typedef autoSomeThing <structFricationGridPlayOptions> autoFricationGridPlayOptions; typedef structDaata FricationGridPlayOptions_Parent; extern struct structClassInfo theClassInfo_FricationGridPlayOptions; extern ClassInfo classFricationGridPlayOptions; struct structFricationGridPlayOptions : public structDaata {

 integer startFricationFormant;
 integer endFricationFormant;
 int bypass;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structFricationGrid *FricationGrid; typedef autoSomeThing <structFricationGrid> autoFricationGrid; typedef structFunction FricationGrid_Parent; extern struct structClassInfo theClassInfo_FricationGrid; extern ClassInfo classFricationGrid; struct structFricationGrid : public structFunction {

 autoIntensityTier fricationAmplitude;
 autoFormantGrid frication_formants;
 OrderedOf<structIntensityTier> frication_formants_amplitudes;
 autoIntensityTier bypass;


  autoFricationGridPlayOptions options;
# 216 "KlattGrid_def.h"
  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structKlattGridPlayOptions *KlattGridPlayOptions; typedef autoSomeThing <structKlattGridPlayOptions> autoKlattGridPlayOptions; typedef structDaata KlattGridPlayOptions_Parent; extern struct structClassInfo theClassInfo_KlattGridPlayOptions; extern ClassInfo classKlattGridPlayOptions; struct structKlattGridPlayOptions : public structDaata {

 double samplingFrequency;
 int scalePeak;
 double xmin;
 double xmax;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structKlattGrid *KlattGrid; typedef autoSomeThing <structKlattGrid> autoKlattGrid; typedef structFunction KlattGrid_Parent; extern struct structClassInfo theClassInfo_KlattGrid; extern ClassInfo classKlattGrid; struct structKlattGrid : public structFunction {

 autoPhonationGrid phonation;
 autoVocalTractGrid vocalTract;
 autoCouplingGrid coupling;
 autoFricationGrid frication;
 autoIntensityTier gain;


  autoKlattGridPlayOptions options;
# 255 "KlattGrid_def.h"
  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 33 "KlattGrid.h" 2



autoPhonationPoint PhonationPoint_create (double time, double period, double openPhase, double collisionPhase, double te,
 double power1, double power2, double pulseScale);

autoPhonationTier PhonationTier_create (double tmin, double tmax);
autoPointProcess PhonationTier_to_PointProcess_closures (PhonationTier me);



autoPhonationGrid PhonationGrid_create (double tmin, double tmax);
autoPhonationGridPlayOptions PhonationGridPlayOptions_create ();
void PhonationGrid_setNames (PhonationGrid me);

autoSound PhonationGrid_to_Sound_aspiration (PhonationGrid me, double samplingFrequency);

void PhonationGrid_draw (PhonationGrid me, Graphics g);

double PhonationGrid_getMaximumPeriod (PhonationGrid me);

autoPhonationTier PhonationGrid_to_PhonationTier (PhonationGrid me);



autoVocalTractGrid VocalTractGrid_create (double tmin, double tmax, integer numberOfFormants,
 integer numberOfNasalFormants, integer numberOfNasalAntiFormants);
autoVocalTractGridPlayOptions VocalTractGridPlayOptions_create ();
void VocalTractGrid_setNames (VocalTractGrid me);
void VocalTractGrid_draw (VocalTractGrid me, Graphics g, kKlattGridFilterModel filterModel);



autoCouplingGrid CouplingGrid_create (double tmin, double tmax, integer numberOfTrachealFormants, integer numberOfTrachealAntiFormants, integer numberOfDeltaFormants);
autoCouplingGridPlayOptions CouplingGridPlayOptions_create ();
void CouplingGrid_setNames (CouplingGrid me);
double CouplingGrid_getDeltaFormantAtTime (CouplingGrid me, integer iformant, double t);
double CouplingGrid_getDeltaBandwidthAtTime (CouplingGrid me, integer iformant, double t);



void FormantGrid_CouplingGrid_updateOpenPhases (FormantGrid me, CouplingGrid thee);



void Sound_FormantGrid_filterWithOneFormant_inplace (Sound me, FormantGrid thee, integer iformant);
void Sound_FormantGrid_filterWithOneAntiFormant_inplace (Sound me, FormantGrid thee, integer iformant);
void Sound_FormantGrid_Intensities_filterWithOneFormant_inplace (Sound me, FormantGrid thee, OrderedOf<structIntensityTier>* amplitudes, integer iformant);
autoSound Sound_FormantGrid_Intensities_filter (Sound me, FormantGrid thee, OrderedOf<structIntensityTier>* amplitudes, integer iformantb, integer iformante, int alternatingSign);



autoFricationGrid FricationGrid_create (double tmin, double tmax, integer numberOfFormants);
autoFricationGridPlayOptions FricationGridPlayOptions_create ();
void FricationGrid_setNames (FricationGrid me);
void FricationGrid_draw (FricationGrid me, Graphics g);

autoSound FricationGrid_to_Sound (FricationGrid me, double samplingFrequency);

autoSound Sound_FricationGrid_filter (Sound me, FricationGrid thee);



autoSound Sound_VocalTractGrid_CouplingGrid_filter (Sound me, VocalTractGrid thee, CouplingGrid coupling);



autoKlattGrid KlattGrid_create (double tmin, double tmax, integer numberOfFormants,
 integer numberOfNasalFormants, integer numberOfNasalAntiFormants,
 integer numberOfTrachealFormants, integer numberOfTrachealAntiFormants,
 integer numberOfFricationFormants, integer numberOfDeltaFormants);

autoKlattGrid KlattGrid_createFromVowel (double duration, double f0start, double f1, double b1, double f2, double b2, double f3, double b3, double f4, double bandWidthFraction, double formantFrequencyInterval);

autoKlattGrid KlattGrid_createExample ();
autoKlattGridPlayOptions KlattGridPlayOptions_create ();
void KlattGrid_setNames (KlattGrid me);
autoKlattGrid KlattTable_to_KlattGrid (KlattTable me, double frameDuration);

void KlattGrid_draw (KlattGrid me, Graphics g, kKlattGridFilterModel filterModel);
void klattGrid_drawPhonation (KlattGrid me, Graphics g);
void KlattGrid_drawVocalTract (KlattGrid me, Graphics g, kKlattGridFilterModel filterModel, int withTrachea);

conststring32 KlattGrid_getFormantName (kKlattGridFormantType formantType);
# 127 "KlattGrid.h"
double KlattGrid_getPitchAtTime (KlattGrid me, double t); void KlattGrid_addPitchPoint (KlattGrid me, double t, double value); void KlattGrid_removePitchPoints (KlattGrid me, double t1, double t2); autoPitchTier KlattGrid_extractPitchTier (KlattGrid me); void KlattGrid_replacePitchTier (KlattGrid me, PitchTier thee);
double KlattGrid_getFlutterAtTime (KlattGrid me, double t); void KlattGrid_addFlutterPoint (KlattGrid me, double t, double value); void KlattGrid_removeFlutterPoints (KlattGrid me, double t1, double t2); autoRealTier KlattGrid_extractFlutterTier (KlattGrid me); void KlattGrid_replaceFlutterTier (KlattGrid me, RealTier thee);
double KlattGrid_getDoublePulsingAtTime (KlattGrid me, double t); void KlattGrid_addDoublePulsingPoint (KlattGrid me, double t, double value); void KlattGrid_removeDoublePulsingPoints (KlattGrid me, double t1, double t2); autoRealTier KlattGrid_extractDoublePulsingTier (KlattGrid me); void KlattGrid_replaceDoublePulsingTier (KlattGrid me, RealTier thee);
double KlattGrid_getOpenPhaseAtTime (KlattGrid me, double t); void KlattGrid_addOpenPhasePoint (KlattGrid me, double t, double value); void KlattGrid_removeOpenPhasePoints (KlattGrid me, double t1, double t2); autoRealTier KlattGrid_extractOpenPhaseTier (KlattGrid me); void KlattGrid_replaceOpenPhaseTier (KlattGrid me, RealTier thee);
double KlattGrid_getCollisionPhaseAtTime (KlattGrid me, double t); void KlattGrid_addCollisionPhasePoint (KlattGrid me, double t, double value); void KlattGrid_removeCollisionPhasePoints (KlattGrid me, double t1, double t2); autoRealTier KlattGrid_extractCollisionPhaseTier (KlattGrid me); void KlattGrid_replaceCollisionPhaseTier (KlattGrid me, RealTier thee);
double KlattGrid_getSpectralTiltAtTime (KlattGrid me, double t); void KlattGrid_addSpectralTiltPoint (KlattGrid me, double t, double value); void KlattGrid_removeSpectralTiltPoints (KlattGrid me, double t1, double t2); autoIntensityTier KlattGrid_extractSpectralTiltTier (KlattGrid me); void KlattGrid_replaceSpectralTiltTier (KlattGrid me, IntensityTier thee);
double KlattGrid_getPower1AtTime (KlattGrid me, double t); void KlattGrid_addPower1Point (KlattGrid me, double t, double value); void KlattGrid_removePower1Points (KlattGrid me, double t1, double t2); autoRealTier KlattGrid_extractPower1Tier (KlattGrid me); void KlattGrid_replacePower1Tier (KlattGrid me, RealTier thee);
double KlattGrid_getPower2AtTime (KlattGrid me, double t); void KlattGrid_addPower2Point (KlattGrid me, double t, double value); void KlattGrid_removePower2Points (KlattGrid me, double t1, double t2); autoRealTier KlattGrid_extractPower2Tier (KlattGrid me); void KlattGrid_replacePower2Tier (KlattGrid me, RealTier thee);
double KlattGrid_getVoicingAmplitudeAtTime (KlattGrid me, double t); void KlattGrid_addVoicingAmplitudePoint (KlattGrid me, double t, double value); void KlattGrid_removeVoicingAmplitudePoints (KlattGrid me, double t1, double t2); autoIntensityTier KlattGrid_extractVoicingAmplitudeTier (KlattGrid me); void KlattGrid_replaceVoicingAmplitudeTier (KlattGrid me, IntensityTier thee);
double KlattGrid_getAspirationAmplitudeAtTime (KlattGrid me, double t); void KlattGrid_addAspirationAmplitudePoint (KlattGrid me, double t, double value); void KlattGrid_removeAspirationAmplitudePoints (KlattGrid me, double t1, double t2); autoIntensityTier KlattGrid_extractAspirationAmplitudeTier (KlattGrid me); void KlattGrid_replaceAspirationAmplitudeTier (KlattGrid me, IntensityTier thee);
double KlattGrid_getBreathinessAmplitudeAtTime (KlattGrid me, double t); void KlattGrid_addBreathinessAmplitudePoint (KlattGrid me, double t, double value); void KlattGrid_removeBreathinessAmplitudePoints (KlattGrid me, double t1, double t2); autoIntensityTier KlattGrid_extractBreathinessAmplitudeTier (KlattGrid me); void KlattGrid_replaceBreathinessAmplitudeTier (KlattGrid me, IntensityTier thee);
# 148 "KlattGrid.h"
double KlattGrid_getFormantAtTime (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t); void KlattGrid_addFormantPoint (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t, double value); void KlattGrid_removeFormantPoints (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t1, double t2); double KlattGrid_getDeltaFormantAtTime (KlattGrid me, integer iformant, double t); void KlattGrid_addDeltaFormantPoint (KlattGrid me, integer iformant, double t, double value); void KlattGrid_removeDeltaFormantPoints (KlattGrid me, integer iformant, double t1, double t2);
double KlattGrid_getBandwidthAtTime (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t); void KlattGrid_addBandwidthPoint (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t, double value); void KlattGrid_removeBandwidthPoints (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t1, double t2); double KlattGrid_getDeltaBandwidthAtTime (KlattGrid me, integer iformant, double t); void KlattGrid_addDeltaBandwidthPoint (KlattGrid me, integer iformant, double t, double value); void KlattGrid_removeDeltaBandwidthPoints (KlattGrid me, integer iformant, double t1, double t2);

void KlattGrid_formula_frequencies (KlattGrid me, kKlattGridFormantType formantType, conststring32 expression, Interpreter interpreter);
void KlattGrid_formula_bandwidths (KlattGrid me, kKlattGridFormantType formantType, conststring32 expression, Interpreter interpreter);
void KlattGrid_formula_amplitudes (KlattGrid me, kKlattGridFormantType formantType, conststring32 expression, Interpreter interpreter);

autoFormantGrid KlattGrid_extractFormantGrid (KlattGrid me, kKlattGridFormantType formantType);
void KlattGrid_replaceFormantGrid (KlattGrid me, kKlattGridFormantType formantType, FormantGrid thee);

autoFormantGrid KlattGrid_extractDeltaFormantGrid (KlattGrid me);
void KlattGrid_replaceDeltaFormantGrid (KlattGrid me, FormantGrid thee);

autoFormantGrid KlattGrid_to_oralFormantGrid_openPhases (KlattGrid me, double fadeFraction);
autoPointProcess KlattGrid_extractPointProcess_glottalClosures (KlattGrid me);

double KlattGrid_getAmplitudeAtTime (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t);
void KlattGrid_addAmplitudePoint (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t, double value);
void KlattGrid_removeAmplitudePoints (KlattGrid me, kKlattGridFormantType formantType, integer iformant, double t1, double t2);
autoIntensityTier KlattGrid_extractAmplitudeTier (KlattGrid me, kKlattGridFormantType formantType, integer iformant);
void KlattGrid_replaceAmplitudeTier (KlattGrid me, kKlattGridFormantType formantType, integer iformant, IntensityTier thee);

double KlattGrid_getFricationAmplitudeAtTime (KlattGrid me, double t);
void KlattGrid_addFricationAmplitudePoint (KlattGrid me, double t, double value);
void KlattGrid_removeFricationAmplitudePoints (KlattGrid me, double t1, double t2);
autoIntensityTier KlattGrid_extractFricationAmplitudeTier (KlattGrid me);
void KlattGrid_replaceFricationAmplitudeTier (KlattGrid me, IntensityTier thee);

double KlattGrid_getFricationBypassAtTime (KlattGrid me, double t);
void KlattGrid_addFricationBypassPoint (KlattGrid me, double t, double value);
void KlattGrid_removeFricationBypassPoints (KlattGrid me, double t1, double t2);
autoIntensityTier KlattGrid_extractFricationBypassTier (KlattGrid me);
void KlattGrid_replaceFricationBypassTier (KlattGrid me, IntensityTier thee);

void KlattGrid_setGlottisCoupling (KlattGrid me);

autoFormantGrid * KlattGrid_getAddressOfFormantGrid (KlattGrid me, kKlattGridFormantType formantType);
OrderedOf<structIntensityTier>* KlattGrid_getAddressOfAmplitudes (KlattGrid me, kKlattGridFormantType formantType);





void KlattGrid_addFormantFrequencyAndBandwidthTiers (KlattGrid me, kKlattGridFormantType formantType, integer position);
void KlattGrid_removeFormantFrequencyAndBandwidthTiers (KlattGrid me, kKlattGridFormantType formantType, integer position);
void KlattGrid_addFormantAmplitudeTier (KlattGrid me, kKlattGridFormantType formantType, integer position);
void KlattGrid_removeFormantAmplitudeTier (KlattGrid me, kKlattGridFormantType formantType, integer position);
# 203 "KlattGrid.h"
void KlattGrid_addFormant (KlattGrid me, kKlattGridFormantType formantType, integer position);
void KlattGrid_removeFormant (KlattGrid me, kKlattGridFormantType formantType, integer position);




void KlattGrid_play (KlattGrid me);

void KlattGrid_playSpecial (KlattGrid me);

void KlattGrid_setDefaultPlayOptions (KlattGrid me);

autoSound KlattGrid_to_Sound (KlattGrid me);

autoSound KlattGrid_to_Sound_phonation (KlattGrid me);

int KlattGrid_synthesize (KlattGrid me, double t1, double t2, double samplingFrequency, double maximumPeriod);






autoSound Sound_KlattGrid_filterByVocalTract (Sound me, KlattGrid thee, kKlattGridFilterModel filterModel);

autoSound Sound_KlattGrid_filter_frication (Sound me, KlattGrid thee);

autoKlattGrid Sound_to_KlattGrid_simple (Sound me, double timeStep, integer maximumNumberOfFormants, double maximumFormantFrequency, double windowLength, double preEmphasisFrequency, double minimumPitch, double maximumPitch, double minimumPitchIntensity, int subtractMean);
# 48 "VowelEditor.cpp" 2
# 1 "../fon/PitchTier_to_Sound.h" 1
# 19 "../fon/PitchTier_to_Sound.h"
# 1 "../fon/PitchTier.h" 1
# 20 "../fon/PitchTier_to_Sound.h" 2


autoSound PitchTier_to_Sound_pulseTrain (PitchTier me, double samplingFrequency,
  double adaptFactor, double adaptTime, integer interpolationDepth,
  bool hum);
autoSound PitchTier_to_Sound_phonation (PitchTier me, double samplingFrequency,
  double adaptFactor, double maximumPeriod,
  double openPhase, double collisionPhase, double power1, double power2,
  bool hum);
void PitchTier_playPart (PitchTier me, double tmin, double tmax, bool hum);
void PitchTier_play (PitchTier me);
void PitchTier_hum (PitchTier me);

autoSound PitchTier_to_Sound_sine (PitchTier me, double tmin, double tmax, double samplingFrequency);
void PitchTier_playPart_sine (PitchTier me, double tmin, double tmax);
# 49 "VowelEditor.cpp" 2
# 1 "../fon/Polygon.h" 1
# 24 "../fon/Polygon.h"
# 1 "../fon/Polygon_def.h" 1
# 21 "../fon/Polygon_def.h"
typedef struct structPolygon *Polygon; typedef autoSomeThing <structPolygon> autoPolygon; typedef structDaata Polygon_Parent; extern struct structClassInfo theClassInfo_Polygon; extern ClassInfo classPolygon; struct structPolygon : public structDaata {

 integer numberOfPoints;
# 34 "../fon/Polygon_def.h"
  autovector <double> x;
  autovector <double> y;



  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 25 "../fon/Polygon.h" 2

autoPolygon Polygon_create (integer numberOfPoints);
# 42 "../fon/Polygon.h"
void Polygon_randomize (Polygon me);

double Polygon_perimeter (Polygon me);

void Polygon_salesperson (Polygon me, integer numberOfIterations);
# 60 "../fon/Polygon.h"
void Polygon_draw (Polygon me, Graphics g, double xmin, double xmax, double ymin, double ymax);
void Polygon_drawClosed (Polygon me, Graphics g, double xmin, double xmax, double ymin, double ymax);

void Polygon_paint (Polygon me, Graphics g, MelderColour colour, double xmin, double xmax, double ymin, double ymax);

void Polygon_drawCircles (Polygon me, Graphics g,
 double xmin, double xmax, double ymin, double ymax, double diameter_mm);

void Polygon_paintCircles (Polygon me, Graphics g,
 double xmin, double xmax, double ymin, double ymax, double diameter_mm);

void Polygons_drawConnection (Polygon me, Polygon thee, Graphics g,
 double xmin, double xmax, double ymin, double ymax, int hasArrow, double relativeLength);
# 50 "VowelEditor.cpp" 2
# 1 "../sys/Preferences.h" 1
# 39 "../sys/Preferences.h"
void Preferences_addByte (conststring32 string , signed char *value, signed char defaultValue);
void Preferences_addShort (conststring32 string , short *value, short defaultValue);
void Preferences_addInt16 (conststring32 string , int *value, int defaultValue);
void Preferences_addInt (conststring32 string , int *value, int defaultValue);
void Preferences_addInteger (conststring32 string , integer *value, integer defaultValue);
void Preferences_addUbyte (conststring32 string , unsigned char *value, unsigned char defaultValue);
void Preferences_addUshort (conststring32 string , unsigned short *value, unsigned short defaultValue);
void Preferences_addUint (conststring32 string , unsigned int *value, unsigned int defaultValue);
void Preferences_addUinteger (conststring32 string , uinteger *value, uinteger defaultValue);
void Preferences_addBool (conststring32 string , bool *value, bool defaultValue);
void Preferences_addDouble (conststring32 string , double *value, double defaultValue);
void Preferences_addString (conststring32 string , char32 *value, conststring32 defaultValue);
void _Preferences_addEnum (conststring32 string , int *value, int min, int max,
 conststring32 (*getText) (int value), int (*getValue) (conststring32 text), int defaultValue);




void Preferences_read (MelderFile file);
void Preferences_write (MelderFile file);

void Preferences_exit_optimizeByLeaking ();
# 51 "VowelEditor.cpp" 2
# 1 "TableOfReal_extensions.h" 1
# 21 "TableOfReal_extensions.h"
# 1 "Categories.h" 1
# 21 "Categories.h"
# 1 "../dwsys/Collection_extensions.h" 1
# 23 "../dwsys/Collection_extensions.h"
# 1 "../dwsys/Permutation.h" 1
# 23 "../dwsys/Permutation.h"
# 1 "../dwsys/Permutation_def.h" 1
# 21 "../dwsys/Permutation_def.h"
typedef struct structPermutation *Permutation; typedef autoSomeThing <structPermutation> autoPermutation; typedef structDaata Permutation_Parent; extern struct structClassInfo theClassInfo_Permutation; extern ClassInfo classPermutation; struct structPermutation : public structDaata {

 integer numberOfElements;
 autovector <integer> p;


  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 24 "../dwsys/Permutation.h" 2





void Permutation_init (Permutation me, integer numberOfElements);

void Permutation_tableJump_inline (Permutation me, integer jumpSize, integer first);

autoPermutation Permutation_create (integer numberOfElements);





void Permutation_checkInvariant (Permutation me);



void Permutation_sort (Permutation me);


void Permutation_permuteRandomly_inplace (Permutation me, integer from, integer to);

autoPermutation Permutation_permuteRandomly (Permutation me, integer from, integer to);


autoPermutation Permutation_rotate (Permutation me, integer from, integer to, integer step);

void Permutation_swapOneFromRange (Permutation me, integer from, integer to, integer pos, bool forbidsame);



void Permutation_swapBlocks (Permutation me, integer from, integer to, integer blocksize);


void Permutation_swapPositions (Permutation me, integer i1, integer i2);

void Permutation_swapNumbers (Permutation me, integer i1, integer i2);

autoPermutation Permutation_interleave (Permutation me, integer from, integer to, integer blocksize, integer offset);

autoPermutation Permutation_permuteBlocksRandomly (Permutation me, integer from, integer to, integer blocksize, bool permuteWithinBlocks, bool noDoublets);



integer Permutation_getValueAtIndex (Permutation me, integer i);


integer Permutation_getIndexAtValue (Permutation me, integer value);


autoPermutation Permutation_invert (Permutation me);


void Permutation_reverse_inline (Permutation me, integer from, integer to);
autoPermutation Permutation_reverse (Permutation me, integer from, integer to);


void Permutation_next_inplace (Permutation me);

void Permutation_previous_inplace (Permutation me);

autoPermutation Permutations_multiply2 (Permutation me, Permutation thee);

autoPermutation Permutations_multiply (OrderedOf<structPermutation>* me);
# 24 "../dwsys/Collection_extensions.h" 2

autoCollection Collection_Permutation_permuteItems (Collection me, Permutation him);

autoCollection Collection_permuteItems (Collection me);


int OrderedOfString_append (StringList me, conststring32 append);

autoStringList OrderedOfString_joinItems (StringList me, StringList thee);


autoStringSet StringList_to_StringSet (StringList me);

double OrderedOfString_getFractionDifferent (StringList me, StringList thee);

integer OrderedOfString_getNumberOfDifferences (StringList me, StringList thee);

integer OrderedOfString_indexOfItem_c (StringList me, conststring32 str);

void OrderedOfString_initWithSequentialNumbers (StringList me, integer n);

void OrderedOfString_removeOccurrences (StringList me, conststring32 search, bool use_regexp);

void OrderedOfString_changeStrings (StringList me, char32 *search, char32 *replace,
 integer maximumNumberOfReplaces, integer *out_numberOfMatches, integer *out_numberOfStringmatches, bool use_regexp);

bool OrderedOfString_containSameElements (StringList me, StringList thee);
# 22 "Categories.h" 2



typedef struct structCategories *Categories; typedef autoSomeThing <structCategories> autoCategories; extern struct structClassInfo theClassInfo_Categories; extern ClassInfo classCategories; typedef structStringList Categories_Parent; struct structCategories : public structStringList {
 void v_info ()
  override;
 void v_readText (MelderReadText text, int formatVersion)
  override;
 void v_writeText (MelderFile file)
  override;
};

autoCategories Categories_create ();

autoCategories Categories_createWithSequentialNumbers (integer n);

autoCategories Categories_selectUniqueItems (Categories me);

void Categories_drawItem (Categories me, Graphics g, integer position, double xWC, double yWC);

autoCategories TableOfReal_to_CategoriesRow (TableOfReal me);

autoCategories TableOfReal_to_CategoriesColumn (TableOfReal me);
# 22 "TableOfReal_extensions.h" 2

# 1 "../dwsys/Graphics_extensions.h" 1
# 22 "../dwsys/Graphics_extensions.h"
# 1 "../dwsys/Graphics_extensions_enums.h" 1
# 19 "../dwsys/Graphics_extensions_enums.h"
enum class kGraphicsMatrixCellDrawingOrder { UNDEFINED = -1, MIN = 1,
 ROWS = 1,
 COLUMNS = 2,
 INCREASING_VALUES = 3,
 DECREASING_VALUES = 4,
 RANDOM = 5,
MAX = 5, DEFAULT = RANDOM }; conststring32 kGraphicsMatrixCellDrawingOrder_getText (kGraphicsMatrixCellDrawingOrder value); kGraphicsMatrixCellDrawingOrder kGraphicsMatrixCellDrawingOrder_getValue (conststring32 text); inline static kGraphicsMatrixCellDrawingOrder& operator++ (kGraphicsMatrixCellDrawingOrder& value) { value = static_cast <kGraphicsMatrixCellDrawingOrder> (static_cast <int> (value) + 1); return value; }

enum class kGraphicsMatrixOrigin { UNDEFINED = -1, MIN = 1,
 TOP_LEFT = 1,
 TOP_RIGHT = 2,
 BOTTOM_LEFT = 3,
 BOTTOM_RIGHT = 4,
MAX = 4, DEFAULT = BOTTOM_RIGHT }; conststring32 kGraphicsMatrixOrigin_getText (kGraphicsMatrixOrigin value); kGraphicsMatrixOrigin kGraphicsMatrixOrigin_getValue (conststring32 text); inline static kGraphicsMatrixOrigin& operator++ (kGraphicsMatrixOrigin& value) { value = static_cast <kGraphicsMatrixOrigin> (static_cast <int> (value) + 1); return value; }
# 23 "../dwsys/Graphics_extensions.h" 2






void Graphics_boxAndWhiskerPlot (Graphics g, constVEC data, double x, double r, double w, double ymin, double ymax);

void Graphics_quantileQuantilePlot (Graphics g, integer numberOfQuantiles, constVEC xdata, constVEC ydata,
 double xmin, double xmax, double ymin, double ymax, double labelSize, conststring32 plotLabel);

void Graphics_lagPlot (Graphics g, constVEC x, double xmin, double xmax, integer lag, double labelSize, conststring32 plotLabel);
# 24 "TableOfReal_extensions.h" 2
# 1 "Matrix_extensions.h" 1
# 26 "Matrix_extensions.h"
# 1 "../fon/Matrix.h" 1
# 27 "Matrix_extensions.h" 2
# 1 "../dwsys/Eigen.h" 1
# 24 "../dwsys/Eigen.h"
# 1 "../dwsys/Eigen_def.h" 1
# 20 "../dwsys/Eigen_def.h"
typedef struct structEigen *Eigen; typedef autoSomeThing <structEigen> autoEigen; typedef structDaata Eigen_Parent; extern struct structClassInfo theClassInfo_Eigen; extern ClassInfo classEigen; struct structEigen : public structDaata {

 integer numberOfEigenvalues;
 integer dimension;
 autovector <double> eigenvalues;
 automatrix <double> eigenvectors;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 25 "../dwsys/Eigen.h" 2

autoEigen Eigen_create (integer numberOfEigenvalues, integer dimension);

void Eigen_init (Eigen me, integer numberOfEigenvalues, integer dimension);

void Eigen_initFromSymmetricMatrix (Eigen me, constMATVU const& a);

void Eigen_initFromSquareRoot (Eigen me, constMATVU const& a);







void Eigen_initFromSquareRootPair (Eigen me, constMAT a, constMAT b);







integer Eigen_getNumberOfEigenvectors (Eigen me);

integer Eigen_getDimensionOfComponents (Eigen me);

double Eigen_getCumulativeContributionOfComponents (Eigen me, integer from, integer to);

integer Eigen_getDimensionOfFraction (Eigen me, double fraction);

double Eigen_getEigenvectorElement (Eigen me, integer ivec, integer element);

double Eigen_getSumOfEigenvalues (Eigen me, integer from, integer to);


void Eigen_sort (Eigen me);




void Eigen_invertEigenvector (Eigen me, integer ivec);

void Eigen_drawEigenvalues (Eigen me, Graphics g, integer first, integer last, double ymin, double ymax,
 bool fractionOfTotal, bool cumulative, double size_mm, conststring32 mark, bool garnish);

void Eigen_drawEigenvector (Eigen me, Graphics g, integer ivec, integer first, integer last, double minimum, double maximum, bool weigh,
 double size_mm, conststring32 mark, bool connect, char32 **rowLabels, bool garnish);
# 81 "../dwsys/Eigen.h"
void Eigens_alignEigenvectors (OrderedOf<structEigen>* me);

double Eigens_getAngleBetweenEigenplanes_degrees (Eigen me, Eigen thee);
# 28 "Matrix_extensions.h" 2


# 1 "../dwsys/SVD.h" 1
# 26 "../dwsys/SVD.h"
# 1 "../dwsys/NUM2.h" 1
# 27 "../dwsys/NUM2.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed/limits.h" 2 3 4
# 28 "../dwsys/NUM2.h" 2

# 1 "../dwsys/MAT_numerics.h" 1
       
# 22 "../dwsys/MAT_numerics.h"
void MAT_getEigenSystemFromSymmetricMatrix (constMAT a, autoMAT *out_eigenvectors, autoVEC *out_eigenvalues, bool sortAscending);
# 34 "../dwsys/MAT_numerics.h"
void MAT_getEigenSystemFromSymmetricMatrix_preallocated (MAT eigenvectors, VEC eigenvalues, constMATVU const& a, bool sortAscending);
# 47 "../dwsys/MAT_numerics.h"
void MAT_getEigenSystemFromGeneralSquareMatrix (constMAT const& inout_a, autoCOMPVEC *out_eigenvalues, automatrix<dcomplex> *out_eigenvectors);
# 62 "../dwsys/MAT_numerics.h"
void MAT_asPrincipalComponents_preallocated (MATVU pc, constMATVU const& m, integer numberOfComponents);
autoMAT MAT_asPrincipalComponents (constMATVU m, integer numberOfComponents);

void MATpseudoInverse (MATVU const& target, constMATVU const& mat, double tolerance);
autoMAT newMATpseudoInverse (constMATVU const& mat, double tolerance);
# 30 "../dwsys/NUM2.h" 2
# 39 "../dwsys/NUM2.h"
autoVEC newVECfromString (conststring32 s);







autoINTVEC NUMstring_getElementsOfRanges (conststring32 ranges, integer maximumElement, conststring32 elementType, bool sortedUniques);

char32 * NUMstring_timeNoDot (double time);

regexp *NUMregexp_compile (conststring32 regexp);


char32 *strstr_regexp (conststring32 string, conststring32 search_regexp);






autoSTRVEC string32vector_searchAndReplace (constSTRVEC me,
 conststring32 search, conststring32 replace, integer maximumNumberOfReplaces,
 integer *nmatches, integer *nstringmatches, bool use_regexp);
# 77 "../dwsys/NUM2.h"
void MATprintMatlabForm (constMATVU const& m, conststring32 name);
# 89 "../dwsys/NUM2.h"
inline bool NUMisNonNegative (constVECVU const& vec) {
 for (integer i = 1; i <= vec.size; i ++)
  if (vec [i] < 0.0)
   return false;
 return true;
}
inline bool NUMisNonNegative (constMATVU const& mat) {
 for (integer irow = 1; irow <= mat.nrow; irow ++)
  for (integer icol = 1; icol <= mat.ncol; icol ++)
   if (mat [irow] [icol] < 0.0)
    return false;
 return true;
}

inline integer NUMmaxPos (constVECVU const& v) {
 if (NUMisEmpty (v)) return 0;
 integer index = 1;
 double maximum = v [1];
 for (integer i = 2; i <= v.size; i ++) {
  if (v [i] > maximum) {
   maximum = v [i];
   index = i;
  }
 }
 return index;
}

inline integer NUMmaxPos (constINTVECVU const& v) {
 if (NUMisEmpty (v)) return 0;
 integer index = 1;
 integer maximum = v [1];
 for (integer i = 2; i <= v.size; i ++) {
  if (v [i] > maximum) {
   maximum = v [i];
   index = i;
  }
 }
 return index;
}

inline integer NUMminPos (constVECVU const& v) {
 if (NUMisEmpty (v)) return 0;
 integer index = 1;
 double minimum = v [1];
 for (integer i = 2; i <= v.size; i ++) {
  if (v [i] < minimum) {
   minimum = v [i];
   index = i;
  }
 }
 return index;
}

inline integer NUMminPos (constINTVECVU const& v) {
 if (NUMisEmpty (v))
  return 0;
 integer index = 1;
 integer minimum = v [1];
 for (integer i = 2; i <= v.size; i ++) {
  if (v [i] < minimum) {
   minimum = v [i];
   index = i;
  }
 }
 return index;
}

inline void NUMextrema (constVECVU const& x, double *out_minimum, double *out_maximum) {
 if (out_minimum)
  *out_minimum = NUMmin (x);
 if (out_maximum)
  *out_maximum = NUMmax (x);
}





inline void VECclip_inplace (VEC x, double min, double max) {
 for (integer i = 1; i <= x.size; i ++)
  Melder_clip (min, & x [i], max);
}

inline void VECabs (VECVU const& result, constVECVU const& v) {
 ((result.size == v.size) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 173, "result.size == v.size"), abort ()));
 for (integer i = 1; i <= result.size; i ++)
  result [i] = fabs (v [i]);
}

inline autoVEC newVECabs (constVECVU const& v) {
 autoVEC result = newVECraw (v.size);
 VECabs (result.get(), v);
 return result;
}

inline void VECabs_inplace (VECVU const& v) {
 for (integer i = 1; i <= v.size; i ++)
  v [i] = fabs (v [i]);
}

inline void INTVEClinear (INTVEC const& v, integer start, integer step) {
 for (integer i = 1; i <= v.size; i ++)
  v [i] = start + (i - 1) * step;
}

inline autoINTVEC newINTVEClinear (integer size, integer start, integer step) {
 autoINTVEC result = newINTVECraw (size);
 INTVEClinear (result, start, step);
 return result;
}

inline bool NUMhasZeroElement (constMATVU const m) {
 for (integer irow = 1; irow <= m.nrow; irow ++)
  for (integer icol = 1; icol <= m.ncol; icol++)
   if (m [irow][icol] == 0.0)
    return true;
 return false;
}

inline integer NUMcountNumberOfNonZeroElements (constVECVU const& v) {
 integer count = 0;
 for (integer i = 1; i <= v.size; i ++)
  if (v [i] != 0.0)
   ++ count;
 return count;
}

inline double NUMmul (constVECVU const& x, constMATVU const& m, constVECVU const& y) {
 ((x.size == m.nrow) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 217, "x.size == m.nrow"), abort ()));
 ((y.size == m.ncol) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 218, "y.size == m.ncol"), abort ()));
 longdouble result = 0.0;
 for (integer k = 1; k <= x.size; k ++)
  result += x [k] * NUMinner (m.row (k), y);
 return (double) result;
}

inline autoVEC VECnorm_rows (constMATVU const& x, double power) {
 autoVEC norm = newVECraw (x.nrow);
 for (integer irow = 1; irow <= norm.size; irow ++)
  norm [irow] = NUMnorm (x.row (irow), power);
 return norm;
}

inline void VECnormalize_inplace (VECVU const& vec, double power, double newNorm) {
 ((newNorm > 0.0) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 233, "newNorm > 0.0"), abort ()));
 double oldnorm = NUMnorm (vec, power);
 if (oldnorm > 0.0)
  vec *= newNorm / oldnorm;
}

inline void MATnormalize_inplace (MATVU const& mat, double power, double newNorm) {
 ((newNorm > 0.0) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 240, "newNorm > 0.0"), abort ()));
 double oldnorm = NUMnorm (mat, power);
 if (oldnorm > 0.0)
  mat *= newNorm / oldnorm;
}

inline void MATnormalizeRows_inplace (MATVU const& a, double power, double norm) {
 ((norm > 0.0) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 247, "norm > 0.0"), abort ()));
 for (integer irow = 1; irow <= a.nrow; irow ++)
  VECnormalize_inplace (a.row (irow), power, norm);
}

inline void MATnormalizeColumns_inplace (MATVU const& a, double power, double norm) {
 MATnormalizeRows_inplace (a.transpose(), power, norm);
}




void VECsmoothByMovingAverage_preallocated (VECVU const& out, constVECVU const& in, integer window);

autoMAT MATcovarianceFromColumnCentredMatrix (constMATVU const& x, integer ndf);






void MATmtm_weighRows (MATVU const& result, constMATVU const& data, constVECVU const& rowWeights);

inline autoMAT newMATmtm_weighRows (constMATVU const& data, constVECVU const& rowWeights) {
 autoMAT result = newMATraw (data.ncol, data.ncol);
 MATmtm_weighRows (result.get(), data, rowWeights);
 return result;
}

double NUMmultivariateKurtosis (constMATVU const& x, integer method);





void NUMmad (constVEC x, double *inout_location, bool wantlocation, double *out_mad, VEC const& workSpace);
# 294 "../dwsys/NUM2.h"
void NUMstatistics_huber (constVEC x, double *inout_location, bool wantlocation, double *inout_scale, bool wantscale, double k_stdev, double tol, integer maximumNumberOfiterations, VEC const& workSpace);
# 303 "../dwsys/NUM2.h"
autoVEC newVECmonotoneRegression (constVEC x);
# 326 "../dwsys/NUM2.h"
template<typename T1, typename T2>
void NUMsortTogether (vector<T1> a, vector<T2> b) {
 ((a.size == b.size) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 328, "a.size == b.size"), abort ()));
 T1 k, min;
 T2 kb, min2;
 if (a.size < 2) return;
 if (a.size == 2) {
  if (a [1] > a [2]) {
   min = a [2];
   a [2] = a [1];
   a [1] = min;
   min2 = b [2];
   b [2] = b [1];
   b [1] = min2;
  }
  return;
 }
 if (a.size <= 12) {
  for (integer i = 1; i < a.size; i ++) {
   min = a [i];
   integer imin = i;
   for (integer j = i + 1; j <= a.size; j ++)
    if (a [j] < min) {
     min = a [j];
     imin = j;
    }
   a [imin] = a [i];
   a [i] = min;
   min2 = b [imin];
   b [imin] = b [i];
   b [i] = min2;
  }
  return;
 }

 integer l = (a.size >> 1) + 1;
 integer r = a.size;
 for (;;) {
  if (l > 1) {
   l --;
   k = a [l];
   kb = b [l];
  } else {
   k = a [r];
   kb = b [r];
   a [r] = a [1];
   b [r] = b [1];
   r --;
   if (r == 1) {
    a [1] = k;
    b [1] = kb;
    return;
   }
  }

  integer i, j = l;
  for (;;) {
   i = j;
   j = j << 1;
   if (j > r) break;
   if (j < r && a [j] < a [j + 1]) j ++;

   a [i] = a [j];
   b [i] = b [j];
  }

  for (;;) {
   j = i;
   i = j >> 1;

   if (j == l || k <= a [i]) {
    a [j] = k;
    b [j] = kb;
    break;
   }
   a [j] = a [i];
   b [j] = b [i];
  }
 }
}

void VECsort3_inplace (VEC const& a, INTVEC const& iv1, INTVEC const& iv2, bool descending);


void INTVECindex (INTVEC const& target, constVEC const& a);
void INTVECindex (INTVEC const& target, constSTRVEC const& s);

inline autoINTVEC newINTVECindex (constVEC const& a) {
 autoINTVEC result = newINTVECraw (a.size);
 INTVECindex (result.get(), a);
 return result;
}

inline autoINTVEC newINTVECindex (constSTRVEC const& s) {
 autoINTVEC result = newINTVECraw (s.size);
 INTVECindex (result.get(), s);
 return result;
}

void MATrankColumns (MAT m, integer cb, integer ce);







inline void VECrankSorted (VECVU const& a) {
 integer jt, j = 1;
 while (j < a.size) {
  for (jt = j + 1; jt <= a.size && a [jt] == a [j]; jt ++) {}
  double rank = (j + jt - 1) * 0.5;
  for (integer i = j; i <= jt - 1; i ++)
   a [i] = rank;
  j = jt;
 }
 if (j == a.size)
  a [a.size] = a.size;
}

autoMAT newMATlowerCholeslyInverse_fromLowerCholesky (constMAT const& m);

void MATlowerCholesky_inplace (MAT a, double *out_lnd);

autoMAT newMATlowerCholesky (constMATVU const& a, double *out_lnd);

void MATlowerCholeskyInverse_inplace (MAT a, double *out_lnd);

inline autoMAT newMATlowerCholeskyInverse (constMAT const& a) {
 autoMAT result = newMATcopy (a);
 MATlowerCholeskyInverse_inplace (result.get(), nullptr);
 return result;
}





autoMAT newMATinverse_fromLowerCholeskyInverse (constMAT m);





double NUMdeterminant_fromSymmetricMatrix (constMAT m);




double NUMmahalanobisDistanceSquared (constMAT lowerInverse, constVEC v, constVEC m);
# 485 "../dwsys/NUM2.h"
double NUMtrace (const constMATVU& a);
double NUMtrace2 (const constMATVU& x, const constMATVU& y);




void MATprojectColumnsOnEigenspace_preallocated (MAT projection, constMATVU const& data, constMATVU const& eigenvectors);
# 505 "../dwsys/NUM2.h"
double VECdominantEigenvector_inplace (VEC inout_q, constMAT m, double tolerance);
# 518 "../dwsys/NUM2.h"
integer NUMsolveQuadraticEquation (double a, double b, double c, double *x1, double *x2);







autoVEC newVECsolve (constMATVU const& a, constVECVU const& b, double tol);






autoMAT newMATsolve (constMATVU const& a, constMATVU const& b, double tol);
# 550 "../dwsys/NUM2.h"
void VECsolveSparse_IHT (VECVU const& x, constMATVU const& d, constVECVU const& y, integer numberOfNonZeros, integer maximumNumberOfIterations, double tolerance, integer infoLevel);
autoVEC newVECsolveSparse_IHT (constMATVU const& d, constVECVU const& y, integer numberOfNonZeros, integer maximumNumberOfIterations, double tolerance, integer infoLevel);

void VECsolveNonnegativeLeastSquaresRegression (VECVU const& result, constMATVU const& m, constVECVU const& y, integer itermax, double tol, integer infoLevel);

inline autoVEC newVECsolveNonnegativeLeastSquaresRegression (constMATVU const& a, constVECVU const& y, integer itermax, double tol, integer infoLevel) {
 autoVEC result = newVECzero (a.ncol);
 VECsolveNonnegativeLeastSquaresRegression (result.get(), a, y, itermax, tol, infoLevel);
 return result;
}







void NUMsolveConstrainedLSQuadraticRegression (constMAT const& x, constVEC y, double *out_alpha, double *out_gamma);
# 580 "../dwsys/NUM2.h"
autoVEC newVECsolveWeaklyConstrainedLinearRegression (constMAT const& a, constVEC const& y, double alpha, double delta);
# 597 "../dwsys/NUM2.h"
void NUMprocrustes (constMATVU const& x, constMATVU const& y, autoMAT *out_rotation, autoVEC *out_translation, double *out_scale);
# 607 "../dwsys/NUM2.h"
double NUMnrbis (double (*f)(double x, double *dfx, void *closure), double xmin, double xmax, void *closure);







double NUMridders (double (*f) (double x, void *closure), double xmin, double xmax, void *closure);






double NUMmspline (constVEC const & knot, integer order, integer i, double x);
# 634 "../dwsys/NUM2.h"
double NUMispline (constVEC const & aknot, integer order, integer i, double x);
# 651 "../dwsys/NUM2.h"
double NUMwilksLambda (constVEC const& lambda, integer from, integer to);





double NUMlnBeta (double a, double b);





double NUMbeta2 (double z, double w);

double NUMbetaContinuedFraction(double a, double b, double x);

double NUMfactln (integer n);


void NUMlngamma_complex (double zr, double zi, double *out_lnr, double *out_arg);
# 684 "../dwsys/NUM2.h"
double NUMlogNormalP (double x, double zeta, double sigma);


double NUMlogNormalQ (double x, double zeta, double sigma);


double NUMstudentP (double t, double df);





double NUMstudentQ (double t, double df);





double NUMfisherP (double f, double df1, double df2);





double NUMfisherQ (double f, double df1, double df2);





double NUMinvGaussQ (double p);







double NUMinvChiSquareQ (double p, double df);





double NUMinvStudentQ (double p, double df);





double NUMinvFisherQ (double p, double df1, double df2);





double NUMtukeyQ (double q, double cc, double df, double rr);





double NUMinvTukeyQ (double p, double cc, double df, double rr);
# 760 "../dwsys/NUM2.h"
double NUMmelToHertz2 (double mel);




double NUMhertzToMel2 (double f);




double NUMmelToHertz3 (double mel);




double NUMhertzToMel3 (double hz);




double NUMbarkToHertz2 (double bark);




double NUMhertzToBark2 (double hz);




double NUMhertzToBark_traunmueller (double hz);




double NUMbarkToHertz_traunmueller (double bark);




double NUMbarkToHertz_schroeder (double bark);




double NUMbarkToHertz_zwickerterhardt (double hz);




double NUMhertzToBark_schroeder (double hz);




double NUMbladonlindblomfilter_amplitude (double zc, double z);
# 831 "../dwsys/NUM2.h"
double NUMsekeyhansonfilter_amplitude (double zc, double z);
# 847 "../dwsys/NUM2.h"
double NUMtriangularfilter_amplitude (double fl, double fc, double fh,
 double f);
# 861 "../dwsys/NUM2.h"
double NUMformantfilter_amplitude (double fc, double bw, double f);
# 870 "../dwsys/NUM2.h"
double VECburg (VEC const& a, constVEC const& x);







autoVEC newVECburg (constVEC const& x, integer numberOfPredictionCoefficients, double *out_xms);

void VECfilterInverse_inplace (VEC const& s, constVEC const& filter, VEC const& filterMemory);

void NUMdmatrix_to_dBs (MAT const& m, double ref, double factor, double floor);
# 898 "../dwsys/NUM2.h"
autoMAT MATcosinesTable (integer n);





void VECcosineTransform_preallocated (VEC const& target, constVEC const& x, constMAT const& cosinesTable);
void VECinverseCosineTransform_preallocated (VEC const& target, constVEC const& x, constMAT const& cosinesTable);



void NUMcubicSplineInterpolation_getSecondDerivatives (VEC const& out_y, constVEC const& x, constVEC const& y, double yp1, double ypn);
# 922 "../dwsys/NUM2.h"
double NUMcubicSplineInterpolation (constVEC const& xa, constVEC const& ya, constVEC const& y2a, double x);







autoVEC newVECbiharmonic2DSplineInterpolation_getWeights (constVECVU const& x, constVECVU const& y, constVECVU const& w);





double NUMbiharmonic2DSplineInterpolation (constVECVU const& x, constVECVU const& y, constVECVU const& w, double xp, double yp);
# 953 "../dwsys/NUM2.h"
double NUMsincpi (const double x);

double NUMsinc (const double x);




integer NUMgetOrientationOfPoints (double x1, double y1, double x2, double y2, double x3, double y3);





bool NUMdoLineSegmentsIntersect (double x1, double y1, double x2, double y2, double x3, double y3,
 double x4, double y4);


integer NUMgetIntersectionsWithRectangle (double x1, double y1, double x2, double y2,
 double xmin, double ymin, double xmax, double ymax, double *xi, double *yi);





bool NUMclipLineWithinRectangle (double xl1, double yl1, double xl2, double yl2, double xr1, double yr1,
 double xr2, double yr2, double *out_xo1, double *out_yo1, double *out_xo2, double *out_yo2);






void NUMgetEllipseBoundingBox (double a, double b, double cospsi,
 double *out_width, double *out_height);
# 1007 "../dwsys/NUM2.h"
double NUMminimize_brent (double (*f) (double x, void *closure), double a, double b,
 void *closure, double tol, double *fx);
# 1041 "../dwsys/NUM2.h"
struct structNUMfft_Table
{
  integer n;
  autoVEC trigcache;
  autoINTVEC splitcache;
};

typedef struct structNUMfft_Table *NUMfft_Table;

void NUMfft_Table_init (NUMfft_Table table, integer n);




struct autoNUMfft_Table : public structNUMfft_Table {
 autoNUMfft_Table () throw () {
  n = 0;
 }
 ~autoNUMfft_Table () { }
};

void NUMfft_forward (NUMfft_Table table, VEC data);
# 1101 "../dwsys/NUM2.h"
void NUMfft_backward (NUMfft_Table table, VEC data);
# 1139 "../dwsys/NUM2.h"
void NUMforwardRealFastFourierTransform (VEC data);
# 1153 "../dwsys/NUM2.h"
void NUMreverseRealFastFourierTransform (VEC data);
# 1165 "../dwsys/NUM2.h"
void NUMrealft (VEC data, integer direction);

integer NUMgetIndexFromProbability (constVEC probs, double p);
integer NUMgetIndexFromProbability (double *probs, integer nprobs, double p);


void NUMlineFit (constVEC x, constVEC y, double *out_m, double *out_intercept, integer method);






void NUMlineFit_theil (constVEC const& x, constVEC const& y, double *out_m, double *out_intercept, bool completeMethod);
# 1198 "../dwsys/NUM2.h"
void NUMlineFit_LS (constVEC const& x, constVEC const& y, double *out_m, double *out_intercept);
# 1238 "../dwsys/NUM2.h"
integer NUMrandomBinomial (double p, integer n);
double NUMrandomBinomial_real (double p, integer n);
# 1254 "../dwsys/NUM2.h"
double NUMrandomGamma (const double alpha, const double beta);



void VECrc_from_lpc (VEC rc, constVEC lpc);


void VECarea_from_rc (VEC area, constVEC rc);


void VECrc_from_area (VEC rc, constVEC area);


void VEClpc_from_area (VEC lpc, constVEC area);


void VECarea_from_lpc (VEC area, constVEC lpc);



void NUMfixIndicesInRange (integer lowerLimit, integer upperLimit, integer *lowIndex, integer *highIndex);

void NUMgetEntropies (constMATVU const& m, double *out_h, double *out_hx,
 double *out_hy, double *out_hygx, double *out_hxgy, double *out_uygx, double *out_uxgy, double *out_uxy);

inline double NUMmean_weighted (constVEC x, constVEC w) {
 ((x.size == w.size) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 1280, "x.size == w.size"), abort ()));
 double inproduct = NUMinner (x, w);
 double wsum = NUMsum (w);
 return inproduct / wsum;
}

inline void VECchainRows_preallocated (VECVU const& v, constMATVU const& m) {
 ((m.nrow * m.ncol == v.size) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 1287, "m.nrow * m.ncol == v.size"), abort ()));
 integer k = 1;
 for (integer irow = 1; irow <= m.nrow; irow ++)
  for (integer icol = 1; icol <= m.ncol; icol ++)
   v [k ++] = m [irow] [icol];
}

inline autoVEC VECchainRows (constMATVU const& m) {
 autoVEC result = newVECraw (m.nrow * m.ncol);
 VECchainRows_preallocated (result.get(), m);
 return result;
}

inline void VECchainColumns_preallocated (VEC const& v, constMATVU const& m) {
 ((m.nrow * m.ncol == v.size) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 1301, "m.nrow * m.ncol == v.size"), abort ()));
 integer k = 1;
 for (integer icol = 1; icol <= m.ncol; icol ++)
  for (integer irow = 1; irow <= m.nrow; irow ++)
   v [k ++] = m [irow] [icol];
}

inline autoVEC VECchainColumns (constMATVU const& m) {
 autoVEC result = newVECraw (m.nrow * m.ncol);
 VECchainColumns_preallocated (result.get(), m);
 return result;
}


void MATmul3 (MATVU const & target, constMATVU const& X, constMATVU const& Y, constMATVU const& Z);


void MATmul3_XYXt (MATVU const& target, constMATVU const& X, constMATVU const& Y);


void MATmul3_XYsXt (MATVU const& target, constMAT const& X, constMAT const& Y);







inline void MATfromUpperTriangularVector_preallocated (MAT m, constVEC v) {
 ((v.size == m.ncol * (m.ncol + 1) / 2) ? (void) (0) : (Melder_assert_ ("../dwsys/NUM2.h", 1330, "v.size == m.ncol * (m.ncol + 1) / 2"), abort ()));
 integer irow = 1;
 for (integer inum = 1; inum <= v.size; inum ++) {
  integer nskipped = (irow - 1) * irow / 2;
  integer inumc = inum + nskipped;
  irow = (inumc - 1) / m.ncol + 1;
  integer icol = ( (inumc - 1) % m.ncol) + 1;
  m [irow] [icol] = m [icol] [irow] = v [inum];
  if (icol == m.ncol) irow ++;
 }
}

inline autoINTVEC INTVECto (integer to) {
 autoINTVEC result = newINTVECraw (to);
 for (integer i = 1; i <= to; i ++)
  result [i] = i;
 return result;
}

void NUMeigencmp22 (double a, double b, double c, double *out_rt1, double *out_rt2, double *out_cs1, double *out_sn1 );
# 1378 "../dwsys/NUM2.h"
void NUMpolynomial_recurrence (VEC const& pn, double a, double b, double c, constVEC const& pnm1, constVEC const& pnm2);

static inline void NUMgetThreadingInfo (integer numberOfFrames, integer maximumNumberOfThreads, integer *inout_numberOfFramesPerThread, integer * out_numberOfThreads) {
 if (*inout_numberOfFramesPerThread <= 0)
  *inout_numberOfFramesPerThread = 25;
 integer numberOfThreads = (numberOfFrames - 1) / *inout_numberOfFramesPerThread + 1;
 if (numberOfThreads > maximumNumberOfThreads)
  numberOfThreads = maximumNumberOfThreads;
 if (numberOfThreads < 1)
  numberOfThreads = 1;
 *inout_numberOfFramesPerThread = (numberOfFrames - 1) / numberOfThreads + 1;
 if (out_numberOfThreads)
  *out_numberOfThreads = numberOfThreads;
}
# 27 "../dwsys/SVD.h" 2


# 1 "../dwsys/SVD_def.h" 1
# 20 "../dwsys/SVD_def.h"
typedef struct structSVD *SVD; typedef autoSomeThing <structSVD> autoSVD; typedef structDaata SVD_Parent; extern struct structClassInfo theClassInfo_SVD; extern ClassInfo classSVD; struct structSVD : public structDaata {

 double tolerance;
 integer numberOfRows;
 integer numberOfColumns;

  bool isTransposed;

# 47 "../dwsys/SVD_def.h"
  automatrix <double> u;
  automatrix <double> v;

 autovector <double> d;


  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structGSVD *GSVD; typedef autoSomeThing <structGSVD> autoGSVD; typedef structDaata GSVD_Parent; extern struct structClassInfo theClassInfo_GSVD; extern ClassInfo classGSVD; struct structGSVD : public structDaata {

 double tolerance;
 integer numberOfColumns;
 automatrix <double> q;
 automatrix <double> r;
 autovector <double> d1;
 autovector <double> d2;


  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 30 "../dwsys/SVD.h" 2

void SVD_init (SVD me, integer numberOfRows, integer numberOfColumns);

autoSVD SVD_create (integer numberOfRows, integer numberOfColumns);





autoSVD SVD_createFromGeneralMatrix (constMATVU const& m);

void SVD_update (SVD me, constMATVU const& m);





void SVD_compute (SVD me);


void SVD_solve_preallocated (SVD me, constVECVU const& b, VECVU const& result);
autoVEC SVD_solve (SVD me, constVECVU const& b);


void SVD_solve_preallocated (SVD me, constMATVU const& b, MATVU const& result);
autoMAT SVD_solve (SVD me, constMATVU const& b);

void SVD_sort (SVD me);




void SVD_setTolerance (SVD me, double tolerance);

double SVD_getTolerance (SVD me);

double SVD_getConditionNumber (SVD me);

double SVD_getSumOfSingularValuesAsFractionOfTotal (SVD me, integer from, integer to);

integer SVD_getMinimumNumberOfSingularValues (SVD me, double fractionOfSumOfSingularValues);

double SVD_getSumOfSingularValues (SVD me, integer from, integer to);

integer SVD_zeroSmallSingularValues (SVD me, double tolerance);






autoMAT SVD_synthesize (SVD me, integer sv_from, integer sv_to);
# 90 "../dwsys/SVD.h"
autoMAT SVD_getSquared (SVD me, bool inverse);
void SVD_getSquared_preallocated (SVD me, bool inverse, MAT const& m);


integer SVD_getRank (SVD me);

autoGSVD GSVD_create (integer numberOfColumns);

autoGSVD GSVD_create (constMATVU const& m1, constMATVU const& m2);

void GSVD_setTolerance (GSVD me, double tolerance);

double GSVD_getTolerance (GSVD me);
# 31 "Matrix_extensions.h" 2

autoMatrix Matrix_readFromIDXFormatFile (MelderFile file);
autoDaata IDXFormattedMatrixFileRecognizer (integer numberOfBytesRead, const char *header, MelderFile file);

void Matrix_scatterPlot (Matrix me, Graphics g, integer icx, integer icy,
    double xmin, double xmax, double ymin, double ymax,
    double size_mm, conststring32 mark, bool garnish);


void Matrix_drawAsSquares_inside (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax, kGraphicsMatrixOrigin origin, double cellAreaScaleFactor, kGraphicsMatrixCellDrawingOrder drawingOrder);

void Matrix_drawAsSquares (Matrix me, Graphics graphics, double xmin, double xmax, double ymin, double ymax, bool garnished);



void Matrix_drawRowsAsLineSegments (Matrix me, Graphics g, double xmin, double xmax, double ymin, double ymax,
 double minimum, double maximum, int connect);


void Matrix_scale (Matrix me, int choice);




autoMatrix Matrix_transpose (Matrix me);

void Matrix_drawDistribution (Matrix me, Graphics g, double xmin, double xmax,
 double ymin, double ymax, double minimum, double maximum, integer nBins,
 double freqMin, double freqmax, bool cumulative, bool garnish);

void Matrix_drawSliceY (Matrix me, Graphics g, double x, double ymin, double ymax,
 double min, double max);

int Matrix_fitPolynomial (Matrix me, integer maxDegree);

autoMatrix Matrix_solveEquation (Matrix me, double tolerance);

autoMatrix Matrix_solveEquation (Matrix me, Matrix thee, double tolerance);

double Matrix_getMean (Matrix me, double xmin, double xmax, double ymin, double ymax);

double Matrix_getStandardDeviation (Matrix me, double xmin, double xmax, double ymin, double ymax);

autoEigen Matrix_to_Eigen (Matrix me);


autoMatrix SVD_to_Matrix (SVD me, integer from, integer to);

autoCOMPVEC Matrix_listEigenvalues (Matrix me);
void Matrix_Eigen_complex (Matrix me, autoMatrix *out_eigenvectors, autoMatrix *out_eigenvalues);
# 25 "TableOfReal_extensions.h" 2
# 1 "PatternList.h" 1
# 22 "PatternList.h"
# 1 "ActivationList.h" 1
# 23 "ActivationList.h"
typedef struct structActivationList *ActivationList; typedef autoSomeThing <structActivationList> autoActivationList; extern struct structClassInfo theClassInfo_ActivationList; extern ClassInfo classActivationList; typedef structMatrix ActivationList_Parent; struct structActivationList : public structMatrix {
};
# 40 "ActivationList.h"
void ActivationList_init (ActivationList me, integer ny, integer nx);

autoActivationList ActivationList_create (integer ny, integer nx);

autoActivationList Matrix_to_ActivationList (Matrix me);

autoMatrix ActivationList_to_Matrix (ActivationList me);

int _ActivationList_checkElements (ActivationList me);
# 23 "PatternList.h" 2

typedef struct structPatternList *PatternList; typedef autoSomeThing <structPatternList> autoPatternList; extern struct structClassInfo theClassInfo_PatternList; extern ClassInfo classPatternList; typedef structMatrix PatternList_Parent; struct structPatternList : public structMatrix {
};
# 40 "PatternList.h"
autoPatternList PatternList_create (integer ny, integer nx);

void PatternList_normalize (PatternList me, int choice, double pmin, double pmax);




void PatternList_draw (PatternList me, Graphics g, integer pattern, double xmin, double xmax,
 double ymin, double ymax, bool garnish);

autoPatternList Matrix_to_PatternList (Matrix me, integer join);

autoMatrix PatternList_to_Matrix (PatternList me);

autoPatternList ActivationList_to_PatternList (ActivationList me);

bool _PatternList_checkElements (PatternList me);
# 26 "TableOfReal_extensions.h" 2

# 1 "SSCP.h" 1
# 21 "SSCP.h"
# 1 "CCA.h" 1
# 30 "CCA.h"
# 1 "CCA_def.h" 1
# 29 "CCA_def.h"
typedef struct structCCA *CCA; typedef autoSomeThing <structCCA> autoCCA; typedef structDaata CCA_Parent; extern struct structClassInfo theClassInfo_CCA; extern ClassInfo classCCA; struct structCCA : public structDaata {

 integer numberOfCoefficients;
 integer numberOfObservations;
 autoStrings yLabels;
 autoStrings xLabels;
 autoEigen y;
 autoEigen x;


  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 31 "CCA.h" 2
# 51 "CCA.h"
autoCCA CCA_create (integer numberOfCoefficients, integer ny, integer nx);

void CCA_drawEigenvector (CCA me, Graphics g, int x_or_y, integer ivec, integer first, integer last,
 double ymin, double ymax, int weigh, double size_mm, conststring32 mark, int connect, bool garnish);

double CCA_getEigenvectorElement (CCA me, int x_or_y, integer ivec, integer element);

autoCCA TableOfReal_to_CCA (TableOfReal me, integer ny);
# 101 "CCA.h"
autoTableOfReal CCA_TableOfReal_scores (CCA me, TableOfReal thee, integer numberOfFactors);







autoTableOfReal CCA_TableOfReal_factorLoadings (CCA me, TableOfReal thee);





double CCA_getCorrelationCoefficient (CCA me, integer index);

void CCA_getZeroCorrelationProbability (CCA me, integer index, double *out_prob, double *out_chisq, double *out_df);

autoTableOfReal CCA_TableOfReal_predict (CCA me, TableOfReal thee, integer from);
# 22 "SSCP.h" 2
# 1 "PCA.h" 1
# 31 "PCA.h"
# 1 "Configuration.h" 1
# 25 "Configuration.h"
# 1 "Configuration_def.h" 1
# 21 "Configuration_def.h"
typedef struct structConfiguration *Configuration; typedef autoSomeThing <structConfiguration> autoConfiguration; typedef structTableOfReal Configuration_Parent; extern struct structClassInfo theClassInfo_Configuration; extern ClassInfo classConfiguration; struct structConfiguration : public structTableOfReal {

 integer metric;
 autovector <double> w;


  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 26 "Configuration.h" 2


#pragma mark - class Configuration

autoConfiguration Configuration_create (integer numberOfPoints, integer numberOfDimensions);

void Configuration_setMetric (Configuration me, integer metric);

void Configuration_setDefaultWeights (Configuration me);


void Configuration_setSqWeights (Configuration me, const double weight[]);


void Configuration_randomize (Configuration me);




void Configuration_normalize (Configuration me, double variance, bool choice);







void Configuration_rotate (Configuration me, integer dimension1, integer dimension2, double angle_degrees);






void Configuration_invertDimension (Configuration me, int dimension);







autoConfiguration Configuration_congruenceRotation (Configuration me, Configuration thee,
 integer maximumNumberOfIterations, double tolerance);






autoConfiguration Configuration_varimax (Configuration me, bool normalizeRows, bool quartimax, integer maximumNumberOfIterations, double tolerance);






void Configuration_rotateToPrincipalDirections (Configuration me);

void Configuration_draw (Configuration me, Graphics g, int xCoordinate,
 int yCoordinate, double xmin, double xmax, double ymin, double ymax,
 int labelSize, bool useRowLabels, conststring32 label, bool garnish);

void Configuration_drawConcentrationEllipses (Configuration me, Graphics g,
 double scale, bool confidence, conststring32 label, integer d1, integer d2, double xmin, double xmax,
 double ymin, double ymax, double fontSize, bool garnish);

autoConfiguration TableOfReal_to_Configuration (TableOfReal me);

autoConfiguration TableOfReal_to_Configuration_pca (TableOfReal me, integer numberOfDimensions);
# 105 "Configuration.h"
autoConfiguration Configuration_createLetterRExample (int choice);






autoConfiguration Configuration_createCarrollWishExample ();


#pragma mark - class ConfigurationList

typedef struct structConfigurationList *ConfigurationList; typedef autoSomeThing <structConfigurationList> autoConfigurationList; extern struct structClassInfo theClassInfo_ConfigurationList; extern ClassInfo classConfigurationList; static inline autoConfigurationList ConfigurationList_create () { return Thing_newFromClass (classConfigurationList).static_cast_move<structConfigurationList>(); } struct structConfigurationList : OrderedOf<structConfiguration> {
};
# 32 "PCA.h" 2


# 1 "PCA_def.h" 1
# 24 "PCA_def.h"
typedef struct structPCA *PCA; typedef autoSomeThing <structPCA> autoPCA; typedef structEigen PCA_Parent; extern struct structClassInfo theClassInfo_PCA; extern ClassInfo classPCA; struct structPCA : public structEigen {

 integer numberOfObservations;
 autoSTRVEC labels;
 autovector <double> centroid;


  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 35 "PCA.h" 2

autoPCA PCA_create (integer numberOfComponents, integer dimension);

void PCA_setNumberOfObservations (PCA me, integer numberOfObservations);

integer PCA_getNumberOfObservations (PCA me);

autoPCA TableOfReal_to_PCA_byRows (TableOfReal me);

autoEigen PCA_to_Eigen (PCA me);



autoPCA Matrix_to_PCA_byRows (Matrix me);
autoPCA Matrix_to_PCA_byColumns (Matrix me);


void PCA_getEqualityOfEigenvalues (PCA me, integer from, integer to, int conservative, double *out_prob, double *out_chisq, double *out_df);


autoTableOfReal PCA_TableOfReal_to_TableOfReal_projectRows (PCA me, TableOfReal thee, integer numberOfDimensionsToKeep);
autoConfiguration PCA_TableOfReal_to_Configuration (PCA me, TableOfReal thee, integer numberOfDimensions);

autoTableOfReal PCA_TableOfReal_to_TableOfReal_zscores (PCA me, TableOfReal thee, integer numberOfDimensions);

double PCA_TableOfReal_getFractionVariance (PCA me, TableOfReal thee, integer from, integer to);





autoTableOfReal PCA_Configuration_to_TableOfReal_reconstruct (PCA me, Configuration thee);


autoTableOfReal PCA_to_TableOfReal_reconstruct1 (PCA me, conststring32 numstring);
# 23 "SSCP.h" 2
# 1 "TableOfReal_extensions.h" 1
# 24 "SSCP.h" 2

# 1 "SSCP_def.h" 1
# 21 "SSCP_def.h"
typedef struct structSSCP *SSCP; typedef autoSomeThing <structSSCP> autoSSCP; typedef structTableOfReal SSCP_Parent; extern struct structClassInfo theClassInfo_SSCP; extern ClassInfo classSSCP; struct structSSCP : public structTableOfReal {

 double numberOfObservations;
 autovector <double> centroid;







  integer expansionNumberOfRows;
  int dataChanged;
  automatrix <double> expansion;
  double lnd;
  automatrix <double> lowerCholeskyInverse;
  autoPCA pca;



  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 26 "SSCP.h" 2

# 1 "SSCP_enums.h" 1
# 19 "SSCP_enums.h"
enum class kSSCPstorage { UNDEFINED = -1, MIN = 1,
 COMPLETE = 1,
 DIAGONAL = 2,
MAX = 2, DEFAULT = DIAGONAL }; conststring32 kSSCPstorage_getText (kSSCPstorage value); kSSCPstorage kSSCPstorage_getValue (conststring32 text); inline static kSSCPstorage& operator++ (kSSCPstorage& value) { value = static_cast <kSSCPstorage> (static_cast <int> (value) + 1); return value; }
# 28 "SSCP.h" 2

typedef struct structCovariance *Covariance; typedef autoSomeThing <structCovariance> autoCovariance; extern struct structClassInfo theClassInfo_Covariance; extern ClassInfo classCovariance; typedef structSSCP Covariance_Parent; struct structCovariance : public structSSCP {
};

typedef struct structCorrelation *Correlation; typedef autoSomeThing <structCorrelation> autoCorrelation; extern struct structClassInfo theClassInfo_Correlation; extern ClassInfo classCorrelation; typedef structSSCP Correlation_Parent; struct structCorrelation : public structSSCP {
};





typedef struct structSSCPList *SSCPList; typedef autoSomeThing <structSSCPList> autoSSCPList; extern struct structClassInfo theClassInfo_SSCPList; extern ClassInfo classSSCPList; static inline autoSSCPList SSCPList_create () { return Thing_newFromClass (classSSCPList).static_cast_move<structSSCPList>(); } struct structSSCPList : OrderedOf<structSSCP> {
};

typedef struct structCovarianceList *CovarianceList; typedef autoSomeThing <structCovarianceList> autoCovarianceList; extern struct structClassInfo theClassInfo_CovarianceList; extern ClassInfo classCovarianceList; static inline autoCovarianceList CovarianceList_create () { return Thing_newFromClass (classCovarianceList).static_cast_move<structCovarianceList>(); } struct structCovarianceList : OrderedOf<structCovariance> {
 SSCPList asSSCPList () {
  return reinterpret_cast<SSCPList> (this);
 }
};

void SSCP_init (SSCP me, integer dimension, kSSCPstorage storage);

autoSSCP SSCP_create (integer dimension);

void SSCP_reset (SSCP me);

void SSCP_drawTwoDimensionalEllipse_inside (SSCP me, Graphics g, double scale, conststring32 label, double fontSize);

double SSCP_getEllipseScalefactor (SSCP me, double scale, bool confidence);

void SSCP_drawConcentrationEllipse (SSCP me, Graphics g, double scale, int confidence,
 integer d1, integer d2, double xmin, double xmax, double ymin, double ymax, bool garnish);

void SSCP_setNumberOfObservations (SSCP me, double numberOfObservations);

void SSCP_setCentroid (SSCP me, integer component, double value);

void SSCP_setValue (SSCP me, integer row, integer col, double value);

double SSCP_getNumberOfObservations (SSCP me);

double SSCP_getDegreesOfFreedom (SSCP me);

double SSCP_getTotalVariance (SSCP me);

double SSCP_getCumulativeContributionOfComponents (SSCP me, integer from, integer to);

double SSCP_getLnDeterminant (SSCP me);

double SSCP_getConcentrationEllipseArea(SSCP me, double scale, bool confidence, integer d1, integer d2);

double SSCP_getFractionVariation (SSCP me, integer from, integer to);

autoSSCP TableOfReal_to_SSCP (TableOfReal me, integer rowb, integer rowe, integer colb, integer cole);
autoSSCP TableOfReal_to_SSCP_rowWeights (TableOfReal me, integer rowb, integer rowe, integer colb, integer cole, integer weightColumnNumber);

autoTableOfReal SSCP_TableOfReal_extractDistanceQuantileRange (SSCP me, TableOfReal thee, double qlow, double qhigh);

autoTableOfReal Covariance_TableOfReal_extractDistanceQuantileRange (Covariance me, TableOfReal thee, double qlow, double qhigh);





autoTableOfReal Covariance_TableOfReal_mahalanobis (Covariance me, TableOfReal thee, bool useTableCentroid);




autoTableOfReal Covariance_TableOfReal_scaledResiduals (Covariance me, TableOfReal thee, bool useTableCentroid);

autoCovariance TableOfReal_to_Covariance (TableOfReal me);

autoCorrelation TableOfReal_to_Correlation (TableOfReal me);

autoCorrelation TableOfReal_to_Correlation_rank (TableOfReal me);

autoTableOfReal SSCP_to_TableOfReal (SSCP me);

autoTableOfReal SSCP_extractCentroid (SSCP me);

autoTableOfReal Covariance_to_TableOfReal_randomSampling (Covariance me, integer numberOfData);


void Covariance_PCA_generateOneVector_inline (Covariance me, PCA thee, VECVU vec, VEC buf);
# 125 "SSCP.h"
autoSSCPList TableOfReal_to_SSCPList_byLabel (TableOfReal me);

autoPCA SSCP_to_PCA (SSCP me);

void SSCP_expandPCA (SSCP me);

void SSCP_unExpandPCA (SSCP me);

autoCCA SSCP_to_CCA (SSCP me, integer ny);

autoCovariance Covariance_create (integer dimension);

autoCovariance Covariance_createSimple (conststring32 covars, conststring32 centroid, integer numberOfObservations);

autoCovariance Covariance_create_reduceStorage (integer dimension, kSSCPstorage storage);







autoCorrelation Correlation_create (integer dimension);

autoCorrelation Correlation_createSimple (conststring32 s_correlations, conststring32 s_centroid, integer numberOfObservations);

autoTableOfReal Correlation_confidenceIntervals (Correlation me, double confidenceLevel, integer numberOfTests, int method);
# 165 "SSCP.h"
void Covariance_getMarginalDensityParameters (Covariance me, constVECVU const& vector, double *p_mu, double *p_stdev);

double Covariance_getMarginalProbabilityAtPosition (Covariance me, constVECVU const& vector, double x);

double Covariance_getProbabilityAtPosition_string (Covariance me, conststring32 xpos);

double Covariance_getProbabilityAtPosition (Covariance me, constVEC x);


autoCovariance SSCP_to_Covariance (SSCP me, integer numberOfConstraints);

autoSSCP Covariance_to_SSCP (Covariance me);

void SSCP_getDiagonality_bartlett (SSCP me, integer numberOfContraints, double *out_chisq, double *out_prob, double *out_df);

void Correlation_testDiagonality_bartlett (Correlation me, integer numberOfContraints, double *out_chisq, double *out_prob, double *out_df);


autoCorrelation SSCP_to_Correlation (SSCP me);

void Covariance_difference (Covariance me, Covariance thee, double *out_prob, double *out_chisq, double *out_df);

void Covariance_getSignificanceOfOneMean (Covariance me, integer index, double mu, double *out_probability, double *out_t, double *out_df);

void Covariance_getSignificanceOfMeansDifference (Covariance me, integer index1, integer index2, double mu, int paired, int equalVariances, double *out_probability, double *out_t, double *out_ndf);

void Covariance_getSignificanceOfOneVariance (Covariance me, integer index, double sigmasq, double *out_probability, double *out_chisq, double *out_ndf);

void Covariance_getSignificanceOfVariancesRatio (Covariance me, integer index1, integer index2, double ratio, double *out_probability, double *out_f, double *out_df);

double Covariances_getMultivariateCentroidDifference (Covariance me, Covariance thee, int equalCovariances, double *out_prob, double *out_fisher, double *out_df1, double *out_df2);
# 204 "SSCP.h"
void Covariances_equality (CovarianceList me, int method, double *out_prob, double *out_chisq, double *out_df);






double Covariance_TableOfReal_normalityTest_BHEP (Covariance me, TableOfReal data, constVEC const& responsibilities, double *inout_beta, double *out_tnb, double *out_lnmu, double *out_lnvar, bool *out_covarianceIsSingular);
# 222 "SSCP.h"
autoCovariance CovarianceList_to_Covariance_pool (CovarianceList me);
autoCovariance CovarianceList_to_Covariance_between (CovarianceList me);
autoCovariance CovarianceList_to_Covariance_within (CovarianceList me);


autoSSCP SSCPList_to_SSCP_sum (SSCPList me);


autoSSCP SSCPList_to_SSCP_pool (SSCPList me);

void SSCPList_getHomegeneityOfCovariances_box (SSCPList me, double *out_probability, double *out_chisq, double *out_df);

autoSSCP SSCP_toTwoDimensions (SSCP me, constVECVU const& v1, constVECVU const& v2);

autoSSCPList SSCPList_toTwoDimensions (SSCPList me, constVECVU const& v1, constVECVU const& v2);

autoSSCPList SSCPList_extractTwoDimensions (SSCPList me, integer d1, integer d2);



void SSCPList_drawConcentrationEllipses (SSCPList me, Graphics g, double scale,
 bool confidence, conststring32 label, integer d1, integer d2, double xmin, double xmax,
 double ymin, double ymax, double fontSize, bool garnish);

void SSCPList_getEllipsesBoundingBoxCoordinates (SSCPList me, double scale, bool confidence,
 double *xmin, double *xmax, double *ymin, double *ymax);

void SSCP_expand (SSCP me);
# 262 "SSCP.h"
void SSCP_unExpand (SSCP me);


void SSCP_expandLowerCholeskyInverse (SSCP me);

void SSCP_unExpandLowerCholesky (SSCP me);
# 28 "TableOfReal_extensions.h" 2


void TableOfReal_to_PatternList_and_Categories(TableOfReal me, integer fromrow, integer torow, integer fromcol, integer tocol, autoPatternList *out_p, autoCategories *out_c);

autoTableOfReal TableOfReal_transpose (TableOfReal me);

autoStrings TableOfReal_extractRowLabels (TableOfReal me);

autoStrings TableOfReal_extractColumnLabels (TableOfReal me);

void TableOfReal_Categories_setRowLabels (TableOfReal me, Categories thee);


autoTableOfReal TableOfReal_sortOnlyByRowLabels (TableOfReal me);

autoINTVEC TableOfReal_getSortedIndexFromRowLabels (TableOfReal me);

autoTableOfReal TableOfReal_sortRowsByIndex (TableOfReal me, constINTVEC index, bool reverse);


autoTableOfReal TableOfReal_createIrisDataset ();

autoTableOfReal TableOfReal_create_pols1973 (bool include_levels);

autoTableOfReal TableOfReal_create_vanNierop1973 (bool include_levels);

autoTableOfReal TableOfReal_create_weenink1983 (int option);


autoTableOfReal TableOfReal_create_sandwell1987 ();

void TableOfReal_getColumnExtrema (TableOfReal me, integer col, double *min, double *max);

integer TableOfReal_getColumnIndexAtMaximumInRow (TableOfReal me, integer rowNumber);

conststring32 TableOfReal_getColumnLabelAtMaximumInRow (TableOfReal me, integer rowNumber);

void TableOfReal_drawRowsAsHistogram (TableOfReal me, Graphics g, conststring32 rows, integer colb, integer cole,
 double ymin, double ymax, double xoffsetFraction, double interbarFraction,
 double interbarsFraction, conststring32 greys, bool garnish);

void TableOfReal_drawScatterPlot (TableOfReal me, Graphics g, integer icx, integer icy, integer rowb,
 integer rowe, double xmin, double xmax, double ymin, double ymax,
 integer labelSize, bool useRowLabels, conststring32 label, bool garnish);

void TableOfReal_drawAsScalableSquares (TableOfReal me, Graphics g, integer rowmin, integer rowmax, integer colmin, integer colmax, kGraphicsMatrixOrigin origin, double cellSizeFactor, kGraphicsMatrixCellDrawingOrder fillOrder, bool garnish);

void TableOfReal_drawScatterPlotMatrix (TableOfReal me, Graphics g, integer colb, integer cole, double fractionWhite);

void TableOfReal_drawBoxPlots (TableOfReal me, Graphics g, integer rowmin, integer rowmax, integer colmin, integer colmax,
 double ymin, double ymax, bool garnish);

void TableOfReal_drawVectors (TableOfReal me, Graphics g, integer colx1, integer coly1,
 integer colx2, integer coly2, double xmin, double xmax,
 double ymin, double ymax, int vectype, int labelsize, bool garnish);

void TableOfReal_drawBiplot (TableOfReal me, Graphics g, double xmin, double xmax,
 double ymin, double ymax, double sv_splitfactor, int labelsize,
 bool garnish);

void TableOfReal_drawColumnAsDistribution (TableOfReal me, Graphics g, integer column, double minimum, double maximum, integer nBins,
 double freqMin, double freqMax, bool cumulative, bool garnish);

integer TableOfReal_getNumberOfLabelMatches (TableOfReal me, conststring32 search, bool columnLabels,
 bool use_regexp);




void TableOfReal_copyLabels (TableOfReal me, TableOfReal thee, int rowOrigin, int columnOrigin);
# 108 "TableOfReal_extensions.h"
void TableOfReal_setLabelsFromCollectionItemNames (TableOfReal me, Collection thee, bool setRowLabels, bool setColumnLabels);

void TableOfReal_setSequentialColumnLabels (TableOfReal me, integer from, integer to, conststring32 precursor, integer number, integer increment);

void TableOfReal_setSequentialRowLabels (TableOfReal me, integer from, integer to, conststring32 precursor, integer number, integer increment);

bool TableOfReal_hasRowLabels (TableOfReal me);

bool TableOfReal_hasColumnLabels (TableOfReal me);

void TableOfReal_changeRowLabels (TableOfReal me, conststring32 search, conststring32 replace,
 integer maximumNumberOfReplaces, integer *nmatches, integer *nstringmatches, bool use_regexp);

void TableOfReal_changeColumnLabels (TableOfReal me, conststring32 search, conststring32 replace,
 integer maximumNumberOfReplaces, integer *nmatches, integer *nstringmatches, bool use_regexp);
# 134 "TableOfReal_extensions.h"
void TableOfReal_centreColumns (TableOfReal me);

void TableOfReal_centreColumns_byRowLabel (TableOfReal me);


double TableOfReal_getColumnQuantile (TableOfReal me, integer col, double quantile);

double TableOfReal_getRowSumByLabel (TableOfReal me, conststring32 label);

double TableOfReal_getRowSum (TableOfReal me, integer index);

double TableOfReal_getColumnSumByLabel (TableOfReal me, conststring32 label);

double TableOfReal_getColumnSum (TableOfReal me, integer index);

double TableOfReal_getGrandSum (TableOfReal me);

void TableOfReal_centreRows (TableOfReal me);

void TableOfReal_doubleCentre (TableOfReal me);

bool TableOfReal_isNonNegative (TableOfReal me);

double TableOfReal_getTableNorm (TableOfReal me);

void TableOfReal_normalizeTable (TableOfReal me, double norm);

void TableOfReal_normalizeColumns (TableOfReal me, double norm);

void TableOfReal_normalizeRows (TableOfReal me, double norm);

void TableOfReal_standardizeColumns (TableOfReal me);

void TableOfReal_standardizeRows (TableOfReal me);

autoTableOfReal TableOfReal_rankColumns (TableOfReal me, integer fromColumn, integer toColumn);

autoTableOfReal TableOfReal_meansByRowLabels (TableOfReal me, bool expand, bool useMedians);







autoTableOfReal TableOfReal_bootstrap (TableOfReal me);


autoTableOfReal TableOfReal_randomizeRows (TableOfReal me);



autoTableOfReal TableOfReal_to_TableOfReal (TableOfReal me);

autoTableOfReal TableOfReal_choleskyDecomposition (TableOfReal me, bool upper, bool inverse);

autoTableOfReal TableOfReal_appendColumns (TableOfReal me, TableOfReal thee);

void TableOfReal_copyOneRowWithLabel (TableOfReal me, TableOfReal thee, integer myrow, integer thyrow);


double TableOfReal_normalityTest_BHEP (TableOfReal me, double *h, double *out_tnb, double *out_lnmu, double *out_lnvar, bool *out_singularCovariance);

autoTableOfReal TableOfReal_TableOfReal_crossCorrelations (TableOfReal me, TableOfReal thee, bool by_columns, bool center, bool normalize);


#pragma mark - class TableOfRealList

autoTableOfReal TableOfRealList_sum (TableOfRealList me);

bool TableOfRealList_haveIdenticalDimensions (TableOfRealList me);

autoTableOfReal TableOfRealList_appendColumnsMany (TableOfRealList me);

autoMatrix TableOfReal_to_Matrix_interpolateOnRectangularGrid (TableOfReal me, double xmin, double xmax, double nx, double ymin, double ymax, integer ny, int );
# 52 "VowelEditor.cpp" 2
# 1 "Table_extensions.h" 1
# 29 "Table_extensions.h"
# 1 "../dwsys/FileInMemoryManager.h" 1
# 22 "../dwsys/FileInMemoryManager.h"
# 1 "../dwsys/FileInMemorySet.h" 1
# 21 "../dwsys/FileInMemorySet.h"
# 1 "../dwsys/FileInMemory.h" 1
# 24 "../dwsys/FileInMemory.h"
# 1 "../dwsys/FileInMemory_def.h" 1
# 20 "../dwsys/FileInMemory_def.h"
typedef struct structFileInMemory *FileInMemory; typedef autoSomeThing <structFileInMemory> autoFileInMemory; typedef structDaata FileInMemory_Parent; extern struct structClassInfo theClassInfo_FileInMemory; extern ClassInfo classFileInMemory; struct structFileInMemory : public structDaata {

 autostring32 d_path;
 autostring32 d_id;
 integer d_numberOfBytes;
 integer d_position;
 integer d_errno;
 int32 ungetChar;





  autovector <byte> d_data;

 unsigned char writable;


  unsigned char _dontOwnData;



  void v_info () override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 25 "../dwsys/FileInMemory.h" 2

autoFileInMemory FileInMemory_create (MelderFile file);
# 36 "../dwsys/FileInMemory.h"
autoFileInMemory FileInMemory_createWithData (integer numberOfBytes, const char *data, bool isStaticData, conststring32 path, conststring32 id);

void FileInMemory_setId (FileInMemory me, conststring32 newId);

void FileInMemory_showAsCode (FileInMemory me, conststring32 name, integer numberOfBytesPerLine);
# 22 "../dwsys/FileInMemorySet.h" 2




# 1 "../dwsys/FileInMemorySet_def.h" 1
# 20 "../dwsys/FileInMemorySet_def.h"
typedef struct structFileInMemorySet *FileInMemorySet; typedef autoSomeThing <structFileInMemorySet> autoFileInMemorySet; typedef structSortedSet FileInMemorySet_Parent; extern struct structClassInfo theClassInfo_FileInMemorySet; extern ClassInfo classFileInMemorySet; struct structFileInMemorySet : public structSortedSet {


  static int s_compareHook (Daata f1, Daata f2) noexcept {
   FileInMemory me = static_cast<FileInMemory> (f1), thee = static_cast<FileInMemory> (f2);
   return Melder_cmp (me -> d_path.get(), thee -> d_path.get());
  }
  CompareHook v_getCompareHook () override { return s_compareHook; }

  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 27 "../dwsys/FileInMemorySet.h" 2

autoFileInMemorySet FileInMemorySet_create ();

autoFileInMemorySet FileInMemorySet_createFromDirectoryContents (conststring32 dirpath, conststring32 file);

autoFileInMemorySet FilesInMemory_to_FileInMemorySet (OrderedOf<structFileInMemory>& list);

autoFileInMemorySet FileInMemorySet_extractFiles (FileInMemorySet me, kMelder_string which, conststring32 criterion);


autoFileInMemorySet FileInMemorySet_listFiles (FileInMemorySet me, kMelder_string which, conststring32 criterion);

integer FileInMemorySet_getTotalNumberOfBytes (FileInMemorySet me);

autoFileInMemorySet FileInMemorySets_merge (OrderedOf<structFileInMemorySet>& list);

void FileInMemorySet_showAsCode (FileInMemorySet me, conststring32 name, integer numberOfBytesPerLine);

void FileInMemorySet_showOneFileAsCode (FileInMemorySet me, integer index, conststring32 name, integer numberOfBytesPerLine);

autovector<unsigned char> FileInMemorySet_getCopyOfData (FileInMemorySet me, conststring32 id);
const char * FileInMemorySet_getData (FileInMemorySet me, conststring32 id, integer *out_numberOfBytes);

integer FileInMemorySet_findNumberOfMatches_path (FileInMemorySet me, kMelder_string which, conststring32 criterion);

integer FileInMemorySet_getIndexFromId (FileInMemorySet me, conststring32 id);

integer FileInMemorySet_lookUp (FileInMemorySet me, conststring32 path);

bool FileInMemorySet_hasDirectory (FileInMemorySet me, conststring32 name);

autoStrings FileInMemorySet_to_Strings_id (FileInMemorySet me);
# 23 "../dwsys/FileInMemoryManager.h" 2



# 1 "../dwsys/FileInMemoryManager_def.h" 1
# 20 "../dwsys/FileInMemoryManager_def.h"
typedef struct structFileInMemoryManager *FileInMemoryManager; typedef autoSomeThing <structFileInMemoryManager> autoFileInMemoryManager; typedef structDaata FileInMemoryManager_Parent; extern struct structClassInfo theClassInfo_FileInMemoryManager; extern ClassInfo classFileInMemoryManager; struct structFileInMemoryManager : public structDaata {

 autoFileInMemorySet files;
 autoFileInMemorySet openFiles;
 integer errorNumber;


  void v_info ()
   override;


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 27 "../dwsys/FileInMemoryManager.h" 2

autoFileInMemoryManager FileInMemoryManager_create (FileInMemorySet files);

autoFileInMemory FileInMemoryManager_createFile (FileInMemoryManager me, MelderFile file);


autoFileInMemorySet FileInMemoryManager_extractFiles (FileInMemoryManager me, kMelder_string which, conststring32 criterion);





bool FileInMemoryManager_hasDirectory (FileInMemoryManager me, conststring32 name);

FILE *FileInMemoryManager_fopen (FileInMemoryManager me, const char *filename, const char *mode);

void FileInMemoryManager_rewind (FileInMemoryManager me, FILE *stream);

int FileInMemoryManager_fclose (FileInMemoryManager me, FILE *stream);

int FileInMemoryManager_feof (FileInMemoryManager me, FILE *stream);

integer FileInMemoryManager_ftell (FileInMemoryManager me, FILE *stream);

int FileInMemoryManager_fseek (FileInMemoryManager me, FILE *stream, integer offset, int origin);

char *FileInMemoryManager_fgets (FileInMemoryManager me, char *str, int num, FILE *stream);

size_t FileInMemoryManager_fread (FileInMemoryManager me, void *ptr, size_t size, size_t count, FILE *stream);

int FileInMemoryManager_fgetc (FileInMemoryManager me, FILE *stream);

int FileInMemoryManager_fprintf (FileInMemoryManager me, FILE * stream, const char * format, ... );

int FileInMemoryManager_ungetc (FileInMemoryManager me, int character, FILE * stream);

void test_FileInMemoryManager_io (void);
# 30 "Table_extensions.h" 2




integer Table_getNumberOfRowsWhere (Table me, conststring32 formula, Interpreter interpreter);

autoINTVEC Table_findRowsMatchingCriterion (Table me, conststring32 formula, Interpreter interpreter);

autoVEC Table_getColumnVector (Table me, integer columnNumber);

autoTable Table_create_petersonBarney1952 ();

autoTable Table_create_polsVanNierop1973 ();

autoTable Table_create_weenink1983 ();

autoTable Table_create_esposito2006 ();

autoTable Table_create_ganong1980 ();

autoTable FileInMemoryManager_downto_Table (FileInMemoryManager me, bool openFilesOnly);

double Table_getMedianAbsoluteDeviation (Table me, integer columnNumber);

void Table_reportHuberMStatistics (Table me, integer columnNumber, double k_std, double tol, double *out_location, double *out_scale, integer maximumNumberOfiterations);


autoTable Table_getOneWayAnalysisOfVarianceF (Table me,
 integer column, integer groupColumn, autoTable *means, autoTable *meansDiff, autoTable *meansDiffProbabilities);

autoTable Table_getOneWayKruskalWallis (Table me,
 integer column, integer factorColumn, double *p_prob, double *p_kruskalWallis, double *p_df);

autoTable Table_getTwoWayAnalysisOfVarianceF (Table me,
 integer column, integer groupColumnA, integer groupColumnB, autoTable *means, autoTable *factorLevelSizes);

void Table_verticalErrorBarsPlotWhere (Table me, Graphics g, integer xcolumn, integer ycolumn, double xmin, double xmax,
 double ymin, double ymax, integer yci_min, integer yci_max, double bar_mm, bool garnish, conststring32 formula, Interpreter interpreter);

void Table_horizontalErrorBarsPlotWhere (Table me, Graphics g, integer xcolumn, integer ycolumn, double xmin, double xmax,
 double ymin, double ymax, integer xci_min, integer xci_max, double bar_mm, bool garnish, conststring32 formula, Interpreter interpreter);

void Table_normalProbabilityPlot (Table me, Graphics g,
 integer column, integer numberOfQuantiles, double numberOfSigmas, double labelSize, conststring32 label, bool garnish);

void Table_quantileQuantilePlot (Table me, Graphics g,
 integer xcolumn, integer ycolumn, integer numberOfQuantiles,
 double xmin, double xmax, double ymin, double ymax, double labelSize, conststring32 label, bool garnish
);

void Table_quantileQuantilePlot_betweenLevels (Table me, Graphics g,
 integer dataColumn, integer factorColumn, conststring32 xlevel, conststring32 ylevel, integer numberOfQuantiles,
 double xmin, double xmax, double ymin, double ymax, double labelSize, conststring32 label, bool garnish
);

void Table_boxPlots (Table me, Graphics g,
 integer dataColumn, integer factorColumn, double ymin, double ymax, bool garnish);

void Table_boxPlotsWhere (Table me, Graphics g,
 conststring32 dataColumns_string, integer factorColumn,
 double ymin, double ymax, bool garnish, conststring32 formula, Interpreter interpreter
);

autoTable Table_extractRowsWhere (Table me, conststring32 formula, Interpreter interpreter);

autoTable Table_extractColumnRanges (Table me, conststring32 ranges);

autoTable Table_extractMahalanobisWhere (Table me,
 conststring32 columnLabels, conststring32 factorColumn, double numberOfSigmas,
 kMelder_number which, conststring32 formula, Interpreter interpreter
);

void Table_distributionPlotWhere (Table me, Graphics g,
 integer dataColumn, double minimum, double maximum, integer nBins,
 double freqMin, double freqMax, bool garnish, conststring32 formula, Interpreter interpreter
);

void Table_barPlotWhere (Table me, Graphics g,
 conststring32 columnLabels, double ymin, double ymax, conststring32 labelColumn,
 double xoffsetFraction, double interbarFraction, double interbarsFraction, conststring32 colours,
 double angle, bool garnish, conststring32 formula, Interpreter interpreter
);

void Table_lineGraphWhere (Table me, Graphics g,
 integer xcolumn, double xmin, double xmax, integer ycolumn, double ymin, double ymax,
 conststring32 symbol, double angle, bool garnish, conststring32 formula, Interpreter interpreter
);

void Table_lagPlotWhere (Table me, Graphics g,
 integer column, integer lag, double xmin, double xmax,
 conststring32 symbol, double labelSize, bool garnish, conststring32 formula, Interpreter interpreter
);

void Table_drawEllipsesWhere (Table me, Graphics g,
 integer xcolumn, integer ycolumn, integer labelcolumn, double xmin, double xmax, double ymin, double ymax,
 double numberOfSigmas, double labelSize, bool garnish, conststring32 formula, Interpreter interpreter);

void Table_printAsAnovaTable (Table me);

void Table_printAsMeansTable (Table me);
# 53 "VowelEditor.cpp" 2
# 1 "VowelEditor.h" 1
# 26 "VowelEditor.h"
# 1 "../fon/FormantTier.h" 1
# 27 "../fon/FormantTier.h"
# 1 "../fon/FormantTier_def.h" 1
# 21 "../fon/FormantTier_def.h"
typedef struct structFormantPoint *FormantPoint; typedef autoSomeThing <structFormantPoint> autoFormantPoint; typedef structAnyPoint FormantPoint_Parent; extern struct structClassInfo theClassInfo_FormantPoint; extern ClassInfo classFormantPoint; struct structFormantPoint : public structAnyPoint {

 integer numberOfFormants;
 autovector <double> formant;
 autovector <double> bandwidth;

void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };




typedef struct structFormantTier *FormantTier; typedef autoSomeThing <structFormantTier> autoFormantTier; typedef structFunction FormantTier_Parent; extern struct structClassInfo theClassInfo_FormantTier; extern ClassInfo classFormantTier; struct structFormantTier : public structFunction {

 SortedSetOfDoubleOf<structFormantPoint> points;


  AnyTier asAnyTier () { return reinterpret_cast <AnyTier> (this); } void v_shiftX (double xfrom, double xto) override { ((AnyTier) this) -> structAnyTier::v_shiftX (xfrom, xto); } void v_scaleX (double xminfrom, double xmaxfrom, double xminto, double xmaxto) override { ((AnyTier) this) -> structAnyTier::v_scaleX (xminfrom, xmaxfrom, xminto, xmaxto); };


void v_destroy () noexcept override; void v_copy (Daata data_to) override; bool v_equal (Daata otherData) override; static Data_Description s_description; Data_Description v_description () override { return s_description; } bool v_canWriteAsEncoding (int outputEncoding) override; void v_writeText (MelderFile openFile) override; void v_readText (MelderReadText text, int formatVersion) override; void v_writeBinary (FILE *f) override; void v_readBinary (FILE *f, int formatVersion) override; };
# 28 "../fon/FormantTier.h" 2

autoFormantPoint FormantPoint_create (double time, integer numberOfFormants);
autoFormantTier FormantTier_create (double tmin, double tmax);
double FormantTier_getValueAtTime (FormantTier me, integer iformant, double t);
double FormantTier_getBandwidthAtTime (FormantTier me, integer iformant, double t);
integer FormantTier_getMinNumFormants (FormantTier me);
integer FormantTier_getMaxNumFormants (FormantTier me);
void FormantTier_speckle (FormantTier me, Graphics g, double tmin, double tmax, double fmax, bool garnish);
autoFormantTier Formant_downto_FormantTier (Formant me);
autoFormantTier Formant_PointProcess_to_FormantTier (Formant me, PointProcess pp);
autoTableOfReal FormantTier_downto_TableOfReal (FormantTier me, bool includeFormants, bool includeBandwidths);

void Sound_FormantTier_filter_inplace (Sound me, FormantTier formantTier);
autoSound Sound_FormantTier_filter (Sound me, FormantTier formantTier);
autoSound Sound_FormantTier_filter_noscale (Sound me, FormantTier formantTier);
# 27 "VowelEditor.h" 2


# 1 "../sys/Editor.h" 1
# 21 "../sys/Editor.h"
# 1 "../sys/Collection.h" 1
# 22 "../sys/Editor.h" 2
# 1 "../sys/Gui.h" 1
# 76 "../sys/Gui.h"
# 1 "../sys/machine.h" 1
# 21 "../sys/machine.h"
void Machine_initLookAndFeel (int argc, char **argv);
int Machine_getMenuBarHeight ();
int Machine_getMainWindowMenuBarHeight ();
int Machine_getTitleBarHeight ();
int Machine_getScrollBarWidth ();
int Machine_getTextHeight ();
int Machine_getButtonHeight ();
# 77 "../sys/Gui.h" 2
# 295 "../sys/Gui.h"
 typedef void *GuiObject;


int Gui_getResolution (GuiObject widget);
void Gui_getWindowPositioningBounds (double *x, double *y, double *width, double *height);

typedef struct structGuiForm *GuiForm; typedef autoSomeThing <structGuiForm> autoGuiForm; extern struct structClassInfo theClassInfo_GuiForm; extern ClassInfo classGuiForm;
typedef struct structGuiMenu *GuiMenu; typedef autoSomeThing <structGuiMenu> autoGuiMenu; extern struct structClassInfo theClassInfo_GuiMenu; extern ClassInfo classGuiMenu;
typedef struct structGuiScrolledWindow *GuiScrolledWindow; typedef autoSomeThing <structGuiScrolledWindow> autoGuiScrolledWindow; extern struct structClassInfo theClassInfo_GuiScrolledWindow; extern ClassInfo classGuiScrolledWindow;
typedef struct structGuiShell *GuiShell; typedef autoSomeThing <structGuiShell> autoGuiShell; extern struct structClassInfo theClassInfo_GuiShell; extern ClassInfo classGuiShell;
typedef struct structGuiWindow *GuiWindow; typedef autoSomeThing <structGuiWindow> autoGuiWindow; extern struct structClassInfo theClassInfo_GuiWindow; extern ClassInfo classGuiWindow;

typedef struct structGuiThing *GuiThing; typedef autoSomeThing <structGuiThing> autoGuiThing; extern struct structClassInfo theClassInfo_GuiThing; extern ClassInfo classGuiThing; typedef structThing GuiThing_Parent; struct structGuiThing : public structThing {
 GuiShell d_shell;
 GuiThing d_parent;
 GuiObject d_widget;

 void v_destroy () noexcept
  override;

 virtual void v_show ();
 virtual void v_hide ();
 virtual void v_setSensitive (bool sensitive);
};

void GuiThing_show (GuiThing me);
void GuiThing_hide (GuiThing me);
void GuiThing_setSensitive (GuiThing me, bool sensitive);

typedef struct structGuiControl *GuiControl; typedef autoSomeThing <structGuiControl> autoGuiControl; extern struct structClassInfo theClassInfo_GuiControl; extern ClassInfo classGuiControl; typedef structGuiThing GuiControl_Parent; struct structGuiControl : public structGuiThing {
 int d_left, d_right, d_top, d_bottom;
 bool d_blockValueChangedCallbacks;

 virtual void v_positionInForm (GuiObject widget, int left, int right, int top, int bottom, GuiForm parent);
 virtual void v_positionInScrolledWindow (GuiObject widget, int width, int height, GuiScrolledWindow parent);
};

int GuiControl_getX (GuiControl me);
int GuiControl_getY (GuiControl me);
int GuiControl_getWidth (GuiControl me);
int GuiControl_getHeight (GuiControl me);
void GuiControl_move (GuiControl me, int x, int y);
void GuiControl_setSize (GuiControl me, int width, int height);

typedef struct structGuiForm *GuiForm; typedef autoSomeThing <structGuiForm> autoGuiForm; extern struct structClassInfo theClassInfo_GuiForm; extern ClassInfo classGuiForm; typedef structGuiControl GuiForm_Parent; struct structGuiForm : public structGuiControl {
};

typedef MelderCallback <void, structThing > GuiShell_GoAwayCallback;

typedef struct structGuiShell *GuiShell; typedef autoSomeThing <structGuiShell> autoGuiShell; extern struct structClassInfo theClassInfo_GuiShell; extern ClassInfo classGuiShell; typedef structGuiForm GuiShell_Parent; struct structGuiShell : public structGuiForm {
 int d_width, d_height;







 GuiShell_GoAwayCallback d_goAwayCallback;
 Thing d_goAwayBoss;

 void v_destroy () noexcept
  override;
};

int GuiShell_getShellWidth (GuiShell me);
int GuiShell_getShellHeight (GuiShell me);
void GuiShell_setTitle (GuiShell me, conststring32 title );
void GuiShell_drain (GuiShell me);



typedef struct structGuiButton *GuiButton; typedef autoSomeThing <structGuiButton> autoGuiButton; extern struct structClassInfo theClassInfo_GuiButton; extern ClassInfo classGuiButton;

typedef struct structGuiButtonEvent {
 GuiButton button;
 bool shiftKeyPressed, commandKeyPressed, optionKeyPressed, extraControlKeyPressed;
} *GuiButtonEvent;

typedef MelderCallback <void, structThing , GuiButtonEvent> GuiButton_ActivateCallback;

typedef struct structGuiButton *GuiButton; typedef autoSomeThing <structGuiButton> autoGuiButton; extern struct structClassInfo theClassInfo_GuiButton; extern ClassInfo classGuiButton; typedef structGuiControl GuiButton_Parent; struct structGuiButton : public structGuiControl {
 GuiButton_ActivateCallback d_activateCallback;
 Thing d_activateBoss;
 GuiMenu d_menu;
};






GuiButton GuiButton_create (GuiForm parent,
 int left, int right, int top, int bottom,
 conststring32 text,
 GuiButton_ActivateCallback activateCallback, Thing boss,
 uint32 flags
);
GuiButton GuiButton_createShown (GuiForm parent,
 int left, int right, int top, int bottom,
 conststring32 text,
 GuiButton_ActivateCallback activateCallback, Thing boss,
 uint32 flags
);

void GuiButton_setText (GuiButton me, conststring32 text );



typedef struct structGuiCheckButton *GuiCheckButton; typedef autoSomeThing <structGuiCheckButton> autoGuiCheckButton; extern struct structClassInfo theClassInfo_GuiCheckButton; extern ClassInfo classGuiCheckButton;

typedef struct structGuiCheckButtonEvent {
 GuiCheckButton toggle;
} *GuiCheckButtonEvent;

typedef MelderCallback <void, structThing , GuiCheckButtonEvent> GuiCheckButton_ValueChangedCallback;

typedef struct structGuiCheckButton *GuiCheckButton; typedef autoSomeThing <structGuiCheckButton> autoGuiCheckButton; extern struct structClassInfo theClassInfo_GuiCheckButton; extern ClassInfo classGuiCheckButton; typedef structGuiControl GuiCheckButton_Parent; struct structGuiCheckButton : public structGuiControl {
 GuiCheckButton_ValueChangedCallback d_valueChangedCallback;
 Thing d_valueChangedBoss;
};




GuiCheckButton GuiCheckButton_create (GuiForm parent,
 int left, int right, int top, int bottom,
 conststring32 text,
 GuiCheckButton_ValueChangedCallback valueChangedCallback, Thing boss,
 uint32 flags
);
GuiCheckButton GuiCheckButton_createShown (GuiForm parent,
 int left, int right, int top, int bottom,
 conststring32 text,
 GuiCheckButton_ValueChangedCallback valueChangedCallback, Thing boss,
 uint32 flags
);

bool GuiCheckButton_getValue (GuiCheckButton me);
void GuiCheckButton_setValue (GuiCheckButton me, bool value);



typedef struct structGuiDialog *GuiDialog; typedef autoSomeThing <structGuiDialog> autoGuiDialog; extern struct structClassInfo theClassInfo_GuiDialog; extern ClassInfo classGuiDialog; typedef structGuiShell GuiDialog_Parent; struct structGuiDialog : public structGuiShell {
};



GuiDialog GuiDialog_create (GuiWindow parent,
 int x, int y, int width, int height,
 conststring32 title,
 GuiShell_GoAwayCallback goAwayCallback, Thing goAwayBoss,
 uint32 flags
);



typedef struct structGuiDrawingArea *GuiDrawingArea; typedef autoSomeThing <structGuiDrawingArea> autoGuiDrawingArea; extern struct structClassInfo theClassInfo_GuiDrawingArea; extern ClassInfo classGuiDrawingArea;
typedef struct structGuiScrollBar *GuiScrollBar; typedef autoSomeThing <structGuiScrollBar> autoGuiScrollBar; extern struct structClassInfo theClassInfo_GuiScrollBar; extern ClassInfo classGuiScrollBar;

typedef struct structGuiDrawingArea_ExposeEvent {
 GuiDrawingArea widget;
 int x, y, width, height;
} *GuiDrawingArea_ExposeEvent;
typedef struct structGuiDrawingArea_ClickEvent {
 GuiDrawingArea widget;
 int x, y;
 bool shiftKeyPressed, commandKeyPressed, optionKeyPressed, extraControlKeyPressed;
 int button;
} *GuiDrawingArea_ClickEvent;
typedef struct structGuiDrawingArea_KeyEvent {
 GuiDrawingArea widget;
 char32 key;
 bool shiftKeyPressed, commandKeyPressed, optionKeyPressed, extraControlKeyPressed;
} *GuiDrawingArea_KeyEvent;
typedef struct structGuiDrawingArea_ResizeEvent {
 GuiDrawingArea widget;
 int width, height;
} *GuiDrawingArea_ResizeEvent;

typedef MelderCallback <void, structThing , GuiDrawingArea_ExposeEvent> GuiDrawingArea_ExposeCallback;
typedef MelderCallback <void, structThing , GuiDrawingArea_ClickEvent > GuiDrawingArea_ClickCallback;
typedef MelderCallback <void, structThing , GuiDrawingArea_KeyEvent > GuiDrawingArea_KeyCallback;
typedef MelderCallback <void, structThing , GuiDrawingArea_ResizeEvent> GuiDrawingArea_ResizeCallback;

typedef struct structGuiDrawingArea *GuiDrawingArea; typedef autoSomeThing <structGuiDrawingArea> autoGuiDrawingArea; extern struct structClassInfo theClassInfo_GuiDrawingArea; extern ClassInfo classGuiDrawingArea; typedef structGuiControl GuiDrawingArea_Parent; struct structGuiDrawingArea : public structGuiControl {
 GuiScrollBar d_horizontalScrollBar, d_verticalScrollBar;
 GuiDrawingArea_ExposeCallback d_exposeCallback;
 Thing d_exposeBoss;
 GuiDrawingArea_ClickCallback d_clickCallback;
 Thing d_clickBoss;
 GuiDrawingArea_KeyCallback d_keyCallback;
 Thing d_keyBoss;
 GuiDrawingArea_ResizeCallback d_resizeCallback;
 Thing d_resizeBoss;
};



GuiDrawingArea GuiDrawingArea_create (GuiForm parent, int left, int right, int top, int bottom,
 GuiDrawingArea_ExposeCallback exposeCallback,
 GuiDrawingArea_ClickCallback clickCallback,
 GuiDrawingArea_KeyCallback keyCallback,
 GuiDrawingArea_ResizeCallback resizeCallback, Thing boss,
 uint32 flags);
GuiDrawingArea GuiDrawingArea_createShown (GuiForm parent, int left, int right, int top, int bottom,
 GuiDrawingArea_ExposeCallback exposeCallback,
 GuiDrawingArea_ClickCallback clickCallback,
 GuiDrawingArea_KeyCallback keyCallback,
 GuiDrawingArea_ResizeCallback resizeCallback, Thing boss,
 uint32 flags);
GuiDrawingArea GuiDrawingArea_create (GuiScrolledWindow parent, int width, int height,
 GuiDrawingArea_ExposeCallback exposeCallback,
 GuiDrawingArea_ClickCallback clickCallback,
 GuiDrawingArea_KeyCallback keyCallback,
 GuiDrawingArea_ResizeCallback resizeCallback, Thing boss,
 uint32 flags);
GuiDrawingArea GuiDrawingArea_createShown (GuiScrolledWindow parent, int width, int height,
 GuiDrawingArea_ExposeCallback exposeCallback,
 GuiDrawingArea_ClickCallback clickCallback,
 GuiDrawingArea_KeyCallback keyCallback,
 GuiDrawingArea_ResizeCallback resizeCallback, Thing boss,
 uint32 flags);

void GuiDrawingArea_setSwipable (GuiDrawingArea me, GuiScrollBar horizontalScrollBar, GuiScrollBar verticalScrollBar);
void GuiDrawingArea_setExposeCallback (GuiDrawingArea me, GuiDrawingArea_ExposeCallback callback, Thing boss);
void GuiDrawingArea_setClickCallback (GuiDrawingArea me, GuiDrawingArea_ClickCallback callback, Thing boss);
void GuiDrawingArea_setResizeCallback (GuiDrawingArea me, GuiDrawingArea_ResizeCallback callback, Thing boss);



autoStringSet GuiFileSelect_getInfileNames (GuiWindow parent, conststring32 title, bool allowMultipleFiles);
autostring32 GuiFileSelect_getOutfileName (GuiWindow parent, conststring32 title, conststring32 defaultName);
autostring32 GuiFileSelect_getDirectoryName (GuiWindow parent, conststring32 title);



GuiForm GuiForm_createInScrolledWindow (GuiScrolledWindow parent);





typedef struct structGuiLabel *GuiLabel; typedef autoSomeThing <structGuiLabel> autoGuiLabel; extern struct structClassInfo theClassInfo_GuiLabel; extern ClassInfo classGuiLabel; typedef structGuiControl GuiLabel_Parent; struct structGuiLabel : public structGuiControl {
};




GuiLabel GuiLabel_create (GuiForm parent, int left, int right, int top, int bottom,
 conststring32 text, uint32 flags);
GuiLabel GuiLabel_createShown (GuiForm parent, int left, int right, int top, int bottom,
 conststring32 text, uint32 flags);

void GuiLabel_setText (GuiLabel me, conststring32 text );



typedef struct structGuiList *GuiList; typedef autoSomeThing <structGuiList> autoGuiList; extern struct structClassInfo theClassInfo_GuiList; extern ClassInfo classGuiList;
typedef struct structGuiScrolledWindow *GuiScrolledWindow; typedef autoSomeThing <structGuiScrolledWindow> autoGuiScrolledWindow; extern struct structClassInfo theClassInfo_GuiScrolledWindow; extern ClassInfo classGuiScrolledWindow;

typedef struct structGuiList_SelectionChangedEvent {
 GuiList list;
} *GuiList_SelectionChangedEvent;
typedef MelderCallback <void, structThing , GuiList_SelectionChangedEvent> GuiList_SelectionChangedCallback;

typedef struct structGuiList_DoubleClickEvent {
 GuiList list;
} *GuiList_DoubleClickEvent;
typedef MelderCallback <void, structThing , GuiList_DoubleClickEvent> GuiList_DoubleClickCallback;

typedef struct structGuiList_ScrollEvent {
 GuiList list;
} *GuiList_ScrollEvent;
typedef MelderCallback <void, structThing , GuiList_ScrollEvent> GuiList_ScrollCallback;

typedef struct structGuiList *GuiList; typedef autoSomeThing <structGuiList> autoGuiList; extern struct structClassInfo theClassInfo_GuiList; extern ClassInfo classGuiList; typedef structGuiControl GuiList_Parent; struct structGuiList : public structGuiControl {
 bool d_allowMultipleSelection;
 GuiList_SelectionChangedCallback d_selectionChangedCallback;
 Thing d_selectionChangedBoss;
 GuiList_DoubleClickCallback d_doubleClickCallback;
 Thing d_doubleClickBoss;
 GuiList_ScrollCallback d_scrollCallback;
 Thing d_scrollBoss;



};

GuiList GuiList_create (GuiForm parent, int left, int right, int top, int bottom, bool allowMultipleSelection, conststring32 header);
GuiList GuiList_createShown (GuiForm parent, int left, int right, int top, int bottom, bool allowMultipleSelection, conststring32 header);

void GuiList_deleteAllItems (GuiList me);
void GuiList_deleteItem (GuiList me, integer position);
void GuiList_deselectAllItems (GuiList me);
void GuiList_deselectItem (GuiList me, integer position);
integer GuiList_getBottomPosition (GuiList me);
integer GuiList_getNumberOfItems (GuiList me);
autoINTVEC GuiList_getSelectedPositions (GuiList me);
integer GuiList_getTopPosition (GuiList me);
# 607 "../sys/Gui.h"
void GuiList_insertItem (GuiList me, conststring32 itemText , integer position);

void GuiList_replaceItem (GuiList me, conststring32 itemText , integer position);
void GuiList_setTopPosition (GuiList me, integer topPosition);
void GuiList_selectItem (GuiList me, integer position);
void GuiList_setSelectionChangedCallback (GuiList me, GuiList_SelectionChangedCallback callback, Thing boss);
void GuiList_setDoubleClickCallback (GuiList me, GuiList_DoubleClickCallback callback, Thing boss);
void GuiList_setScrollCallback (GuiList me, GuiList_ScrollCallback callback, Thing boss);



typedef struct structGuiMenuItem *GuiMenuItem; typedef autoSomeThing <structGuiMenuItem> autoGuiMenuItem; extern struct structClassInfo theClassInfo_GuiMenuItem; extern ClassInfo classGuiMenuItem;

typedef struct structGuiMenu *GuiMenu; typedef autoSomeThing <structGuiMenu> autoGuiMenu; extern struct structClassInfo theClassInfo_GuiMenu; extern ClassInfo classGuiMenu; typedef structGuiThing GuiMenu_Parent; struct structGuiMenu : public structGuiThing {
 autoGuiMenuItem d_menuItem;
 autoGuiButton d_cascadeButton;
# 634 "../sys/Gui.h"
 void v_destroy () noexcept
  override;
 void v_show ()
  override;
 void v_hide ()
  override;
 void v_setSensitive (bool sensitive)
  override;
};

GuiMenu GuiMenu_createInWindow (GuiWindow window, conststring32 title, uint32 flags);
GuiMenu GuiMenu_createInMenu (GuiMenu supermenu, conststring32 title, uint32 flags);
GuiMenu GuiMenu_createInForm (GuiForm form, int left, int right, int top, int bottom, conststring32 title, uint32 flags);

void GuiMenu_empty (GuiMenu me);



typedef struct structGuiMenuItem *GuiMenuItem; typedef autoSomeThing <structGuiMenuItem> autoGuiMenuItem; extern struct structClassInfo theClassInfo_GuiMenuItem; extern ClassInfo classGuiMenuItem;

typedef struct structGuiMenuItemEvent {
 GuiMenuItem menuItem;
 bool shiftKeyPressed, commandKeyPressed, optionKeyPressed, extraControlKeyPressed;
} *GuiMenuItemEvent;

typedef MelderCallback <void, structThing , GuiMenuItemEvent> GuiMenuItemCallback;

typedef struct structGuiMenuItem *GuiMenuItem; typedef autoSomeThing <structGuiMenuItem> autoGuiMenuItem; extern struct structClassInfo theClassInfo_GuiMenuItem; extern ClassInfo classGuiMenuItem; typedef structGuiThing GuiMenuItem_Parent; struct structGuiMenuItem : public structGuiThing {
 GuiMenu d_menu;
 GuiMenuItemCallback d_callback;
 Thing d_boss;



};
# 713 "../sys/Gui.h"
GuiMenuItem GuiMenu_addItem (GuiMenu menu, conststring32 title, uint32 flags,
 GuiMenuItemCallback callback, Thing boss);

GuiMenuItem GuiMenu_addSeparator (GuiMenu menu);

void GuiMenuItem_check (GuiMenuItem me, bool check);



typedef struct structGuiOptionMenu *GuiOptionMenu; typedef autoSomeThing <structGuiOptionMenu> autoGuiOptionMenu; extern struct structClassInfo theClassInfo_GuiOptionMenu; extern ClassInfo classGuiOptionMenu; typedef structGuiControl GuiOptionMenu_Parent; struct structGuiOptionMenu : public structGuiControl {
 int d_value;
 OrderedOf<structGuiMenuItem> d_options;







 void v_show ()
  override;
};

void GuiOptionMenu_init (GuiOptionMenu me, GuiForm parent, int left, int right, int top, int bottom, uint32 flags);
GuiOptionMenu GuiOptionMenu_create (GuiForm parent, int left, int right, int top, int bottom, uint32 flags);
GuiOptionMenu GuiOptionMenu_createShown (GuiForm parent, int left, int right, int top, int bottom, uint32 flags);

void GuiOptionMenu_addOption (GuiOptionMenu me, conststring32 text);
int GuiOptionMenu_getValue (GuiOptionMenu me);
void GuiOptionMenu_setValue (GuiOptionMenu me, int value);



typedef struct structGuiProgressBar *GuiProgressBar; typedef autoSomeThing <structGuiProgressBar> autoGuiProgressBar; extern struct structClassInfo theClassInfo_GuiProgressBar; extern ClassInfo classGuiProgressBar;

typedef struct structGuiProgressBar *GuiProgressBar; typedef autoSomeThing <structGuiProgressBar> autoGuiProgressBar; extern struct structClassInfo theClassInfo_GuiProgressBar; extern ClassInfo classGuiProgressBar; typedef structGuiControl GuiProgressBar_Parent; struct structGuiProgressBar : public structGuiControl {



};

GuiProgressBar GuiProgressBar_create (GuiForm parent, int left, int right, int top, int bottom, uint32 flags);
GuiProgressBar GuiProgressBar_createShown (GuiForm parent, int left, int right, int top, int bottom, uint32 flags);

void GuiProgressBar_setValue (GuiProgressBar me, double value);



typedef struct structGuiRadioButton *GuiRadioButton; typedef autoSomeThing <structGuiRadioButton> autoGuiRadioButton; extern struct structClassInfo theClassInfo_GuiRadioButton; extern ClassInfo classGuiRadioButton;

typedef struct structGuiRadioButtonEvent {
 GuiRadioButton toggle;
 int position;
} *GuiRadioButtonEvent;

typedef MelderCallback <void, structThing , GuiRadioButtonEvent> GuiRadioButtonCallback;

typedef struct structGuiRadioButton *GuiRadioButton; typedef autoSomeThing <structGuiRadioButton> autoGuiRadioButton; extern struct structClassInfo theClassInfo_GuiRadioButton; extern ClassInfo classGuiRadioButton; typedef structGuiControl GuiRadioButton_Parent; struct structGuiRadioButton : public structGuiControl {
 GuiRadioButton d_previous, d_next;
 GuiRadioButtonCallback d_valueChangedCallback;
 Thing d_valueChangedBoss;



};




GuiRadioButton GuiRadioButton_create (GuiForm parent, int left, int right, int top, int bottom,
 conststring32 buttonText, GuiRadioButtonCallback valueChangedCallback, Thing valueChangedBoss, uint32 flags);
GuiRadioButton GuiRadioButton_createShown (GuiForm parent, int left, int right, int top, int bottom,
 conststring32 buttonText, GuiRadioButtonCallback valueChangedCallback, Thing valueChangedBoss, uint32 flags);

void GuiRadioGroup_begin ();
void GuiRadioGroup_end ();

bool GuiRadioButton_getValue (GuiRadioButton me);
void GuiRadioButton_set (GuiRadioButton me);



typedef struct structGuiScale *GuiScale; typedef autoSomeThing <structGuiScale> autoGuiScale; extern struct structClassInfo theClassInfo_GuiScale; extern ClassInfo classGuiScale;

typedef struct structGuiScale *GuiScale; typedef autoSomeThing <structGuiScale> autoGuiScale; extern struct structClassInfo theClassInfo_GuiScale; extern ClassInfo classGuiScale; typedef structGuiControl GuiScale_Parent; struct structGuiScale : public structGuiControl { public:



};

GuiScale GuiScale_create (GuiForm parent, int left, int right, int top, int bottom,
 int minimum, int maximum, int value, uint32 flags);
GuiScale GuiScale_createShown (GuiForm parent, int left, int right, int top, int bottom,
 int minimum, int maximum, int value, uint32 flags);

int GuiScale_getValue (GuiScale me);
void GuiScale_setValue (GuiScale me, int value);



typedef struct structGuiScrollBar *GuiScrollBar; typedef autoSomeThing <structGuiScrollBar> autoGuiScrollBar; extern struct structClassInfo theClassInfo_GuiScrollBar; extern ClassInfo classGuiScrollBar;

typedef struct structGuiScrollBarEvent {
 GuiScrollBar scrollBar;
} *GuiScrollBarEvent;

typedef MelderCallback <void, structThing , GuiScrollBarEvent> GuiScrollBarCallback;

typedef struct structGuiScrollBar *GuiScrollBar; typedef autoSomeThing <structGuiScrollBar> autoGuiScrollBar; extern struct structClassInfo theClassInfo_GuiScrollBar; extern ClassInfo classGuiScrollBar; typedef structGuiControl GuiScrollBar_Parent; struct structGuiScrollBar : public structGuiControl {
 GuiScrollBarCallback d_valueChangedCallback;
 Thing d_valueChangedBoss;
};



GuiScrollBar GuiScrollBar_create (GuiForm parent, int left, int right, int top, int bottom,
 double minimum, double maximum, double value, double sliderSize, double increment, double pageIncrement,
 GuiScrollBarCallback valueChangedCallback, Thing valueChangedBoss, uint32 flags);
GuiScrollBar GuiScrollBar_createShown (GuiForm parent, int left, int right, int top, int bottom,
 double minimum, double maximum, double value, double sliderSize, double increment, double pageIncrement,
 GuiScrollBarCallback valueChangedCallback, Thing valueChangedBoss, uint32 flags);

double GuiScrollBar_getValue (GuiScrollBar me);
double GuiScrollBar_getSliderSize (GuiScrollBar me);
void GuiScrollBar_set (GuiScrollBar me, double minimum, double maximum, double value,
 double sliderSize, double increment, double pageIncrement);



typedef struct structGuiScrolledWindow *GuiScrolledWindow; typedef autoSomeThing <structGuiScrolledWindow> autoGuiScrolledWindow; extern struct structClassInfo theClassInfo_GuiScrolledWindow; extern ClassInfo classGuiScrolledWindow;

typedef struct structGuiScrolledWindow *GuiScrolledWindow; typedef autoSomeThing <structGuiScrolledWindow> autoGuiScrolledWindow; extern struct structClassInfo theClassInfo_GuiScrolledWindow; extern ClassInfo classGuiScrolledWindow; typedef structGuiControl GuiScrolledWindow_Parent; struct structGuiScrolledWindow : public structGuiControl { public:
};

GuiScrolledWindow GuiScrolledWindow_create (GuiForm parent, int left, int right, int top, int bottom,
 int horizontalScrollbarPersistence, int verticalScrollbarPersistence, uint32 flags);
GuiScrolledWindow GuiScrolledWindow_createShown (GuiForm parent, int left, int right, int top, int bottom,
 int horizontalScrollbarPersistence, int verticalScrollbarPersistence, uint32 flags);



typedef struct structGuiText *GuiText; typedef autoSomeThing <structGuiText> autoGuiText; extern struct structClassInfo theClassInfo_GuiText; extern ClassInfo classGuiText;

typedef struct structGuiTextEvent {
 GuiText text;
} *GuiTextEvent;

typedef MelderCallback <void, structThing , GuiTextEvent> GuiText_ChangedCallback;




 typedef char * history_data;


typedef struct _history_entry_s history_entry;
struct _history_entry_s {
 history_entry *prev, *next;
 integer first, last;
 history_data text;
 bool type_del : 1;
};

typedef struct structGuiText *GuiText; typedef autoSomeThing <structGuiText> autoGuiText; extern struct structClassInfo theClassInfo_GuiText; extern ClassInfo classGuiText; typedef structGuiControl GuiText_Parent; struct structGuiText : public structGuiControl {
 GuiText_ChangedCallback d_changedCallback;
 Thing d_changedBoss;







  history_entry *d_prev, *d_next;
  GuiMenuItem d_undo_item, d_redo_item;
  bool d_history_change : 1;




};






GuiText GuiText_create (GuiForm parent, int left, int right, int top, int bottom, uint32 flags);
GuiText GuiText_createShown (GuiForm parent, int left, int right, int top, int bottom, uint32 flags);

void GuiText_copy (GuiText me);
void GuiText_cut (GuiText me);
autostring32 GuiText_getSelection (GuiText me);
autostring32 GuiText_getString (GuiText me);
autostring32 GuiText_getStringAndSelectionPosition (GuiText me, integer *first, integer *last);
void GuiText_paste (GuiText me);
void GuiText_redo (GuiText me);
void GuiText_remove (GuiText me);
void GuiText_replace (GuiText me, integer from_pos, integer to_pos, conststring32 value);
void GuiText_scrollToSelection (GuiText me);
void GuiText_setChangedCallback (GuiText me, GuiText_ChangedCallback changedCallback, Thing changedBoss);
void GuiText_setFontSize (GuiText me, double size);
void GuiText_setRedoItem (GuiText me, GuiMenuItem item);
void GuiText_setSelection (GuiText me, integer first, integer last);
void GuiText_setString (GuiText me, conststring32 text, bool undoable = true);
void GuiText_setUndoItem (GuiText me, GuiMenuItem item);
void GuiText_undo (GuiText me);



typedef struct structGuiWindow *GuiWindow; typedef autoSomeThing <structGuiWindow> autoGuiWindow; extern struct structClassInfo theClassInfo_GuiWindow; extern ClassInfo classGuiWindow; typedef structGuiShell GuiWindow_Parent; struct structGuiWindow : public structGuiShell {
# 937 "../sys/Gui.h"
};



GuiWindow GuiWindow_create (int x, int y, int width, int height, int minimumWidth, int minimumHeight,
 conststring32 title , GuiShell_GoAwayCallback goAwayCallback, Thing goAwayBoss, uint32 flags);


void GuiWindow_addMenuBar (GuiWindow me);
bool GuiWindow_setDirty (GuiWindow me, bool dirty);
# 955 "../sys/Gui.h"
void GuiWindow_setFile (GuiWindow me, MelderFile file);




void GuiObject_destroy (GuiObject me);



void Gui_setOpenDocumentCallback (void (*openDocumentCallback) (MelderFile file), void (*finishedOpeningDocumentsCallback) ());
void Gui_setQuitApplicationCallback (int (*quitApplicationCallback) (void));

extern uinteger theGuiTopLowAccelerators [8];




void Gui_injectMessageProcs (GuiWindow parent);
# 23 "../sys/Editor.h" 2
# 1 "../sys/Ui.h" 1
# 21 "../sys/Ui.h"
# 1 "../sys/Graphics.h" 1
# 22 "../sys/Ui.h" 2

# 1 "../sys/Interpreter.h" 1
# 23 "../sys/Interpreter.h"
# 1 "../sys/Formula.h" 1
# 33 "../sys/Formula.h"
typedef struct structInterpreterVariable *InterpreterVariable; typedef autoSomeThing <structInterpreterVariable> autoInterpreterVariable; extern struct structClassInfo theClassInfo_InterpreterVariable; extern ClassInfo classInterpreterVariable;

typedef struct structStackel {
# 45 "../sys/Formula.h"
 int which;
 bool owned;
# 56 "../sys/Formula.h"
  union



 {
  double number;
  autostring32 _string;
  Daata object;
  VEC numericVector;
  MAT numericMatrix;
  InterpreterVariable variable;
 };
 structStackel () {
  memset (this, 0, sizeof (structStackel));
  ((this -> which == 0) ? (void) (0) : (Melder_assert_ ("../sys/Formula.h", 70, "our which == Stackel_NUMBER"), abort ()));
  ((this -> number == 0.0) ? (void) (0) : (Melder_assert_ ("../sys/Formula.h", 71, "our number == 0.0"), abort ()));
  ((! this -> _string) ? (void) (0) : (Melder_assert_ ("../sys/Formula.h", 72, "! our _string"), abort ()));
  ((! this -> object) ? (void) (0) : (Melder_assert_ ("../sys/Formula.h", 73, "! our object"), abort ()));
  ((! this -> owned) ? (void) (0) : (Melder_assert_ ("../sys/Formula.h", 74, "! our owned"), abort ()));
 }
 void reset () {
  if (this -> which <= 0)
   return;
  if (this -> which == 1) {
   this -> _string. reset();
  } else if (this -> which == 2) {
   if (this -> owned) {
    {
     autoVEC removable;
     removable. adoptFromAmbiguousOwner (this -> numericVector);
    }
    this -> numericVector = VEC ();
   }
  } else if (this -> which == 3) {
   if (this -> owned) {
    {
     autoMAT removable;
     removable. adoptFromAmbiguousOwner (this -> numericMatrix);
    }
    this -> numericMatrix = MAT ();
   }
  }
 }
 ~structStackel () {
  this -> reset();
 }
 structStackel& operator= (structStackel&& other) noexcept {
  if (& other != this) {
   this -> reset();
   memmove (this, & other, sizeof (structStackel));
   memset (& other, 0, sizeof (structStackel));
  }
  return *this;
 }
 conststring32 getString () {
  return this -> _string.get();
 }
 autostring32 moveString () {
  return this -> _string.move();
 }
 void setString (autostring32 newString) {
  this -> reset();

   ::new (& this -> _string) autostring32();

  this -> which = 1;
  this -> _string = newString.move();
 }
 conststring32 whichText ();
} *Stackel;

struct Formula_Result {
 int expressionType;
 double numericResult;
 autostring32 stringResult;
 VEC numericVectorResult;
 MAT numericMatrixResult;
 bool owned;
 Formula_Result () {
  this -> expressionType = 0;
  this -> numericResult = 0.0;
  this -> stringResult = autostring32();
  this -> numericVectorResult = VEC ();
  this -> numericMatrixResult = MAT ();
  this -> owned = false;
 }
 void reset () {
  this -> stringResult. reset();
  if (this -> owned) {
   {
    autoVEC removable;
    removable. adoptFromAmbiguousOwner (this -> numericVectorResult);
   }
   this -> numericVectorResult = VEC ();
   {
    autoMAT mat;
    mat. adoptFromAmbiguousOwner (this -> numericMatrixResult);
   }
   this -> numericMatrixResult = MAT ();
  }
 }
 ~ Formula_Result () {
  this -> reset();
 }
};

typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter;

void Formula_compile (Interpreter interpreter, Daata data, conststring32 expression, int expressionType, bool optimize);

void Formula_run (integer row, integer col, Formula_Result *result);
# 24 "../sys/Interpreter.h" 2


# 1 "/usr/include/c++/9/unordered_map" 1 3
# 32 "/usr/include/c++/9/unordered_map" 3
       
# 33 "/usr/include/c++/9/unordered_map" 3
# 46 "/usr/include/c++/9/unordered_map" 3
# 1 "/usr/include/c++/9/bits/hashtable.h" 1 3
# 33 "/usr/include/c++/9/bits/hashtable.h" 3
       
# 34 "/usr/include/c++/9/bits/hashtable.h" 3

# 1 "/usr/include/c++/9/bits/hashtable_policy.h" 1 3
# 38 "/usr/include/c++/9/bits/hashtable_policy.h" 3

# 38 "/usr/include/c++/9/bits/hashtable_policy.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;

namespace __detail
{





  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Hashtable_base;



  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return __first != __last ? 1 : 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    { return __distance_fw(__first, __last,
      std::__iterator_category(__first)); }

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __x) const
      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
      { return std::get<0>(std::forward<_Tp>(__x)); }
  };

  template<typename _NodeAlloc>
    struct _Hashtable_alloc;



  template<typename _NodeAlloc>
    struct _ReuseOrAllocNode
    {
    private:
      using __node_alloc_type = _NodeAlloc;
      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
 : _M_nodes(__nodes), _M_h(__h) { }
      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;

      ~_ReuseOrAllocNode()
      { _M_h._M_deallocate_nodes(_M_nodes); }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 {
   if (_M_nodes)
     {
       __node_type* __node = _M_nodes;
       _M_nodes = _M_nodes->_M_next();
       __node->_M_nxt = nullptr;
       auto& __a = _M_h._M_node_allocator();
       __node_alloc_traits::destroy(__a, __node->_M_valptr());
       try
  {
    __node_alloc_traits::construct(__a, __node->_M_valptr(),
       std::forward<_Arg>(__arg));
  }
       catch(...)
  {
    _M_h._M_deallocate_node_ptr(__node);
    throw;
  }
       return __node;
     }
   return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
 }

    private:
      mutable __node_type* _M_nodes;
      __hashtable_alloc& _M_h;
    };



  template<typename _NodeAlloc>
    struct _AllocNode
    {
    private:
      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _AllocNode(__hashtable_alloc& __h)
 : _M_h(__h) { }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 { return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }

    private:
      __hashtable_alloc& _M_h;
    };
# 198 "/usr/include/c++/9/bits/hashtable_policy.h" 3
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };
# 214 "/usr/include/c++/9/bits/hashtable_policy.h" 3
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
  };






  template<typename _Value>
    struct _Hash_node_value_base : _Hash_node_base
    {
      typedef _Value value_type;

      __gnu_cxx::__aligned_buffer<_Value> _M_storage;

      _Value*
      _M_valptr() noexcept
      { return _M_storage._M_ptr(); }

      const _Value*
      _M_valptr() const noexcept
      { return _M_storage._M_ptr(); }

      _Value&
      _M_v() noexcept
      { return *_M_valptr(); }

      const _Value&
      _M_v() const noexcept
      { return *_M_valptr(); }
    };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node;






  template<typename _Value>
    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>
    {
      std::size_t _M_hash_code;

      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };






  template<typename _Value>
    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>
    {
      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base(__node_type* __p) noexcept
      : _M_cur(__p) { }

      void
      _M_incr() noexcept
      { _M_cur = _M_cur->_M_next(); }
    };

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
    noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
    noexcept
    { return __x._M_cur != __y._M_cur; }


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      using pointer = typename std::conditional<__constant_iterators,
      const _Value*, _Value*>::type;

      using reference = typename std::conditional<__constant_iterators,
        const _Value&, _Value&>::type;

      _Node_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int) noexcept
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const _Value* pointer;
      typedef const _Value& reference;

      _Node_const_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_const_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x) noexcept
      : __base_type(__x._M_cur) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_const_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int) noexcept
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    using __has_load_factor = std::true_type;

    _Prime_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };


  struct _Mask_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num & (__den - 1); }
  };


  inline std::size_t
  __clp2(std::size_t __n) noexcept
  {

    if (__n < 2)
      return __n;
    const unsigned __lz = sizeof(size_t) > sizeof(long)
      ? __builtin_clzll(__n - 1ull)
      : __builtin_clzl(__n - 1ul);

    return (size_t(1) << (numeric_limits<size_t>::digits - __lz - 1)) << 1;
  }



  struct _Power2_rehash_policy
  {
    using __has_load_factor = std::true_type;

    _Power2_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }



    std::size_t
    _M_next_bkt(std::size_t __n) noexcept
    {
      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
      const auto __max_bkt = size_t(1) << (__max_width * 8 - 1);
      std::size_t __res = __clp2(__n);

      if (__res == __n)
 __res <<= 1;

      if (__res == 0)
 __res = __max_bkt;

      if (__res == __max_bkt)



 _M_next_resize = std::size_t(-1);
      else
 _M_next_resize
   = __builtin_ceil(__res * (long double)_M_max_load_factor);

      return __res;
    }


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const noexcept
    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) noexcept
    {
      if (__n_elt + __n_ins >= _M_next_resize)
 {
   long double __min_bkts = (__n_elt + __n_ins)
     / (long double)_M_max_load_factor;
   if (__min_bkts >= __n_bkt)
     return std::make_pair(true,
       _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,
      __n_bkt * _S_growth_factor)));

   _M_next_resize
     = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);
   return std::make_pair(false, 0);
 }
      else
 return std::make_pair(false, 0);
    }

    typedef std::size_t _State;

    _State
    _M_state() const noexcept
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state) noexcept
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    std::size_t _M_next_resize;
  };
# 628 "/usr/include/c++/9/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    {
      using mapped_type = typename std::tuple_element<1, _Pair>::type;
    };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
        _Select1st,
       _Equal, _H1, _H2, _Hash,
         _Traits>;

      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
         _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;
      using __node_type = typename __hashtable_base::__node_type;

    public:
      using key_type = typename __hashtable_base::key_type;
      using iterator = typename __hashtable_base::iterator;
      using mapped_type = typename std::tuple_element<1, _Pair>::type;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k);

      const mapped_type&
      at(const key_type& __k) const;
    };

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::tuple<const key_type&>(__k),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::forward_as_tuple(std::move(__k)),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k) const
    -> const mapped_type&
    {
      const __hashtable* __h = static_cast<const __hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
    protected:
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __hashtable_base::value_type;
      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename __hashtable_base::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;
      using __node_gen_type = _AllocNode<__node_alloc_type>;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, true_type);

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, false_type);

    public:
      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__v, __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, __v, __node_gen, __unique_keys());
      }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 {
   __hashtable& __h = _M_conjure_hashtable();
   __node_gen_type __node_gen(__h);
   return _M_insert_range(__first, __last, __node_gen, __unique_keys());
 }
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, true_type)
      {
 size_type __n_elt = __detail::__distance_fw(__first, __last);
 if (__n_elt == 0)
   return;

 __hashtable& __h = _M_conjure_hashtable();
 for (; __first != __last; ++__first)
   {
     if (__h._M_insert(*__first, __node_gen, __unique_keys(),
         __n_elt).second)
       __n_elt = 1;
     else if (__n_elt != 1)
       --__n_elt;
   }
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, false_type)
      {
 using __rehash_type = typename __hashtable::__rehash_type;
 using __rehash_state = typename __hashtable::__rehash_state;
 using pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);
 if (__n_elt == 0)
   return;

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_type& __rehash = __h._M_rehash_policy;
 const __rehash_state& __saved_state = __rehash._M_state();
 pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
       __h._M_element_count,
       __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __saved_state);

 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __unique_keys());
      }







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      __ireturn_type
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys());
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _H1, _H2, _Hash,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator __hint, _Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__hint, __unique_keys(),
    std::forward<_Pair>(__v));
 }
   };

  template<typename _Policy>
    using __has_load_factor = typename _Policy::__has_load_factor;







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    typename =
      __detected_or_t<std::false_type, __has_load_factor, _RehashPolicy>>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits,
        std::false_type>
    {
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits,
   std::true_type>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_RehashPolicy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__builtin_ceil(__n / max_load_factor()));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
   : _Tp(std::forward<_OtherTp>(__tp))
 { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return static_cast<const _Tp&>(__eboh); }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
   : _M_tp(std::forward<_OtherTp>(__tp))
 { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Local_iterator_base;
# 1166 "/usr/include/c++/9/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Hash_code_base;



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;

    protected:
      typedef void* __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
        const _Hash& __h)
      : __ebo_extract_key(__ex), __ebo_hash(__h) { }

      __hash_code
      _M_hash_code(const _Key& __key) const
      { return 0; }

      std::size_t
      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const
      { return _M_ranged_hash()(__k, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),
         (std::size_t)0)) )
      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_ranged_hash(), __x._M_ranged_hash());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _Hash&
      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }

      _Hash&
      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;


      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      {
 static_assert(__is_invocable<const _H1&, const _Key&>{},
     "hash function must be invocable with an argument of key type");
 return _M_h1()(__k);
      }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))
    && noexcept(declval<const _H2&>()((__hash_code)0,
          (std::size_t)0)) )
      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:

      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>;

      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, true> __node_type;


      _Hash_code_base() = default;
      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      {
 static_assert(__is_invocable<const _H1&, const _Key&>{},
     "hash function must be invocable with an argument of key type");
 return _M_h1()(__k);
      }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _H2&>()((__hash_code)0,
       (std::size_t)0)) )
      { return _M_h2()(__p->_M_hash_code, __n); }

      void
      _M_store_code(__node_type* __n, __hash_code __c) const
      { __n->_M_hash_code = __c; }

      void
      _M_copy_code(__node_type* __to, const __node_type* __from) const
      { __to->_M_hash_code = __from->_M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };





  template <typename _Key, typename _Value, typename _ExtractKey,
     typename _Equal, typename _HashCodeType,
     bool __cache_hash_code>
  struct _Equal_helper;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)
    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v())); }
  };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)
    { return __eq(__k, __extract(__n->_M_v())); }
  };



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, true>
    : private _Hashtable_ebo_helper<0, _H2>
    {
    protected:
      using __base_type = _Hashtable_ebo_helper<0, _H2>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, true>;

      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base._M_h2()),
 _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt
       = __base_type::_S_get(*this)(_M_cur->_M_hash_code,
        _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, true>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };





  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
    struct _Hash_code_storage
    {
      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

      _Tp*
      _M_h() { return _M_storage._M_ptr(); }

      const _Tp*
      _M_h() const { return _M_storage._M_ptr(); }
    };


  template<typename _Tp>
    struct _Hash_code_storage<_Tp, true>
    {
      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );



      _Tp*
      _M_h() { return reinterpret_cast<_Tp*>(this); }

      const _Tp*
      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    using __hash_code_for_local_iter
      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash, false>>;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, false>
    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, false>;

      _Local_iterator_base() : _M_bucket_count(-1) { }

      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { _M_init(__base); }

      ~_Local_iterator_base()
      {
 if (_M_bucket_count != -1)
   _M_destroy();
      }

      _Local_iterator_base(const _Local_iterator_base& __iter)
      : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket),
        _M_bucket_count(__iter._M_bucket_count)
      {
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
      }

      _Local_iterator_base&
      operator=(const _Local_iterator_base& __iter)
      {
 if (_M_bucket_count != -1)
   _M_destroy();
 _M_cur = __iter._M_cur;
 _M_bucket = __iter._M_bucket;
 _M_bucket_count = __iter._M_bucket_count;
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
 return *this;
      }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt = this->_M_h()->_M_bucket_index(_M_cur,
             _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, false>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

      void
      _M_init(const __hash_code_base& __base)
      { ::new(this->_M_h()) __hash_code_base(__base); }

      void
      _M_destroy() { this->_M_h()->~__hash_code_base(); }

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() == __y._M_curr(); }

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() != __y._M_curr(); }


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;
    public:
      typedef _Value value_type;
      typedef typename std::conditional<__constant_iterators,
     const _Value*, _Value*>::type
             pointer;
      typedef typename std::conditional<__constant_iterators,
     const _Value&, _Value&>::type
             reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __p,
        std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __p,
       std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash,
        __constant_iterators,
        __cache>& __x)
 : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
# 1767 "/usr/include/c++/9/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
  struct _Hashtable_base
  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
      _Traits::__hash_cached::value>,
    private _Hashtable_ebo_helper<0, _Equal>
  {
  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Equal key_equal;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;
    using __constant_iterators = typename __traits_type::__constant_iterators;
    using __unique_keys = typename __traits_type::__unique_keys;

    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _H1, _H2, _Hash,
          __hash_cached::value>;

    using __hash_code = typename __hash_code_base::__hash_code;
    using __node_type = typename __hash_code_base::__node_type;

    using iterator = __detail::_Node_iterator<value_type,
           __constant_iterators::value,
           __hash_cached::value>;

    using const_iterator = __detail::_Node_const_iterator<value_type,
         __constant_iterators::value,
         __hash_cached::value>;

    using local_iterator = __detail::_Local_iterator<key_type, value_type,
        _ExtractKey, _H1, _H2, _Hash,
        __constant_iterators::value,
           __hash_cached::value>;

    using const_local_iterator = __detail::_Local_const_iterator<key_type,
         value_type,
     _ExtractKey, _H1, _H2, _Hash,
     __constant_iterators::value,
     __hash_cached::value>;

    using __ireturn_type = typename std::conditional<__unique_keys::value,
           std::pair<iterator, bool>,
           iterator>::type;
  private:
    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
    using _EqualHelper = _Equal_helper<_Key, _Value, _ExtractKey, _Equal,
     __hash_code, __hash_cached::value>;

  protected:
    _Hashtable_base() = default;
    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
      const _Hash& __hash, const _Equal& __eq)
    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
    { }

    bool
    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
    {
      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
   "key equality predicate must be invocable with two arguments of "
   "key type");
      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),
         __k, __c, __n);
    }

    void
    _M_swap(_Hashtable_base& __x)
    {
      __hash_code_base::_M_swap(__x);
      std::swap(_M_eq(), __x._M_eq());
    }

    const _Equal&
    _M_eq() const { return _EqualEBO::_S_cget(*this); }

    _Equal&
    _M_eq() { return _EqualEBO::_S_get(*this); }
  };






  struct _Equality_base
  {
  protected:
    template<typename _Uiterator>
      static bool
      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
  };


  template<typename _Uiterator>
    bool
    _Equality_base::
    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
        _Uiterator __first2)
    {
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   break;

      if (__first1 == __last1)
 return true;

      _Uiterator __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));

      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
 {
   _Uiterator __tmp = __first1;
   while (__tmp != __it1 && !bool(*__tmp == *__it1))
     ++__tmp;


   if (__tmp != __it1)
     continue;

   std::ptrdiff_t __n2 = 0;
   for (__tmp = __first2; __tmp != __last2; ++__tmp)
     if (*__tmp == *__it1)
       ++__n2;

   if (!__n2)
     return false;

   std::ptrdiff_t __n1 = 0;
   for (__tmp = __it1; __tmp != __last1; ++__tmp)
     if (*__tmp == *__it1)
       ++__n1;

   if (__n1 != __n2)
     return false;
 }
      return true;
    }
# 1919 "/usr/include/c++/9/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
 {
   const auto __ity = __other.find(_ExtractKey()(*__itx));
   if (__ity == __other.end() || !bool(*__ity == *__itx))
     return false;
 }
      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    : public _Equality_base
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end();)
 {
   const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
   const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));

   if (std::distance(__xrange.first, __xrange.second)
       != std::distance(__yrange.first, __yrange.second))
     return false;

   if (!_S_is_permutation(__xrange.first, __xrange.second,
     __yrange.first))
     return false;

   __itx = __xrange.second;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    {
    private:
      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
    public:
      using __node_type = typename _NodeAlloc::value_type;
      using __node_alloc_type = _NodeAlloc;

      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

      using __value_alloc_traits = typename __node_alloc_traits::template
 rebind_traits<typename __node_type::value_type>;

      using __node_base = __detail::_Hash_node_base;
      using __bucket_type = __node_base*;
      using __bucket_alloc_type =
 __alloc_rebind<__node_alloc_type, __bucket_type>;
      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;

      _Hashtable_alloc() = default;
      _Hashtable_alloc(const _Hashtable_alloc&) = default;
      _Hashtable_alloc(_Hashtable_alloc&&) = default;

      template<typename _Alloc>
 _Hashtable_alloc(_Alloc&& __a)
   : __ebo_node_alloc(std::forward<_Alloc>(__a))
 { }

      __node_alloc_type&
      _M_node_allocator()
      { return __ebo_node_alloc::_S_get(*this); }

      const __node_alloc_type&
      _M_node_allocator() const
      { return __ebo_node_alloc::_S_cget(*this); }

      template<typename... _Args>
 __node_type*
 _M_allocate_node(_Args&&... __args);

      void
      _M_deallocate_node(__node_type* __n);

      void
      _M_deallocate_node_ptr(__node_type* __n);


      void
      _M_deallocate_nodes(__node_type* __n);

      __bucket_type*
      _M_allocate_buckets(std::size_t __n);

      void
      _M_deallocate_buckets(__bucket_type*, std::size_t __n);
    };



  template<typename _NodeAlloc>
    template<typename... _Args>
      typename _Hashtable_alloc<_NodeAlloc>::__node_type*
      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      {
 auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
 __node_type* __n = std::__to_address(__nptr);
 try
   {
     ::new ((void*)__n) __node_type;
     __node_alloc_traits::construct(_M_node_allocator(),
        __n->_M_valptr(),
        std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
     throw;
   }
      }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)
    {
      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
      _M_deallocate_node_ptr(__n);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_type* __n)
    {
      typedef typename __node_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      __n->~__node_type();
      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)
    {
      while (__n)
 {
   __node_type* __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _NodeAlloc>
    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*
    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __n)
    {
      __bucket_alloc_type __alloc(_M_node_allocator());

      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);
      __bucket_type* __p = std::__to_address(__ptr);
      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
      return __p;
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,
       std::size_t __n)
    {
      typedef typename __bucket_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      __bucket_alloc_type __alloc(_M_node_allocator());
      __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);
    }


}

}
# 36 "/usr/include/c++/9/bits/hashtable.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,

         __is_nothrow_invocable<const _Hash&, const _Tp&>>>;
# 169 "/usr/include/c++/9/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _H1, _H2, _Hash, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      private __detail::_Hashtable_alloc<
 __alloc_rebind<_Alloc,
         __detail::_Hash_node<_Value,
         _Traits::__hash_cached::value>>>
    {
      static_assert(is_same<typename remove_cv<_Value>::type, _Value>::value,
   "unordered container must have a non-const, non-volatile value_type");





      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;

      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_base = typename __hashtable_alloc::__node_base;
      using __bucket_type = typename __hashtable_alloc::__bucket_type;

    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename __value_alloc_traits::pointer pointer;
      typedef typename __value_alloc_traits::const_pointer const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;

    private:
      using __rehash_type = _RehashPolicy;
      using __rehash_state = typename __rehash_type::_State;

      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __unique_keys = typename __traits_type::__unique_keys;

      using __key_extract = typename std::conditional<
          __constant_iterators::value,
                 __detail::_Identity,
          __detail::_Select1st>::type;

      using __hashtable_base = __detail::
          _Hashtable_base<_Key, _Value, _ExtractKey,
           _Equal, _H1, _H2, _Hash, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _H1, _H2, _Hash,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __reuse_or_alloc_node_type =
 __detail::_ReuseOrAllocNode<__node_alloc_type>;


      template<typename _Cond>
 using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;

      template<typename _Cond>
 using __if_hash_not_cached = __or_<__hash_cached, _Cond>;





      struct __hash_code_base_access : __hash_code_base
      { using __hash_code_base::_M_bucket_index; };



      static_assert(noexcept(declval<const __hash_code_base_access&>()
        ._M_bucket_index((const __node_type*)nullptr,
           (std::size_t)0)),
      "Cache the hash code or qualify your functors involved"
      " in hash code and bucket index computation with noexcept");






      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
      "Functor used to map hash code to bucket index"
      " must be default constructible");

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa>
 friend struct __detail::_Insert;

    public:
      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;

      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;

      using local_iterator = typename __hashtable_base::local_iterator;
      using const_local_iterator = typename __hashtable_base::
       const_local_iterator;






    private:
      __bucket_type* _M_buckets = &_M_single_bucket;
      size_type _M_bucket_count = 1;
      __node_base _M_before_begin;
      size_type _M_element_count = 0;
      _RehashPolicy _M_rehash_policy;







      __bucket_type _M_single_bucket = nullptr;

      bool
      _M_uses_single_bucket(__bucket_type* __bkts) const
      { return __builtin_expect(__bkts == &_M_single_bucket, false); }

      bool
      _M_uses_single_bucket() const
      { return _M_uses_single_bucket(_M_buckets); }

      __hashtable_alloc&
      _M_base_alloc() { return *this; }

      __bucket_type*
      _M_allocate_buckets(size_type __n)
      {
 if (__builtin_expect(__n == 1, false))
   {
     _M_single_bucket = nullptr;
     return &_M_single_bucket;
   }

 return __hashtable_alloc::_M_allocate_buckets(__n);
      }

      void
      _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)
      {
 if (_M_uses_single_bucket(__bkts))
   return;

 __hashtable_alloc::_M_deallocate_buckets(__bkts, __n);
      }

      void
      _M_deallocate_buckets()
      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }



      __node_type*
      _M_bucket_begin(size_type __bkt) const;

      __node_type*
      _M_begin() const
      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }



      template<typename _Ht, typename _NodeGenerator>
 void
 _M_assign_elements(_Ht&&, const _NodeGenerator&);

      template<typename _NodeGenerator>
 void
 _M_assign(const _Hashtable&, const _NodeGenerator&);

      void
      _M_move_assign(_Hashtable&&, std::true_type);

      void
      _M_move_assign(_Hashtable&&, std::false_type);

      void
      _M_reset() noexcept;

      _Hashtable(const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
 : __hashtable_base(__exk, __h1, __h2, __h, __eq),
   __hashtable_alloc(__node_alloc_type(__a))
      { }

    public:

      _Hashtable() = default;
      _Hashtable(size_type __bucket_hint,
   const _H1&, const _H2&, const _Hash&,
   const _Equal&, const _ExtractKey&,
   const allocator_type&);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bucket_hint,
     const _H1&, const _H2&, const _Hash&,
     const _Equal&, const _ExtractKey&,
     const allocator_type&);

      _Hashtable(const _Hashtable&);

      _Hashtable(_Hashtable&&) noexcept;

      _Hashtable(const _Hashtable&, const allocator_type&);

      _Hashtable(_Hashtable&&, const allocator_type&);


      explicit
      _Hashtable(const allocator_type& __a)
 : __hashtable_alloc(__node_alloc_type(__a))
      { }

      explicit
      _Hashtable(size_type __n,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__n, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __n = 0,
     const _H1& __hf = _H1(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __n, __hf, _H2(), _Hash(), __eql,
       __key_extract(), __a)
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __n = 0,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __n, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht);

      _Hashtable&
      operator=(_Hashtable&& __ht)
      noexcept(__node_alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_H1>::value
        && is_nothrow_move_assignable<_Equal>::value)
      {
        constexpr bool __move_storage =
   __node_alloc_traits::_S_propagate_on_move_assign()
   || __node_alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 __reuse_or_alloc_node_type __roan(_M_begin(), *this);
 _M_before_begin._M_nxt = nullptr;
 clear();
 this->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys());
 return *this;
      }

      ~_Hashtable() noexcept;

      void
      swap(_Hashtable&)
      noexcept(__and_<__is_nothrow_swappable<_H1>,
                   __is_nothrow_swappable<_Equal>>::value);


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(this->_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __n) const
      { return std::distance(begin(__n), end(__n)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __n)
      {
 return local_iterator(*this, _M_bucket_begin(__n),
         __n, _M_bucket_count);
      }

      local_iterator
      end(size_type __n)
      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }

      const_local_iterator
      begin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy& __pol)
      { _M_rehash_policy = __pol; }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

    protected:

      size_type
      _M_bucket_index(__node_type* __n) const noexcept
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(const key_type& __k, __hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }



      __node_base*
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      __node_type*
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_type*>(__before_n->_M_nxt);
 return nullptr;
      }


      void
      _M_insert_bucket_begin(size_type, __node_type*);


      void
      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
        size_type __next_bkt);


      __node_base*
      _M_get_previous_node(size_type __bkt, __node_base* __n);




      iterator
      _M_insert_unique_node(size_type __bkt, __hash_code __code,
       __node_type* __n, size_type __n_elt = 1);



      iterator
      _M_insert_multi_node(__node_type* __hint,
      __hash_code __code, __node_type* __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(std::true_type, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(std::false_type __uk, _Args&&... __args)
 { return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }


      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, std::true_type __uk, _Args&&... __args)
 { return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }

      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, std::false_type, _Args&&... __args);

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert(_Arg&&, const _NodeGenerator&, true_type, size_type = 1);

      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    false_type __uk)
 {
   return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,
      __uk);
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&& __arg,
    const _NodeGenerator& __node_gen, true_type __uk)
 {
   return
     _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&&,
    const _NodeGenerator&, false_type);

      size_type
      _M_erase(std::true_type, const key_type&);

      size_type
      _M_erase(std::false_type, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __hint, _Args&&... __args)
 {
   return _M_emplace(__hint, __unique_keys(),
       std::forward<_Args>(__args)...);
 }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys(), __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;


      void rehash(size_type __n);
# 919 "/usr/include/c++/9/bits/hashtable.h" 3
    private:

      void _M_rehash_aux(size_type __n, std::true_type);


      void _M_rehash_aux(size_type __n, std::false_type);



      void _M_rehash(size_type __n, const __rehash_state& __state);
    };



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_bucket_begin(size_type __bkt) const
    -> __node_type*
    {
      __node_base* __n = _M_buckets[__bkt];
      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bucket_hint,
        const _H1& __h1, const _H2& __h2, const _Hash& __h,
        const _Equal& __eq, const _ExtractKey& __exk,
        const allocator_type& __a)
      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
    {
      auto __bkt = _M_rehash_policy._M_next_bkt(__bucket_hint);
      if (__bkt > _M_bucket_count)
 {
   _M_buckets = _M_allocate_buckets(__bkt);
   _M_bucket_count = __bkt;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bucket_hint,
   const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
 : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 auto __bkt_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bucket_hint));

 if (__bkt_count > _M_bucket_count)
   {
     _M_buckets = _M_allocate_buckets(__bkt_count);
     _M_bucket_count = __bkt_count;
   }

 for (; __f != __l; ++__f)
   this->insert(*__f);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    operator=(const _Hashtable& __ht)
    -> _Hashtable&
    {
      if (&__ht == this)
 return *this;

      if (__node_alloc_traits::_S_propagate_on_copy_assign())
 {
   auto& __this_alloc = this->_M_node_allocator();
   auto& __that_alloc = __ht._M_node_allocator();
   if (!__node_alloc_traits::_S_always_equal()
       && __this_alloc != __that_alloc)
     {

       this->_M_deallocate_nodes(_M_begin());
       _M_before_begin._M_nxt = nullptr;
       _M_deallocate_buckets();
       _M_buckets = nullptr;
       std::__alloc_on_copy(__this_alloc, __that_alloc);
       __hashtable_base::operator=(__ht);
       _M_bucket_count = __ht._M_bucket_count;
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       try
  {
    _M_assign(__ht,
       [this](const __node_type* __n)
       { return this->_M_allocate_node(__n->_M_v()); });
  }
       catch(...)
  {


    _M_reset();
    throw;
  }
       return *this;
     }
   std::__alloc_on_copy(__this_alloc, __that_alloc);
 }


      _M_assign_elements(__ht,
 [](const __reuse_or_alloc_node_type& __roan, const __node_type* __n)
 { return __roan(__n->_M_v()); });
      return *this;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Ht, typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign_elements(_Ht&& __ht, const _NodeGenerator& __node_gen)
      {
 __bucket_type* __former_buckets = nullptr;
 std::size_t __former_bucket_count = _M_bucket_count;
 const __rehash_state& __former_state = _M_rehash_policy._M_state();

 if (_M_bucket_count != __ht._M_bucket_count)
   {
     __former_buckets = _M_buckets;
     _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
     _M_bucket_count = __ht._M_bucket_count;
   }
 else
   __builtin_memset(_M_buckets, 0,
      _M_bucket_count * sizeof(__bucket_type));

 try
   {
     __hashtable_base::operator=(std::forward<_Ht>(__ht));
     _M_element_count = __ht._M_element_count;
     _M_rehash_policy = __ht._M_rehash_policy;
     __reuse_or_alloc_node_type __roan(_M_begin(), *this);
     _M_before_begin._M_nxt = nullptr;
     _M_assign(__ht,
        [&__node_gen, &__roan](__node_type* __n)
        { return __node_gen(__roan, __n); });
     if (__former_buckets)
       _M_deallocate_buckets(__former_buckets, __former_bucket_count);
   }
 catch(...)
   {
     if (__former_buckets)
       {

  _M_deallocate_buckets();
  _M_rehash_policy._M_reset(__former_state);
  _M_buckets = __former_buckets;
  _M_bucket_count = __former_bucket_count;
       }
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__bucket_type));
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign(const _Hashtable& __ht, const _NodeGenerator& __node_gen)
      {
 __bucket_type* __buckets = nullptr;
 if (!_M_buckets)
   _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

 try
   {
     if (!__ht._M_before_begin._M_nxt)
       return;



     __node_type* __ht_n = __ht._M_begin();
     __node_type* __this_n = __node_gen(__ht_n);
     this->_M_copy_code(__this_n, __ht_n);
     _M_before_begin._M_nxt = __this_n;
     _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;


     __node_base* __prev_n = __this_n;
     for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
       {
  __this_n = __node_gen(__ht_n);
  __prev_n->_M_nxt = __this_n;
  this->_M_copy_code(__this_n, __ht_n);
  size_type __bkt = _M_bucket_index(__this_n);
  if (!_M_buckets[__bkt])
    _M_buckets[__bkt] = __prev_n;
  __prev_n = __this_n;
       }
   }
 catch(...)
   {
     clear();
     if (__buckets)
       _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_reset() noexcept
    {
      _M_rehash_policy._M_reset();
      _M_bucket_count = 1;
      _M_single_bucket = nullptr;
      _M_buckets = &_M_single_bucket;
      _M_before_begin._M_nxt = nullptr;
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, std::true_type)
    {
      this->_M_deallocate_nodes(_M_begin());
      _M_deallocate_buckets();
      __hashtable_base::operator=(std::move(__ht));
      _M_rehash_policy = __ht._M_rehash_policy;
      if (!__ht._M_uses_single_bucket())
 _M_buckets = __ht._M_buckets;
      else
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }
      _M_bucket_count = __ht._M_bucket_count;
      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
      _M_element_count = __ht._M_element_count;
      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, std::false_type)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 _M_move_assign(std::move(__ht), std::true_type());
      else
 {

   _M_assign_elements(std::move(__ht),
  [](const __reuse_or_alloc_node_type& __roan, __node_type* __n)
  { return __roan(std::move_if_noexcept(__n->_M_v())); });
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(
 __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht) noexcept
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__ht._M_base_alloc())),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_before_begin(__ht._M_before_begin._M_nxt),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (__ht._M_uses_single_bucket())
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 {
   if (__ht._M_uses_single_bucket())
     {
       _M_buckets = &_M_single_bucket;
       _M_single_bucket = __ht._M_single_bucket;
     }
   else
     _M_buckets = __ht._M_buckets;

   _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;


   if (_M_begin())
     _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
   __ht._M_reset();
 }
      else
 {
   _M_assign(__ht,
      [this](__node_type* __n)
      {
        return this->_M_allocate_node(
     std::move_if_noexcept(__n->_M_v()));
      });
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {
      clear();
      _M_deallocate_buckets();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    noexcept(__and_<__is_nothrow_swappable<_H1>,
                 __is_nothrow_swappable<_Equal>>::value)
    {



      this->_M_swap(__x);

      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
      std::swap(_M_rehash_policy, __x._M_rehash_policy);


      if (this->_M_uses_single_bucket())
 {
   if (!__x._M_uses_single_bucket())
     {
       _M_buckets = __x._M_buckets;
       __x._M_buckets = &__x._M_single_bucket;
     }
 }
      else if (__x._M_uses_single_bucket())
 {
   __x._M_buckets = _M_buckets;
   _M_buckets = &_M_single_bucket;
 }
      else
 std::swap(_M_buckets, __x._M_buckets);

      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);
      std::swap(_M_single_bucket, __x._M_single_bucket);



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      if (__x._M_begin())
 __x._M_buckets[__x._M_bucket_index(__x._M_begin())]
   = &__x._M_before_begin;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    -> iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    -> const_iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? const_iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_bucket_begin(__n);
      if (!__p)
 return 0;

      std::size_t __result = 0;
      for (;; __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     ++__result;
   else if (__result)



     break;
   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
 }
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    -> pair<iterator, iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(iterator(__p), iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    -> pair<const_iterator, const_iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(const_iterator(__p), const_iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __n, const key_type& __k,
   __hash_code __code) const
    -> __node_base*
    {
      __node_base* __prev_p = _M_buckets[__n];
      if (!__prev_p)
 return nullptr;

      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;
    __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     return __prev_p;

   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
   __prev_p = __p;
 }
      return nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
    {
      if (_M_buckets[__bkt])
 {


   __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   _M_buckets[__bkt]->_M_nxt = __node;
 }
      else
 {



   __node->_M_nxt = _M_before_begin._M_nxt;
   _M_before_begin._M_nxt = __node;
   if (__node->_M_nxt)


     _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
   _M_buckets[__bkt] = &_M_before_begin;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
      size_type __next_bkt)
    {
      if (!__next || __next_bkt != __bkt)
 {


   if (__next)
     _M_buckets[__next_bkt] = _M_buckets[__bkt];


   if (&_M_before_begin == _M_buckets[__bkt])
     _M_before_begin._M_nxt = __next;
   _M_buckets[__bkt] = nullptr;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_base* __n)
    -> __node_base*
    {
      __node_base* __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(std::true_type, _Args&&... __args)
      -> pair<iterator, bool>
      {

 __node_type* __node = this->_M_allocate_node(std::forward<_Args>(__args)...);
 const key_type& __k = this->_M_extract()(__node->_M_v());
 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(__k);
   }
 catch(...)
   {
     this->_M_deallocate_node(__node);
     throw;
   }

 size_type __bkt = _M_bucket_index(__k, __code);
 if (__node_type* __p = _M_find_node(__bkt, __k, __code))
   {

     this->_M_deallocate_node(__node);
     return std::make_pair(iterator(__p), false);
   }


 return std::make_pair(_M_insert_unique_node(__bkt, __code, __node),
         true);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)
      -> iterator
      {

 __node_type* __node =
   this->_M_allocate_node(std::forward<_Args>(__args)...);

 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(this->_M_extract()(__node->_M_v()));
   }
 catch(...)
   {
     this->_M_deallocate_node(__node);
     throw;
   }

 return _M_insert_multi_node(__hint._M_cur, __code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_unique_node(size_type __bkt, __hash_code __code,
     __node_type* __node, size_type __n_elt)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
       __n_elt);

      try
 {
   if (__do_rehash.first)
     {
       _M_rehash(__do_rehash.second, __saved_state);
       __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);
     }

   this->_M_store_code(__node, __code);


   _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   this->_M_deallocate_node(__node);
   throw;
 }
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__node_type* __hint, __hash_code __code,
    __node_type* __node)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     _M_rehash(__do_rehash.second, __saved_state);

   this->_M_store_code(__node, __code);
   const key_type& __k = this->_M_extract()(__node->_M_v());
   size_type __bkt = _M_bucket_index(__k, __code);



   __node_base* __prev
     = __builtin_expect(__hint != nullptr, false)
       && this->_M_equals(__k, __code, __hint)
  ? __hint
  : _M_find_before_node(__bkt, __k, __code);
   if (__prev)
     {

       __node->_M_nxt = __prev->_M_nxt;
       __prev->_M_nxt = __node;
       if (__builtin_expect(__prev == __hint, false))


        if (__node->_M_nxt
            && !this->_M_equals(__k, __code, __node->_M_next()))
          {
            size_type __next_bkt = _M_bucket_index(__node->_M_next());
            if (__next_bkt != __bkt)
              _M_buckets[__next_bkt] = __node;
          }
     }
   else




     _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   this->_M_deallocate_node(__node);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, true_type,
  size_type __n_elt)
      -> pair<iterator, bool>
      {
 const key_type& __k = this->_M_extract()(__v);
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);

 __node_type* __n = _M_find_node(__bkt, __k, __code);
 if (__n)
   return std::make_pair(iterator(__n), false);

 __n = __node_gen(std::forward<_Arg>(__v));
 return { _M_insert_unique_node(__bkt, __code, __n, __n_elt), true };
      }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(const_iterator __hint, _Arg&& __v,
  const _NodeGenerator& __node_gen, false_type)
      -> iterator
      {


 __hash_code __code = this->_M_hash_code(this->_M_extract()(__v));


 __node_type* __node = __node_gen(std::forward<_Arg>(__v));

 return _M_insert_multi_node(__hint._M_cur, __code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    -> iterator
    {
      __node_type* __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(__n);




      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
    -> iterator
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
    __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      this->_M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::true_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;


      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::false_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;







      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      __node_type* __n_last = __n;
      std::size_t __n_last_bkt = __bkt;
      do
 {
   __n_last = __n_last->_M_next();
   if (!__n_last)
     break;
   __n_last_bkt = _M_bucket_index(__n_last);
 }
      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));


      size_type __result = 0;
      do
 {
   __node_type* __p = __n->_M_next();
   this->_M_deallocate_node(__n);
   __n = __p;
   ++__result;
   --_M_element_count;
 }
      while (__n != __n_last);

      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last && __n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    -> iterator
    {
      __node_type* __n = __first._M_cur;
      __node_type* __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(__n);

      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_type* __tmp = __n;
       __n = __n->_M_next();
       this->_M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    rehash(size_type __n)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::size_t __buckets
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __n);
      __buckets = _M_rehash_policy._M_next_bkt(__buckets);

      if (__buckets != _M_bucket_count)
 _M_rehash(__buckets, __saved_state);
      else

 _M_rehash_policy._M_reset(__saved_state);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash(size_type __n, const __rehash_state& __state)
    {
      try
 {
   _M_rehash_aux(__n, __unique_keys());
 }
      catch(...)
 {


   _M_rehash_policy._M_reset(__state);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::true_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin._M_nxt;
       _M_before_begin._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin;
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }
   __p = __next;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::false_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);

      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_type* __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
           __n);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin._M_nxt;
    _M_before_begin._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin;
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }
# 2219 "/usr/include/c++/9/bits/hashtable.h" 3

}
# 47 "/usr/include/c++/9/unordered_map" 2 3
# 1 "/usr/include/c++/9/bits/unordered_map.h" 1 3
# 33 "/usr/include/c++/9/bits/unordered_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<bool _Cache>
    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                                        _Alloc, __detail::_Select1st,
            _Pred, _Hash,
            __detail::_Mod_range_hashing,
            __detail::_Default_ranged_hash,
            __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
      _Alloc, __detail::_Select1st,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    class unordered_multimap;
# 98 "/usr/include/c++/9/bits/unordered_map.h" 3
  template<typename _Key, typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_map
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 141 "/usr/include/c++/9/bits/unordered_map.h" 3
      unordered_map() = default;
# 150 "/usr/include/c++/9/bits/unordered_map.h" 3
      explicit
      unordered_map(size_type __n,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 171 "/usr/include/c++/9/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_map(const unordered_map&) = default;


      unordered_map(unordered_map&&) = default;





      explicit
      unordered_map(const allocator_type& __a)
 : _M_h(__a)
      { }






      unordered_map(const unordered_map& __umap,
      const allocator_type& __a)
      : _M_h(__umap._M_h, __a)
      { }






      unordered_map(unordered_map&& __umap,
      const allocator_type& __a)
      : _M_h(std::move(__umap._M_h), __a)
      { }
# 226 "/usr/include/c++/9/bits/unordered_map.h" 3
      unordered_map(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a)
      { }

      unordered_map(size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n,
        const allocator_type& __a)
 : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n, const hasher& __hf,
        const allocator_type& __a)
   : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n,
      const allocator_type& __a)
      : unordered_map(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_map&
      operator=(const unordered_map&) = default;


      unordered_map&
      operator=(unordered_map&&) = default;
# 288 "/usr/include/c++/9/bits/unordered_map.h" 3
      unordered_map&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 385 "/usr/include/c++/9/bits/unordered_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 416 "/usr/include/c++/9/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 578 "/usr/include/c++/9/bits/unordered_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }



      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 617 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
 { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 642 "/usr/include/c++/9/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 654 "/usr/include/c++/9/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 791 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 813 "/usr/include/c++/9/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 831 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 855 "/usr/include/c++/9/bits/unordered_map.h" 3
      void
      swap(unordered_map& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }
# 895 "/usr/include/c++/9/bits/unordered_map.h" 3
      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 919 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 937 "/usr/include/c++/9/bits/unordered_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 961 "/usr/include/c++/9/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
# 983 "/usr/include/c++/9/bits/unordered_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      { return _M_h[__k]; }

      mapped_type&
      operator[](key_type&& __k)
      { return _M_h[std::move(__k)]; }
# 1000 "/usr/include/c++/9/bits/unordered_map.h" 3
      mapped_type&
      at(const key_type& __k)
      { return _M_h.at(__k); }

      const mapped_type&
      at(const key_type& __k) const
      { return _M_h.at(__k); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1056 "/usr/include/c++/9/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1071 "/usr/include/c++/9/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1082 "/usr/include/c++/9/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1119 "/usr/include/c++/9/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1130 "/usr/include/c++/9/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
     const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
    };
# 1246 "/usr/include/c++/9/bits/unordered_map.h" 3
  template<typename _Key, typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_multimap
    {
      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 1288 "/usr/include/c++/9/bits/unordered_map.h" 3
      unordered_multimap() = default;
# 1297 "/usr/include/c++/9/bits/unordered_map.h" 3
      explicit
      unordered_multimap(size_type __n,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 1318 "/usr/include/c++/9/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_multimap(const unordered_multimap&) = default;


      unordered_multimap(unordered_multimap&&) = default;





      explicit
      unordered_multimap(const allocator_type& __a)
      : _M_h(__a)
      { }






      unordered_multimap(const unordered_multimap& __ummap,
    const allocator_type& __a)
      : _M_h(__ummap._M_h, __a)
      { }






      unordered_multimap(unordered_multimap&& __ummap,
    const allocator_type& __a)
      : _M_h(std::move(__ummap._M_h), __a)
      { }
# 1373 "/usr/include/c++/9/bits/unordered_map.h" 3
      unordered_multimap(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_multimap&
      operator=(const unordered_multimap&) = default;


      unordered_multimap&
      operator=(unordered_multimap&&) = default;
# 1435 "/usr/include/c++/9/bits/unordered_map.h" 3
      unordered_multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 1527 "/usr/include/c++/9/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 1554 "/usr/include/c++/9/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 1569 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      iterator
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 1603 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
        { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 1628 "/usr/include/c++/9/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 1641 "/usr/include/c++/9/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 1684 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 1705 "/usr/include/c++/9/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1724 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 1748 "/usr/include/c++/9/bits/unordered_map.h" 3
      void
      swap(unordered_multimap& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }
# 1790 "/usr/include/c++/9/bits/unordered_map.h" 3
      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1814 "/usr/include/c++/9/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }







      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 1850 "/usr/include/c++/9/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1906 "/usr/include/c++/9/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1921 "/usr/include/c++/9/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1932 "/usr/include/c++/9/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1969 "/usr/include/c++/9/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1980 "/usr/include/c++/9/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&,
     const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&);
    };
# 2075 "/usr/include/c++/9/bits/unordered_map.h" 3
  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }


# 2165 "/usr/include/c++/9/bits/unordered_map.h" 3

}
# 48 "/usr/include/c++/9/unordered_map" 2 3

# 1 "/usr/include/c++/9/bits/erase_if.h" 1 3
# 33 "/usr/include/c++/9/bits/erase_if.h" 3
       
# 34 "/usr/include/c++/9/bits/erase_if.h" 3



namespace std
{






  namespace __detail
  {
    template<typename _Container, typename _Predicate>
      typename _Container::size_type
      __erase_nodes_if(_Container& __cont, _Predicate __pred)
      {
 typename _Container::size_type __num = 0;
 for (auto __iter = __cont.begin(), __last = __cont.end();
      __iter != __last;)
   {
     if (__pred(*__iter))
       {
  __iter = __cont.erase(__iter);
  ++__num;
       }
     else
       ++__iter;
   }
 return __num;
      }
  }


}
# 50 "/usr/include/c++/9/unordered_map" 2 3
# 27 "../sys/Interpreter.h" 2


# 28 "../sys/Interpreter.h"
typedef struct structInterpreterVariable *InterpreterVariable; typedef autoSomeThing <structInterpreterVariable> autoInterpreterVariable; extern struct structClassInfo theClassInfo_InterpreterVariable; extern ClassInfo classInterpreterVariable; typedef structSimpleString InterpreterVariable_Parent; struct structInterpreterVariable : public structSimpleString {
 autostring32 stringValue;
 double numericValue;
 autoVEC numericVectorValue;
 autoMAT numericMatrixValue;
};
# 42 "../sys/Interpreter.h"
typedef struct structUiForm *UiForm; typedef autoSomeThing <structUiForm> autoUiForm; extern struct structClassInfo theClassInfo_UiForm; extern ClassInfo classUiForm;
typedef struct structEditor *Editor; typedef autoSomeThing <structEditor> autoEditor; extern struct structClassInfo theClassInfo_Editor; extern ClassInfo classEditor;

typedef struct structInterpreter *Interpreter; typedef autoSomeThing <structInterpreter> autoInterpreter; extern struct structClassInfo theClassInfo_Interpreter; extern ClassInfo classInterpreter; typedef structThing Interpreter_Parent; struct structInterpreter : public structThing {
 autostring32 environmentName;
 ClassInfo editorClass;
 int numberOfParameters, numberOfLabels, callDepth;
 char32 parameters [1+400] [100];
 int types [1+400];
 autostring32 arguments [1+400];
 char32 choiceArguments [1+400] [100];
 char32 labelNames [1+1000] [1+99];
 integer labelLines [1+1000];
 char32 dialogTitle [1+100], procedureNames [1+50] [100];
 std::unordered_map <std::u32string, autoInterpreterVariable> variablesMap;
 bool running, stopped;
};

autoInterpreter Interpreter_create (conststring32 environmentName, ClassInfo editorClass);
autoInterpreter Interpreter_createFromEnvironment (Editor editor);

void Melder_includeIncludeFiles (autostring32 *text);
integer Interpreter_readParameters (Interpreter me, mutablestring32 text);
typedef struct structUiForm *UiForm; typedef autoSomeThing <structUiForm> autoUiForm; extern struct structClassInfo theClassInfo_UiForm; extern ClassInfo classUiForm;
autoUiForm Interpreter_createForm (Interpreter me, GuiWindow parent, conststring32 fileName,
 void (*okCallback) (UiForm sendingForm, integer narg, Stackel args, conststring32 sendingString, Interpreter interpreter, conststring32 invokingButtonTitle, bool modified, void *closure), void *okClosure,
 bool selectionOnly);
void Interpreter_getArgumentsFromDialog (Interpreter me, UiForm dialog);
void Interpreter_getArgumentsFromString (Interpreter me, conststring32 arguments);
void Interpreter_getArgumentsFromArgs (Interpreter me, int nargs, Stackel args);
void Interpreter_run (Interpreter me, char32 *text);
void Interpreter_stop (Interpreter me);

void Interpreter_voidExpression (Interpreter me, conststring32 expression);
void Interpreter_numericExpression (Interpreter me, conststring32 expression, double *p_value);
void Interpreter_numericVectorExpression (Interpreter me, conststring32 expression, VEC *p_value, bool *p_owned);
void Interpreter_numericMatrixExpression (Interpreter me, conststring32 expression, MAT *p_value, bool *p_owned);
autostring32 Interpreter_stringExpression (Interpreter me, conststring32 expression);
void Interpreter_anyExpression (Interpreter me, conststring32 expression, Formula_Result *p_result);

InterpreterVariable Interpreter_hasVariable (Interpreter me, conststring32 key);
InterpreterVariable Interpreter_lookUpVariable (Interpreter me, conststring32 key);

extern autoVEC theInterpreterNumvec;
extern autoMAT theInterpreterNummat;
# 24 "../sys/Ui.h" 2
typedef struct structEditorCommand *EditorCommand; typedef autoSomeThing <structEditorCommand> autoEditorCommand; extern struct structClassInfo theClassInfo_EditorCommand; extern ClassInfo classEditorCommand;
# 78 "../sys/Ui.h"
typedef struct structUiOption *UiOption; typedef autoSomeThing <structUiOption> autoUiOption; extern struct structClassInfo theClassInfo_UiOption; extern ClassInfo classUiOption; typedef structThing UiOption_Parent; struct structUiOption : public structThing {
 GuiRadioButton radioButton;
 GuiObject menuItem;
};

enum class _kUiField_type {
 REAL_ = 1,
 REAL_OR_UNDEFINED_ = 2,
 POSITIVE_ = 3,
 INTEGER_ = 4,
 NATURAL_ = 5,
 WORD_ = 6,
 SENTENCE_ = 7,
 COLOUR_ = 8,
 CHANNEL_ = 9,
 LABEL_ = 10,
 TEXT_ = 11,
 NUMVEC_ = 12,
 NUMMAT_ = 13,
 BOOLEAN_ = 14,
 RADIO_ = 15,
 OPTIONMENU_ = 16,
 LIST_ = 17,
 LABELLED_TEXT_MIN_ = 1,
 LABELLED_TEXT_MAX_ = 9
};

typedef struct structUiField *UiField; typedef autoSomeThing <structUiField> autoUiField; extern struct structClassInfo theClassInfo_UiField; extern ClassInfo classUiField; typedef structThing UiField_Parent; struct structUiField : public structThing {
 _kUiField_type type;
 autostring32 formLabel;
 double realValue;
 integer integerValue, integerDefaultValue;
 autostring32 stringValue, stringDefaultValue;
 autoVEC numericVectorValue;
 autoMAT numericMatrixValue;
 MelderColour colourValue;
 OrderedOf<structUiOption> options;
 constSTRVEC strings;
 GuiLabel label;
 GuiText text;
 GuiCheckButton checkButton;
 GuiRadioButton radioButton;
 GuiList list;
 GuiOptionMenu optionMenu;
 int y;

 conststring32 variableName;
 double *realVariable;
 integer *integerVariable;
 int *intVariable;
 bool *boolVariable;
 conststring32 *stringVariable;
 MelderColour *colourVariable;
 constVEC *numericVectorVariable;
 constMAT *numericMatrixVariable;

 int subtract;

 void v_destroy () noexcept
  override;
};



typedef void (*UiCallback) (UiForm _sendingForm, integer _narg, Stackel _args, conststring32 _sendingString, Interpreter interpreter, conststring32 _invokingButtonTitle, bool _modified, void *_closure);




typedef struct structUiForm *UiForm; typedef autoSomeThing <structUiForm> autoUiForm; extern struct structClassInfo theClassInfo_UiForm; extern ClassInfo classUiForm; typedef structThing UiForm_Parent; struct structUiForm : public structThing {
 EditorCommand command;
 GuiWindow d_dialogParent;
 autostring32 invokingButtonTitle, helpTitle;
 UiCallback okCallback;
 void *buttonClosure;




 bool (*allowExecutionHook) (void *closure);
 void *allowExecutionClosure;




 GuiDialog d_dialogForm;
 void (*applyCallback) (UiForm dia, void *closure);
 void (*cancelCallback) (UiForm dia, void *closure);
 int numberOfContinueButtons, defaultContinueButton, cancelContinueButton, clickedContinueButton;
 conststring32 continueTexts [1 + 10];
 int numberOfFields;
 autoUiField field [1 + 50];
 GuiButton okButton, cancelButton, revertButton, helpButton, applyButton, continueButtons [1 + 10];
 bool destroyWhenUnmanaged, isPauseForm;




 structMelderFile file;
 int shiftKeyPressed;
 bool allowMultipleFiles;

 void v_destroy () noexcept
  override;
};


autoUiForm UiForm_create (GuiWindow parent, conststring32 title,
 UiCallback okCallback, void *buttonClosure,
 conststring32 invokingButtonTitle, conststring32 helpTitle);
UiField UiForm_addReal (UiForm me, double *variable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
UiField UiForm_addRealOrUndefined (UiForm me, double *variable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
UiField UiForm_addPositive (UiForm me, double *variable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
UiField UiForm_addInteger (UiForm me, integer *variable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
UiField UiForm_addNatural (UiForm me, integer *variable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
UiField UiForm_addWord (UiForm me, conststring32 *variable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
UiField UiForm_addSentence (UiForm me, conststring32 *variable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
UiField UiForm_addLabel (UiForm me, conststring32 *variable, conststring32 label);
UiField UiForm_addBoolean (UiForm me, bool *variable, conststring32 variableName, conststring32 label, bool defaultValue);
UiField UiForm_addText (UiForm me, conststring32 *variable, conststring32 variableName, conststring32 name, conststring32 defaultValue);
UiField UiForm_addNumvec (UiForm me, constVEC *variable, conststring32 variableName, conststring32 name, conststring32 defaultValue);
UiField UiForm_addNummat (UiForm me, constMAT *variable, conststring32 variableName, conststring32 name, conststring32 defaultValue);
UiField UiForm_addRadio (UiForm me, int *intVariable, conststring32 *stringVariable, conststring32 variableName, conststring32 label, int defaultValue, int base);
UiOption UiRadio_addButton (UiField me, conststring32 label);
UiField UiForm_addOptionMenu (UiForm me, int *intVariable, conststring32 *stringVariable, conststring32 variableName, conststring32 label, int defaultValue, int base);
UiOption UiOptionMenu_addButton (UiField me, conststring32 label);
UiField UiForm_addList (UiForm me, integer *integerVariable, conststring32 *stringVariable, conststring32 variableName, conststring32 label, constSTRVEC strings, integer defaultValue);
UiField UiForm_addColour (UiForm me, MelderColour *colourVariable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
UiField UiForm_addChannel (UiForm me, integer *variable, conststring32 variableName, conststring32 label, conststring32 defaultValue);
void UiForm_finish (UiForm me);

void UiForm_destroyWhenUnmanaged (UiForm me);
void UiForm_setPauseForm (UiForm me,
 int numberOfContinueButtons, int defaultContinueButton, int cancelContinueButton,
 conststring32 continue1, conststring32 continue2, conststring32 continue3,
 conststring32 continue4, conststring32 continue5, conststring32 continue6,
 conststring32 continue7, conststring32 continue8, conststring32 continue9,
 conststring32 continue10,
 void (*cancelCallback) (UiForm dia, void *closure));







 void UiForm_setReal (UiForm me, double *p_variable, double value);
 void UiForm_setRealAsString (UiForm me, double *p_variable, conststring32 stringValue );

 void UiForm_setInteger (UiForm me, integer *p_variable, integer value);
 void UiForm_setIntegerAsString (UiForm me, integer *p_variable, conststring32 stringValue );

 void UiForm_setString (UiForm me, conststring32 *p_variable, conststring32 text );

 void UiForm_setBoolean (UiForm me, bool *p_variable, bool value);

 void UiForm_setOption (UiForm me, int *p_variable, int value);
 void UiForm_setOptionAsString (UiForm me, int *p_variable, conststring32 stringValue );

 void UiForm_setColourAsGreyValue (UiForm me, MelderColour *p_variable, double greyValue);

void UiForm_do (UiForm me, bool modified);
# 267 "../sys/Ui.h"
void UiForm_info (UiForm me, integer narg);







integer UiForm_getInteger (UiForm me, conststring32 fieldName);
char32 * UiForm_getString (UiForm me, conststring32 fieldName);
MelderFile UiForm_getFile (UiForm me, conststring32 fieldName);

double UiForm_getReal_check (UiForm me, conststring32 fieldName);
integer UiForm_getInteger_check (UiForm me, conststring32 fieldName);
char32 * UiForm_getString_check (UiForm me, conststring32 fieldName);
MelderColour UiForm_getColour_check (UiForm me, conststring32 fieldName);

void UiForm_call (UiForm me, integer narg, Stackel args, Interpreter interpreter);
void UiForm_parseString (UiForm me, conststring32 arguments, Interpreter interpreter);

autoUiForm UiInfile_create (GuiWindow parent, conststring32 title,
  UiCallback okCallback, void *okClosure,
  conststring32 invokingButtonTitle, conststring32 helpTitle, bool allowMultipleFiles);

autoUiForm UiOutfile_create (GuiWindow parent, conststring32 title,
  UiCallback okCallback, void *okClosure,
  conststring32 invokingButtonTitle, conststring32 helpTitle);

void UiInfile_do (UiForm me);

void UiOutfile_do (UiForm me, conststring32 defaultName);

MelderFile UiFile_getFile (UiForm me);

void UiFile_hide ();
# 312 "../sys/Ui.h"
void UiHistory_write (conststring32 string);
void UiHistory_write_expandQuotes (conststring32 string);
void UiHistory_write_colonize (conststring32 string);
char32 *UiHistory_get ();
void UiHistory_clear ();

void Ui_setAllowExecutionHook (bool (*allowExecutionHook) (void *closure), void *allowExecutionClosure);

void UiForm_Interpreter_addVariables (UiForm me, Interpreter interpreter);
int UiForm_getClickedContinueButton (UiForm me);
# 24 "../sys/Editor.h" 2

# 1 "../sys/prefs.h" 1
# 21 "../sys/prefs.h"
# 1 "../sys/Preferences.h" 1
# 22 "../sys/prefs.h" 2
# 26 "../sys/Editor.h" 2

# 1 "../sys/Editor_enums.h" 1
# 19 "../sys/Editor_enums.h"
enum class kEditor_writeNameAtTop { UNDEFINED = -1, MIN = 0,
 NO_ = 0,
 FAR_ = 1,
 NEAR_ = 2,
MAX = 2, DEFAULT = FAR_ }; conststring32 kEditor_writeNameAtTop_getText (kEditor_writeNameAtTop value); kEditor_writeNameAtTop kEditor_writeNameAtTop_getValue (conststring32 text); inline static kEditor_writeNameAtTop& operator++ (kEditor_writeNameAtTop& value) { value = static_cast <kEditor_writeNameAtTop> (static_cast <int> (value) + 1); return value; }
# 28 "../sys/Editor.h" 2

typedef struct structEditor *Editor; typedef autoSomeThing <structEditor> autoEditor; extern struct structClassInfo theClassInfo_Editor; extern ClassInfo classEditor;

typedef struct structEditorMenu *EditorMenu; typedef autoSomeThing <structEditorMenu> autoEditorMenu; extern struct structClassInfo theClassInfo_EditorMenu; extern ClassInfo classEditorMenu; typedef structThing EditorMenu_Parent; struct structEditorMenu : public structThing {
 Editor d_editor;
 autostring32 menuTitle;
 GuiMenu menuWidget;
 OrderedOf<structEditorCommand> commands;
};

typedef MelderCallback <void, structEditor, EditorCommand, UiForm, integer , Stackel , conststring32, Interpreter> EditorCommandCallback;

typedef struct structEditorCommand *EditorCommand; typedef autoSomeThing <structEditorCommand> autoEditorCommand; extern struct structClassInfo theClassInfo_EditorCommand; extern ClassInfo classEditorCommand; typedef structThing EditorCommand_Parent; struct structEditorCommand : public structThing {
 Editor d_editor;
 EditorMenu menu;
 autostring32 itemTitle;
 GuiMenuItem itemWidget;
 EditorCommandCallback commandCallback;
 autostring32 script;
 autoUiForm d_uiform;
};

typedef MelderCallback <void, structEditor> Editor_DataChangedCallback;
typedef MelderCallback <void, structEditor> Editor_DestructionCallback;

typedef MelderCallback <void, structEditor, autoDaata > Editor_PublicationCallback;

typedef struct structEditor *Editor; typedef autoSomeThing <structEditor> autoEditor; extern struct structClassInfo theClassInfo_Editor; extern ClassInfo classEditor; typedef structThing Editor_Parent; struct structEditor : public structThing {
 GuiWindow windowForm;
 GuiMenuItem undoButton, searchButton;
 OrderedOf<structEditorMenu> menus;
 Daata data;
 autoDaata previousData;
 bool ownData;
 char32 undoText [100];
 Graphics pictureGraphics;
 Editor_DataChangedCallback d_dataChangedCallback;
 Editor_DestructionCallback d_destructionCallback;
 Editor_PublicationCallback d_publicationCallback;
 autostring32 callbackSocket;

 void v_destroy () noexcept
  override;
 void v_info ()
  override;
 void v_nameChanged ()
  override;

 virtual void v_goAway () { do { _Thing_forget_nozero (this); delete this; } while (false); }
 virtual bool v_hasMenuBar () { return true; }
 virtual bool v_canFullScreen () { return false; }
 virtual bool v_editable () { return true ; }
 virtual bool v_scriptable () { return true; }
 virtual void v_createMenuItems_file (EditorMenu menu);
 virtual void v_createMenuItems_edit (EditorMenu menu);
 virtual bool v_hasQueryMenu () { return true; }
 virtual void v_createMenuItems_query (EditorMenu menu);
 virtual void v_createMenuItems_query_info (EditorMenu menu);
 virtual void v_createMenus ();
 virtual void v_createHelpMenuItems (EditorMenu menu) { (void) menu; }
 virtual void v_createChildren () { }
 virtual void v_dataChanged () { }
 virtual void v_saveData ();
 virtual void v_restoreData ();
 virtual void v_form_pictureWindow (EditorCommand cmd);
 virtual void v_ok_pictureWindow (EditorCommand cmd);
 virtual void v_do_pictureWindow (EditorCommand cmd);
 virtual void v_form_pictureMargins (EditorCommand cmd);
 virtual void v_ok_pictureMargins (EditorCommand cmd);
 virtual void v_do_pictureMargins (EditorCommand cmd);

# 1 "../sys/Editor_prefs.h" 1
# 19 "../sys/Editor_prefs.h"
public: static void f_preferences (); void v_copyPreferencesToInstance () override;

 private: static bool s_picture_eraseFirst; public: virtual bool & pref_picture_eraseFirst () { return s_picture_eraseFirst; } private: static bool sdefault_picture_eraseFirst; public: virtual bool default_picture_eraseFirst () { return sdefault_picture_eraseFirst; }
 private: static enum kEditor_writeNameAtTop s_picture_writeNameAtTop; public: virtual enum kEditor_writeNameAtTop & pref_picture_writeNameAtTop () { return s_picture_writeNameAtTop; } private: static enum kEditor_writeNameAtTop sdefault_picture_writeNameAtTop; public: virtual enum kEditor_writeNameAtTop default_picture_writeNameAtTop () { return sdefault_picture_writeNameAtTop; }


# 100 "../sys/Editor.h" 2
};

GuiMenuItem EditorMenu_addCommand (EditorMenu me, conststring32 itemTitle , uint32 flags, EditorCommandCallback commandCallback);
GuiMenuItem EditorCommand_getItemWidget (EditorCommand me);

EditorMenu Editor_addMenu (Editor me, conststring32 menuTitle, uint32 flags);
GuiObject EditorMenu_getMenuWidget (EditorMenu me);


GuiMenuItem Editor_addCommand (Editor me, conststring32 menuTitle, conststring32 itemTitle, uint32 flags, EditorCommandCallback commandCallback);
GuiMenuItem Editor_addCommandScript (Editor me, conststring32 menuTitle, conststring32 itemTitle, uint32 flags,
 conststring32 script);
void Editor_setMenuSensitive (Editor me, conststring32 menu, bool sensitive);

inline static void Editor_raise (Editor me)






 {
  GuiThing_show (me -> windowForm);
 }
inline static void Editor_dataChanged (Editor me)




 {
  me -> v_dataChanged ();
 }
inline static void Editor_setDataChangedCallback (Editor me, Editor_DataChangedCallback dataChangedCallback)
# 141 "../sys/Editor.h"
 {
  me -> d_dataChangedCallback = dataChangedCallback;
 }
inline static void Editor_broadcastDataChanged (Editor me)





 {
  if (me -> d_dataChangedCallback)
   me -> d_dataChangedCallback (me);
 }
inline static void Editor_setDestructionCallback (Editor me, Editor_DestructionCallback destructionCallback)







 {
  me -> d_destructionCallback = destructionCallback;
 }
inline static void Editor_broadcastDestruction (Editor me)





 {
  if (me -> d_destructionCallback)
   me -> d_destructionCallback (me);
 }
inline static void Editor_setPublicationCallback (Editor me, Editor_PublicationCallback publicationCallback)
# 184 "../sys/Editor.h"
 {
  me -> d_publicationCallback = publicationCallback;
 }
inline static void Editor_broadcastPublication (Editor me, autoDaata publication)
# 197 "../sys/Editor.h"
 {
  if (me -> d_publicationCallback)
   me -> d_publicationCallback (me, publication.move());
 }



void Editor_init (Editor me, int x, int y , int width, int height,
 conststring32 title, Daata data);
# 226 "../sys/Editor.h"
void Editor_save (Editor me, conststring32 text);

autoUiForm UiForm_createE (EditorCommand cmd, conststring32 title, conststring32 invokingButtonTitle, conststring32 helpTitle);
void UiForm_parseStringE (EditorCommand cmd, integer narg, Stackel args, conststring32 arguments, Interpreter interpreter);
autoUiForm UiOutfile_createE (EditorCommand cmd, conststring32 title, conststring32 invokingButtonTitle, conststring32 helpTitle);
autoUiForm UiInfile_createE (EditorCommand cmd, conststring32 title, conststring32 invokingButtonTitle, conststring32 helpTitle);

EditorCommand Editor_getMenuCommand (Editor me, conststring32 menuTitle, conststring32 itemTitle);
void Editor_doMenuCommand (Editor me, conststring32 command, integer narg, Stackel args, conststring32 arguments, Interpreter interpreter);





Graphics praat_picture_editor_open (bool eraseFirst);
void praat_picture_editor_close ();
void Editor_openPraatPicture (Editor me);
void Editor_closePraatPicture (Editor me);
# 30 "VowelEditor.h" 2



# 1 "VowelEditor_enums.h" 1
# 19 "VowelEditor_enums.h"
enum class kVowelEditor_speakerType { UNDEFINED = -1, MIN = 0,
 MAN = 0,
 WOMAN = 1,
 CHILD = 2,
 UNKNOWN = 3,
MAX = 3, DEFAULT = UNKNOWN }; conststring32 kVowelEditor_speakerType_getText (kVowelEditor_speakerType value); kVowelEditor_speakerType kVowelEditor_speakerType_getValue (conststring32 text); inline static kVowelEditor_speakerType& operator++ (kVowelEditor_speakerType& value) { value = static_cast <kVowelEditor_speakerType> (static_cast <int> (value) + 1); return value; }

enum class kVowelEditor_marksDataSet { UNDEFINED = -1, MIN = 1,
 AMERICAN_ENGLISH = 1,
 DUTCH = 2,
 NONE = 3,
 OTHER = 4,
MAX = 4, DEFAULT = OTHER }; conststring32 kVowelEditor_marksDataSet_getText (kVowelEditor_marksDataSet value); kVowelEditor_marksDataSet kVowelEditor_marksDataSet_getValue (conststring32 text); inline static kVowelEditor_marksDataSet& operator++ (kVowelEditor_marksDataSet& value) { value = static_cast <kVowelEditor_marksDataSet> (static_cast <int> (value) + 1); return value; }

enum class kVowelEditor_frequencyScale { UNDEFINED = -1, MIN = 1,
 LOGARITHMIC = 1,
MAX = 1, DEFAULT = LOGARITHMIC }; conststring32 kVowelEditor_frequencyScale_getText (kVowelEditor_frequencyScale value); kVowelEditor_frequencyScale kVowelEditor_frequencyScale_getValue (conststring32 text); inline static kVowelEditor_frequencyScale& operator++ (kVowelEditor_frequencyScale& value) { value = static_cast <kVowelEditor_frequencyScale> (static_cast <int> (value) + 1); return value; }
# 34 "VowelEditor.h" 2

typedef struct structTrajectoryPoint *TrajectoryPoint; typedef autoSomeThing <structTrajectoryPoint> autoTrajectoryPoint; extern struct structClassInfo theClassInfo_TrajectoryPoint; extern ClassInfo classTrajectoryPoint; typedef structAnyPoint TrajectoryPoint_Parent; struct structTrajectoryPoint : public structAnyPoint {
 double x, y;
 MelderColour colour;
 virtual void v_destroy () noexcept { TrajectoryPoint_Parent::v_destroy ();}
};

typedef struct structTrajectory *Trajectory; typedef autoSomeThing <structTrajectory> autoTrajectory; extern struct structClassInfo theClassInfo_Trajectory; extern ClassInfo classTrajectory; typedef structFunction Trajectory_Parent; struct structTrajectory : public structFunction {
 SortedSetOfDoubleOf<TrajectoryPoint> points;
};

typedef struct structVowelSpecification *VowelSpecification; typedef autoSomeThing <structVowelSpecification> autoVowelSpecification; extern struct structClassInfo theClassInfo_VowelSpecification; extern ClassInfo classVowelSpecification; typedef structFunction VowelSpecification_Parent; struct structVowelSpecification : public structFunction {
 autoPitchTier pitchTier;
 autoFormantTier formantTier;
};

typedef struct structVowelEditor *VowelEditor; typedef autoSomeThing <structVowelEditor> autoVowelEditor; extern struct structClassInfo theClassInfo_VowelEditor; extern ClassInfo classVowelEditor; typedef structEditor VowelEditor_Parent; struct structVowelEditor : public structEditor {
 int shiftKeyPressed;
 autoGraphics graphics;
 short width, height;
 autoTable marks;
 autoVowelSpecification vowel;
 autoTrajectory trajectory;
 autoVEC extraFrequencyBandwidthPairs;
 GuiDrawingArea drawingArea;
 GuiButton playButton, reverseButton, publishButton;
 GuiText f0TextField, f0SlopeTextField, durationTextField, extendTextField;
 GuiLabel startInfo, endInfo;

 void v_destroy () noexcept
  override;
 bool v_scriptable ()
  override { return false; }
 void v_createChildren ()
  override;
 void v_createMenus ()
  override;
 void v_createHelpMenuItems (EditorMenu menu)
  override;

# 1 "VowelEditor_prefs.h" 1
# 20 "VowelEditor_prefs.h"
public: static void f_preferences (); void v_copyPreferencesToInstance () override;

 public: int p_shell_width; private: static int s_shell_width; public: virtual int & pref_shell_width () { return s_shell_width; } private: static conststring32 sdefault_shell_width; public: virtual conststring32 default_shell_width () { return sdefault_shell_width; }
 public: int p_shell_height; private: static int s_shell_height; public: virtual int & pref_shell_height () { return s_shell_height; } private: static conststring32 sdefault_shell_height; public: virtual conststring32 default_shell_height () { return sdefault_shell_height; }
 public: bool p_soundFollowsMouse; private: static bool s_soundFollowsMouse; public: virtual bool & pref_soundFollowsMouse () { return s_soundFollowsMouse; } private: static bool sdefault_soundFollowsMouse; public: virtual bool default_soundFollowsMouse () { return sdefault_soundFollowsMouse; }
 public: kVowelEditor_frequencyScale p_window_frequencyScale; private: static enum kVowelEditor_frequencyScale s_window_frequencyScale; public: virtual enum kVowelEditor_frequencyScale & pref_window_frequencyScale () { return s_window_frequencyScale; } private: static enum kVowelEditor_frequencyScale sdefault_window_frequencyScale; public: virtual enum kVowelEditor_frequencyScale default_window_frequencyScale () { return sdefault_window_frequencyScale; }
 public: double p_window_f1min; private: static double s_window_f1min; public: virtual double & pref_window_f1min () { return s_window_f1min; } private: static conststring32 sdefault_window_f1min; public: virtual conststring32 default_window_f1min () { return sdefault_window_f1min; }
 public: double p_window_f1max; private: static double s_window_f1max; public: virtual double & pref_window_f1max () { return s_window_f1max; } private: static conststring32 sdefault_window_f1max; public: virtual conststring32 default_window_f1max () { return sdefault_window_f1max; }
 public: double p_window_f2min; private: static double s_window_f2min; public: virtual double & pref_window_f2min () { return s_window_f2min; } private: static conststring32 sdefault_window_f2min; public: virtual conststring32 default_window_f2min () { return sdefault_window_f2min; }
 public: double p_window_f2max; private: static double s_window_f2max; public: virtual double & pref_window_f2max () { return s_window_f2max; } private: static conststring32 sdefault_window_f2max; public: virtual conststring32 default_window_f2max () { return sdefault_window_f2max; }
 public: double p_synthesis_samplingFrequency; private: static double s_synthesis_samplingFrequency; public: virtual double & pref_synthesis_samplingFrequency () { return s_synthesis_samplingFrequency; } private: static conststring32 sdefault_synthesis_samplingFrequency; public: virtual conststring32 default_synthesis_samplingFrequency () { return sdefault_synthesis_samplingFrequency; }
 public: integer p_synthesis_numberOfFormants; private: static integer s_synthesis_numberOfFormants; public: virtual integer & pref_synthesis_numberOfFormants () { return s_synthesis_numberOfFormants; } private: static conststring32 sdefault_synthesis_numberOfFormants; public: virtual conststring32 default_synthesis_numberOfFormants () { return sdefault_synthesis_numberOfFormants; }
 public: double p_synthesis_q1; private: static double s_synthesis_q1; public: virtual double & pref_synthesis_q1 () { return s_synthesis_q1; } private: static conststring32 sdefault_synthesis_q1; public: virtual conststring32 default_synthesis_q1 () { return sdefault_synthesis_q1; }
 public: double p_synthesis_q2; private: static double s_synthesis_q2; public: virtual double & pref_synthesis_q2 () { return s_synthesis_q2; } private: static conststring32 sdefault_synthesis_q2; public: virtual conststring32 default_synthesis_q2 () { return sdefault_synthesis_q2; }
 public: char32 p_synthesis_extraFBPairs [1+1023]; private: static char32 s_synthesis_extraFBPairs [1+1023]; public: virtual char32 * pref_synthesis_extraFBPairs () { return & s_synthesis_extraFBPairs [0]; } private: static conststring32 sdefault_synthesis_extraFBPairs; public: virtual conststring32 default_synthesis_extraFBPairs () { return sdefault_synthesis_extraFBPairs; }
 public: double p_trajectory_markEvery; private: static double s_trajectory_markEvery; public: virtual double & pref_trajectory_markEvery () { return s_trajectory_markEvery; } private: static conststring32 sdefault_trajectory_markEvery; public: virtual conststring32 default_trajectory_markEvery () { return sdefault_trajectory_markEvery; }
 public: char32 p_trajectory_colour [1+1023]; private: static char32 s_trajectory_colour [1+1023]; public: virtual char32 * pref_trajectory_colour () { return & s_trajectory_colour [0]; } private: static conststring32 sdefault_trajectory_colour; public: virtual conststring32 default_trajectory_colour () { return sdefault_trajectory_colour; }
 public: double p_trajectory_minimumDuration; private: static double s_trajectory_minimumDuration; public: virtual double & pref_trajectory_minimumDuration () { return s_trajectory_minimumDuration; } private: static conststring32 sdefault_trajectory_minimumDuration; public: virtual conststring32 default_trajectory_minimumDuration () { return sdefault_trajectory_minimumDuration; }
 public: double p_trajectory_maximumDuration; private: static double s_trajectory_maximumDuration; public: virtual double & pref_trajectory_maximumDuration () { return s_trajectory_maximumDuration; } private: static conststring32 sdefault_trajectory_maximumDuration; public: virtual conststring32 default_trajectory_maximumDuration () { return sdefault_trajectory_maximumDuration; }
 public: double p_trajectory_duration; private: static double s_trajectory_duration; public: virtual double & pref_trajectory_duration () { return s_trajectory_duration; } private: static conststring32 sdefault_trajectory_duration; public: virtual conststring32 default_trajectory_duration () { return sdefault_trajectory_duration; }
 public: double p_trajectory_extendDuration; private: static double s_trajectory_extendDuration; public: virtual double & pref_trajectory_extendDuration () { return s_trajectory_extendDuration; } private: static conststring32 sdefault_trajectory_extendDuration; public: virtual conststring32 default_trajectory_extendDuration () { return sdefault_trajectory_extendDuration; }
 public: kVowelEditor_speakerType p_marks_speakerType; private: static enum kVowelEditor_speakerType s_marks_speakerType; public: virtual enum kVowelEditor_speakerType & pref_marks_speakerType () { return s_marks_speakerType; } private: static enum kVowelEditor_speakerType sdefault_marks_speakerType; public: virtual enum kVowelEditor_speakerType default_marks_speakerType () { return sdefault_marks_speakerType; }
 public: kVowelEditor_marksDataSet p_marks_dataSet; private: static enum kVowelEditor_marksDataSet s_marks_dataSet; public: virtual enum kVowelEditor_marksDataSet & pref_marks_dataSet () { return s_marks_dataSet; } private: static enum kVowelEditor_marksDataSet sdefault_marks_dataSet; public: virtual enum kVowelEditor_marksDataSet default_marks_dataSet () { return sdefault_marks_dataSet; }
 public: char32 p_marks_fileName [1+1023]; private: static char32 s_marks_fileName [1+1023]; public: virtual char32 * pref_marks_fileName () { return & s_marks_fileName [0]; } private: static conststring32 sdefault_marks_fileName; public: virtual conststring32 default_marks_fileName () { return sdefault_marks_fileName; }
 public: char32 p_marks_colour [1+1023]; private: static char32 s_marks_colour [1+1023]; public: virtual char32 * pref_marks_colour () { return & s_marks_colour [0]; } private: static conststring32 sdefault_marks_colour; public: virtual conststring32 default_marks_colour () { return sdefault_marks_colour; }
 public: double p_marks_fontSize; private: static double s_marks_fontSize; public: virtual double & pref_marks_fontSize () { return s_marks_fontSize; } private: static conststring32 sdefault_marks_fontSize; public: virtual conststring32 default_marks_fontSize () { return sdefault_marks_fontSize; }
 public: double p_f0_start; private: static double s_f0_start; public: virtual double & pref_f0_start () { return s_f0_start; } private: static conststring32 sdefault_f0_start; public: virtual conststring32 default_f0_start () { return sdefault_f0_start; }
 public: double p_f0_slope; private: static double s_f0_slope; public: virtual double & pref_f0_slope () { return s_f0_slope; } private: static conststring32 sdefault_f0_slope; public: virtual conststring32 default_f0_slope () { return sdefault_f0_slope; }
 public: double p_f0_minimum; private: static double s_f0_minimum; public: virtual double & pref_f0_minimum () { return s_f0_minimum; } private: static conststring32 sdefault_f0_minimum; public: virtual conststring32 default_f0_minimum () { return sdefault_f0_minimum; }
 public: double p_f0_maximum; private: static double s_f0_maximum; public: virtual double & pref_f0_maximum () { return s_f0_maximum; } private: static conststring32 sdefault_f0_maximum; public: virtual conststring32 default_f0_maximum () { return sdefault_f0_maximum; }
 public: double p_grid_df1; private: static double s_grid_df1; public: virtual double & pref_grid_df1 () { return s_grid_df1; } private: static conststring32 sdefault_grid_df1; public: virtual conststring32 default_grid_df1 () { return sdefault_grid_df1; }
 public: double p_grid_df2; private: static double s_grid_df2; public: virtual double & pref_grid_df2 () { return s_grid_df2; } private: static conststring32 sdefault_grid_df2; public: virtual conststring32 default_grid_df2 () { return sdefault_grid_df2; }


# 75 "VowelEditor.h" 2

};

autoVowelEditor VowelEditor_create (conststring32 title, Daata data);
# 54 "VowelEditor.cpp" 2
# 1 "../sys/EditorM.h" 1
# 55 "VowelEditor.cpp" 2
# 1 "../sys/machine.h" 1
# 56 "VowelEditor.cpp" 2





# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4

# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 68 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 186 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 62 "VowelEditor.cpp" 2
# 1 "/usr/include/signal.h" 1 3 4
# 27 "/usr/include/signal.h" 3 4
extern "C" {


# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/signum.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/signum.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_TKILL = -6,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 63 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 189 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     throw ();

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     throw ();






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     throw ();
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) throw ();






extern int killpg (__pid_t __pgrp, int __sig) throw ();



extern int raise (int __sig) throw ();



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     throw ();
extern int gsignal (int __sig) throw ();




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 170 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) throw () __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) throw () __attribute__ ((__deprecated__));


extern int siggetmask (void) throw () __attribute__ ((__deprecated__));
# 185 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) throw () __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) throw () __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 227 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) throw ();






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) throw ();


extern int sigpending (sigset_t *__set) throw () __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     throw ();
# 286 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[(64 + 1)];
extern const char *const sys_siglist[(64 + 1)];



# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t __glibc_reserved1[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short __glibc_reserved1[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t __glibc_reserved1[2];
  __uint64_t __glibc_reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 292 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) throw ();






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 302 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 304 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;
# 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 307 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) throw ();

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 317 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 318 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) throw ();




# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 328 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     throw () __attribute__ ((__deprecated__));






extern int sighold (int __sig) throw ();


extern int sigrelse (int __sig) throw ();


extern int sigignore (int __sig) throw ();


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) throw ();






# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __threadid, int __signo) throw ();



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) throw ();
# 360 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) throw ();

extern int __libc_current_sigrtmax (void) throw ();




}
# 63 "VowelEditor.cpp" 2



# 1 "../melder/enums_getText.h" 1
# 67 "VowelEditor.cpp" 2
# 1 "VowelEditor_enums.h" 1
# 19 "VowelEditor_enums.h"

# 19 "VowelEditor_enums.h"
conststring32 kVowelEditor_speakerType_getText (kVowelEditor_speakerType testValue) { return
 testValue == kVowelEditor_speakerType::MAN ? U"Man" :
 testValue == kVowelEditor_speakerType::WOMAN ? U"Woman" :
 testValue == kVowelEditor_speakerType::CHILD ? U"Child" :
 testValue == kVowelEditor_speakerType::UNKNOWN ? U"Unknown" :
kVowelEditor_speakerType_getText (kVowelEditor_speakerType::DEFAULT); }

conststring32 kVowelEditor_marksDataSet_getText (kVowelEditor_marksDataSet testValue) { return
 testValue == kVowelEditor_marksDataSet::AMERICAN_ENGLISH ? U"American English" :
 testValue == kVowelEditor_marksDataSet::DUTCH ? U"Dutch" :
 testValue == kVowelEditor_marksDataSet::NONE ? U"None" :
 testValue == kVowelEditor_marksDataSet::OTHER ? U"Other" :
kVowelEditor_marksDataSet_getText (kVowelEditor_marksDataSet::DEFAULT); }

conststring32 kVowelEditor_frequencyScale_getText (kVowelEditor_frequencyScale testValue) { return
 testValue == kVowelEditor_frequencyScale::LOGARITHMIC ? U"Logaritmic" :
kVowelEditor_frequencyScale_getText (kVowelEditor_frequencyScale::DEFAULT); }
# 68 "VowelEditor.cpp" 2
# 1 "../melder/enums_getValue.h" 1
# 69 "VowelEditor.cpp" 2
# 1 "VowelEditor_enums.h" 1
# 19 "VowelEditor_enums.h"
kVowelEditor_speakerType kVowelEditor_speakerType_getValue (conststring32 testText) {
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"Man")) return kVowelEditor_speakerType::MAN;
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"Woman")) return kVowelEditor_speakerType::WOMAN;
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"Child")) return kVowelEditor_speakerType::CHILD;
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"Unknown")) return kVowelEditor_speakerType::UNKNOWN;
if (! str32cmp (testText, U"\t")) return kVowelEditor_speakerType::DEFAULT; if (! str32cmp (testText, U"\n")) return kVowelEditor_speakerType::MAX; return kVowelEditor_speakerType::UNDEFINED; }

kVowelEditor_marksDataSet kVowelEditor_marksDataSet_getValue (conststring32 testText) {
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"American English")) return kVowelEditor_marksDataSet::AMERICAN_ENGLISH;
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"Dutch")) return kVowelEditor_marksDataSet::DUTCH;
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"None")) return kVowelEditor_marksDataSet::NONE;
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"Other")) return kVowelEditor_marksDataSet::OTHER;
if (! str32cmp (testText, U"\t")) return kVowelEditor_marksDataSet::DEFAULT; if (! str32cmp (testText, U"\n")) return kVowelEditor_marksDataSet::MAX; return kVowelEditor_marksDataSet::UNDEFINED; }

kVowelEditor_frequencyScale kVowelEditor_frequencyScale_getValue (conststring32 testText) {
 if (Melder_equ_firstCharacterCaseInsensitive (testText, U"Logaritmic")) return kVowelEditor_frequencyScale::LOGARITHMIC;
if (! str32cmp (testText, U"\t")) return kVowelEditor_frequencyScale::DEFAULT; if (! str32cmp (testText, U"\n")) return kVowelEditor_frequencyScale::MAX; return kVowelEditor_frequencyScale::UNDEFINED; }
# 70 "VowelEditor.cpp" 2

static Thing _VowelEditor_new () { return new structVowelEditor; } struct structClassInfo theClassInfo_VowelEditor = { U"" "VowelEditor", & theClassInfo_Editor, sizeof (class structVowelEditor), _VowelEditor_new, 0, 0, nullptr}; ClassInfo classVowelEditor = & theClassInfo_VowelEditor;

# 1 "../sys/prefs_define.h" 1
# 74 "VowelEditor.cpp" 2
# 1 "VowelEditor_prefs.h" 1
# 20 "VowelEditor_prefs.h"


 int structVowelEditor :: s_shell_width; conststring32 structVowelEditor :: sdefault_shell_width = U"700";
 int structVowelEditor :: s_shell_height; conststring32 structVowelEditor :: sdefault_shell_height = U"700";
 bool structVowelEditor :: s_soundFollowsMouse; bool structVowelEditor :: sdefault_soundFollowsMouse = true;
 enum kVowelEditor_frequencyScale structVowelEditor :: s_window_frequencyScale; enum kVowelEditor_frequencyScale structVowelEditor :: sdefault_window_frequencyScale = kVowelEditor_frequencyScale :: LOGARITHMIC;
 double structVowelEditor :: s_window_f1min; conststring32 structVowelEditor :: sdefault_window_f1min = U"200.0";
 double structVowelEditor :: s_window_f1max; conststring32 structVowelEditor :: sdefault_window_f1max = U"1200.0";
 double structVowelEditor :: s_window_f2min; conststring32 structVowelEditor :: sdefault_window_f2min = U"500.0";
 double structVowelEditor :: s_window_f2max; conststring32 structVowelEditor :: sdefault_window_f2max = U"3500.0";
 double structVowelEditor :: s_synthesis_samplingFrequency; conststring32 structVowelEditor :: sdefault_synthesis_samplingFrequency = U"44100.0";
 integer structVowelEditor :: s_synthesis_numberOfFormants; conststring32 structVowelEditor :: sdefault_synthesis_numberOfFormants = U"4";
 double structVowelEditor :: s_synthesis_q1; conststring32 structVowelEditor :: sdefault_synthesis_q1 = U"10.0";
 double structVowelEditor :: s_synthesis_q2; conststring32 structVowelEditor :: sdefault_synthesis_q2 = U"10.0";
 char32 structVowelEditor :: s_synthesis_extraFBPairs [1+1023]; conststring32 structVowelEditor :: sdefault_synthesis_extraFBPairs = U"2500 250 3500 350 4500 450";
 double structVowelEditor :: s_trajectory_markEvery; conststring32 structVowelEditor :: sdefault_trajectory_markEvery = U"0.05";
 char32 structVowelEditor :: s_trajectory_colour [1+1023]; conststring32 structVowelEditor :: sdefault_trajectory_colour = U"Black";
 double structVowelEditor :: s_trajectory_minimumDuration; conststring32 structVowelEditor :: sdefault_trajectory_minimumDuration = U"0.01";
 double structVowelEditor :: s_trajectory_maximumDuration; conststring32 structVowelEditor :: sdefault_trajectory_maximumDuration = U"4.0";
 double structVowelEditor :: s_trajectory_duration; conststring32 structVowelEditor :: sdefault_trajectory_duration = U"0.1";
 double structVowelEditor :: s_trajectory_extendDuration; conststring32 structVowelEditor :: sdefault_trajectory_extendDuration = U"0.05";
 enum kVowelEditor_speakerType structVowelEditor :: s_marks_speakerType; enum kVowelEditor_speakerType structVowelEditor :: sdefault_marks_speakerType = kVowelEditor_speakerType :: WOMAN;
 enum kVowelEditor_marksDataSet structVowelEditor :: s_marks_dataSet; enum kVowelEditor_marksDataSet structVowelEditor :: sdefault_marks_dataSet = kVowelEditor_marksDataSet :: AMERICAN_ENGLISH;
 char32 structVowelEditor :: s_marks_fileName [1+1023]; conststring32 structVowelEditor :: sdefault_marks_fileName = U"";
 char32 structVowelEditor :: s_marks_colour [1+1023]; conststring32 structVowelEditor :: sdefault_marks_colour = U"grey";
 double structVowelEditor :: s_marks_fontSize; conststring32 structVowelEditor :: sdefault_marks_fontSize = U"14.0";
 double structVowelEditor :: s_f0_start; conststring32 structVowelEditor :: sdefault_f0_start = U"140.0";
 double structVowelEditor :: s_f0_slope; conststring32 structVowelEditor :: sdefault_f0_slope = U"0.0";
 double structVowelEditor :: s_f0_minimum; conststring32 structVowelEditor :: sdefault_f0_minimum = U"20.0";
 double structVowelEditor :: s_f0_maximum; conststring32 structVowelEditor :: sdefault_f0_maximum = U"2000.0";
 double structVowelEditor :: s_grid_df1; conststring32 structVowelEditor :: sdefault_grid_df1 = U"200.0";
 double structVowelEditor :: s_grid_df2; conststring32 structVowelEditor :: sdefault_grid_df2 = U"500.0";


# 75 "VowelEditor.cpp" 2
# 1 "../sys/prefs_install.h" 1
# 76 "VowelEditor.cpp" 2
# 1 "VowelEditor_prefs.h" 1
# 20 "VowelEditor_prefs.h"
void structVowelEditor :: f_preferences () {

 Preferences_addInt (Melder_cat (U"" "VowelEditor" U"." "shell_width", 1 >= 2 ? U"." "1" : U""), & s_shell_width, Melder_atoi (sdefault_shell_width));
 Preferences_addInt (Melder_cat (U"" "VowelEditor" U"." "shell_height", 1 >= 2 ? U"." "1" : U""), & s_shell_height, Melder_atoi (sdefault_shell_height));
 Preferences_addBool (Melder_cat (U"" "VowelEditor" U"." "soundFollowsMouse", 1 >= 2 ? U"." "1" : U""), & s_soundFollowsMouse, true);
 _Preferences_addEnum (Melder_cat (U"" "VowelEditor" U"." "window_frequencyScale", 1 >= 2 ? U"." "1" : U""), (int *) & s_window_frequencyScale, (int) kVowelEditor_frequencyScale::MIN, (int) kVowelEditor_frequencyScale::MAX, (conststring32 (*) (int)) kVowelEditor_frequencyScale_getText, (enum_generic_getValue) kVowelEditor_frequencyScale_getValue, (int) kVowelEditor_frequencyScale :: LOGARITHMIC);
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "window_f1min", 1 >= 2 ? U"." "1" : U""), & s_window_f1min, Melder_atof (sdefault_window_f1min));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "window_f1max", 1 >= 2 ? U"." "1" : U""), & s_window_f1max, Melder_atof (sdefault_window_f1max));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "window_f2min", 1 >= 2 ? U"." "1" : U""), & s_window_f2min, Melder_atof (sdefault_window_f2min));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "window_f2max", 1 >= 2 ? U"." "1" : U""), & s_window_f2max, Melder_atof (sdefault_window_f2max));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "synthesis_samplingFrequency", 1 >= 2 ? U"." "1" : U""), & s_synthesis_samplingFrequency, Melder_atof (sdefault_synthesis_samplingFrequency));
 Preferences_addInteger (Melder_cat (U"" "VowelEditor" U"." "synthesis_numberOfFormants", 1 >= 2 ? U"." "1" : U""), & s_synthesis_numberOfFormants, Melder_atoi (sdefault_synthesis_numberOfFormants));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "synthesis_q1", 1 >= 2 ? U"." "1" : U""), & s_synthesis_q1, Melder_atof (sdefault_synthesis_q1));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "synthesis_q2", 1 >= 2 ? U"." "1" : U""), & s_synthesis_q2, Melder_atof (sdefault_synthesis_q2));
 Preferences_addString (Melder_cat (U"" "VowelEditor" U"." "synthesis_extraFBPairs", 1 >= 2 ? U"." "1" : U""), & s_synthesis_extraFBPairs [0], U"2500 250 3500 350 4500 450");
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "trajectory_markEvery", 1 >= 2 ? U"." "1" : U""), & s_trajectory_markEvery, Melder_atof (sdefault_trajectory_markEvery));
 Preferences_addString (Melder_cat (U"" "VowelEditor" U"." "trajectory_colour", 1 >= 2 ? U"." "1" : U""), & s_trajectory_colour [0], U"Black");
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "trajectory_minimumDuration", 1 >= 2 ? U"." "1" : U""), & s_trajectory_minimumDuration, Melder_atof (sdefault_trajectory_minimumDuration));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "trajectory_maximumDuration", 1 >= 2 ? U"." "1" : U""), & s_trajectory_maximumDuration, Melder_atof (sdefault_trajectory_maximumDuration));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "trajectory_duration", 1 >= 2 ? U"." "1" : U""), & s_trajectory_duration, Melder_atof (sdefault_trajectory_duration));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "trajectory_extendDuration", 1 >= 2 ? U"." "1" : U""), & s_trajectory_extendDuration, Melder_atof (sdefault_trajectory_extendDuration));
 _Preferences_addEnum (Melder_cat (U"" "VowelEditor" U"." "marks_speakerType", 1 >= 2 ? U"." "1" : U""), (int *) & s_marks_speakerType, (int) kVowelEditor_speakerType::MIN, (int) kVowelEditor_speakerType::MAX, (conststring32 (*) (int)) kVowelEditor_speakerType_getText, (enum_generic_getValue) kVowelEditor_speakerType_getValue, (int) kVowelEditor_speakerType :: WOMAN);
 _Preferences_addEnum (Melder_cat (U"" "VowelEditor" U"." "marks_dataSet", 1 >= 2 ? U"." "1" : U""), (int *) & s_marks_dataSet, (int) kVowelEditor_marksDataSet::MIN, (int) kVowelEditor_marksDataSet::MAX, (conststring32 (*) (int)) kVowelEditor_marksDataSet_getText, (enum_generic_getValue) kVowelEditor_marksDataSet_getValue, (int) kVowelEditor_marksDataSet :: AMERICAN_ENGLISH);
 Preferences_addString (Melder_cat (U"" "VowelEditor" U"." "marks_fileName", 1 >= 2 ? U"." "1" : U""), & s_marks_fileName [0], U"");
 Preferences_addString (Melder_cat (U"" "VowelEditor" U"." "marks_colour", 1 >= 2 ? U"." "1" : U""), & s_marks_colour [0], U"grey");
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "marks_fontSize", 1 >= 2 ? U"." "1" : U""), & s_marks_fontSize, Melder_atof (sdefault_marks_fontSize));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "f0_start", 1 >= 2 ? U"." "1" : U""), & s_f0_start, Melder_atof (sdefault_f0_start));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "f0_slope", 1 >= 2 ? U"." "1" : U""), & s_f0_slope, Melder_atof (sdefault_f0_slope));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "f0_minimum", 1 >= 2 ? U"." "1" : U""), & s_f0_minimum, Melder_atof (sdefault_f0_minimum));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "f0_maximum", 1 >= 2 ? U"." "1" : U""), & s_f0_maximum, Melder_atof (sdefault_f0_maximum));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "grid_df1", 1 >= 2 ? U"." "1" : U""), & s_grid_df1, Melder_atof (sdefault_grid_df1));
 Preferences_addDouble (Melder_cat (U"" "VowelEditor" U"." "grid_df2", 1 >= 2 ? U"." "1" : U""), & s_grid_df2, Melder_atof (sdefault_grid_df2));

}
# 77 "VowelEditor.cpp" 2
# 1 "../sys/prefs_copyToInstance.h" 1
# 78 "VowelEditor.cpp" 2
# 1 "VowelEditor_prefs.h" 1
# 20 "VowelEditor_prefs.h"
void structVowelEditor :: v_copyPreferencesToInstance () { VowelEditor_Parent :: v_copyPreferencesToInstance ();

 p_shell_width = pref_shell_width ();
 p_shell_height = pref_shell_height ();
 p_soundFollowsMouse = pref_soundFollowsMouse ();
 p_window_frequencyScale = pref_window_frequencyScale ();
 p_window_f1min = pref_window_f1min ();
 p_window_f1max = pref_window_f1max ();
 p_window_f2min = pref_window_f2min ();
 p_window_f2max = pref_window_f2max ();
 p_synthesis_samplingFrequency = pref_synthesis_samplingFrequency ();
 p_synthesis_numberOfFormants = pref_synthesis_numberOfFormants ();
 p_synthesis_q1 = pref_synthesis_q1 ();
 p_synthesis_q2 = pref_synthesis_q2 ();
 str32cpy (& p_synthesis_extraFBPairs [0], pref_synthesis_extraFBPairs ());
 p_trajectory_markEvery = pref_trajectory_markEvery ();
 str32cpy (& p_trajectory_colour [0], pref_trajectory_colour ());
 p_trajectory_minimumDuration = pref_trajectory_minimumDuration ();
 p_trajectory_maximumDuration = pref_trajectory_maximumDuration ();
 p_trajectory_duration = pref_trajectory_duration ();
 p_trajectory_extendDuration = pref_trajectory_extendDuration ();
 p_marks_speakerType = pref_marks_speakerType ();
 p_marks_dataSet = pref_marks_dataSet ();
 str32cpy (& p_marks_fileName [0], pref_marks_fileName ());
 str32cpy (& p_marks_colour [0], pref_marks_colour ());
 p_marks_fontSize = pref_marks_fontSize ();
 p_f0_start = pref_f0_start ();
 p_f0_slope = pref_f0_slope ();
 p_f0_minimum = pref_f0_minimum ();
 p_f0_maximum = pref_f0_maximum ();
 p_grid_df1 = pref_grid_df1 ();
 p_grid_df2 = pref_grid_df2 ();

}
# 79 "VowelEditor.cpp" 2
# 88 "VowelEditor.cpp"
#pragma mark - class TrajectoryPointTier

static Thing _TrajectoryPoint_new () { return new structTrajectoryPoint; } struct structClassInfo theClassInfo_TrajectoryPoint = { U"" "TrajectoryPoint", & theClassInfo_AnyPoint, sizeof (class structTrajectoryPoint), _TrajectoryPoint_new, 0, 0, nullptr}; ClassInfo classTrajectoryPoint = & theClassInfo_TrajectoryPoint;

static autoTrajectoryPoint TrajectoryPoint_create (double time, double x, double y, MelderColour colour) {
 autoTrajectoryPoint thee = Thing_newFromClass (classTrajectoryPoint).static_cast_move<structTrajectoryPoint>();
 thee -> number = time;
 thee -> x = x;
 thee -> y = y;
 thee -> colour = colour;
 return thee;
}

static Thing _Trajectory_new () { return new structTrajectory; } struct structClassInfo theClassInfo_Trajectory = { U"" "Trajectory", & theClassInfo_Function, sizeof (class structTrajectory), _Trajectory_new, 0, 0, nullptr}; ClassInfo classTrajectory = & theClassInfo_Trajectory;

static autoTrajectory Trajectory_create (double duration) {
 try {
  autoTrajectory me = Thing_newFromClass (classTrajectory).static_cast_move<structTrajectory>();
  Function_init (me.get(), 0.0, duration);
  return me;
 } catch (MelderError) {
  do { Melder_appendError (U"trajectory not created."); throw MelderError (); } while (false);
 }
}

static void Trajectory_addPoint (Trajectory me, double time, double x, double y, MelderColour colour) {
 try {
  autoTrajectoryPoint point = TrajectoryPoint_create (time, x, y, colour);
  me -> points . addItem_move (point.move());
 } catch (MelderError) {
  do { Melder_appendError (me, U" no point added."); throw MelderError (); } while (false);
 }
}

#pragma mark - class Vowel

static Thing _VowelSpecification_new () { return new structVowelSpecification; } struct structClassInfo theClassInfo_VowelSpecification = { U"" "VowelSpecification", & theClassInfo_Function, sizeof (class structVowelSpecification), _VowelSpecification_new, 0, 0, nullptr}; ClassInfo classVowelSpecification = & theClassInfo_VowelSpecification;

static autoVowelSpecification VowelSpecification_create (double duration) {
 try {
  autoVowelSpecification me = Thing_newFromClass (classVowelSpecification).static_cast_move<structVowelSpecification>();
  Function_init (me.get(), 0.0, duration);
  me -> formantTier = FormantTier_create (0.0, duration);
  me -> pitchTier = PitchTier_create (0.0, duration);
  return me;
 } catch (MelderError) {
  do { Melder_appendError (U"VowelSpecification not created."); throw MelderError (); } while (false);
 }
}

static autoVowelSpecification VowelSpecification_create_twoFormantSchwa (double duration) {
 try {
  autoVowelSpecification me = VowelSpecification_create (duration);
  autoFormantPoint fp = FormantPoint_create (0.0, 2);
  fp -> formant [1] = 500.0;
  fp -> bandwidth [1] = 50.0;
  fp -> formant [2] = 1500.0;
  fp -> bandwidth [2] = 150.0;
  me -> formantTier -> points. addItem_move (fp.move());
  RealTier_addPoint (me -> pitchTier.get(), 0.0, 140.0);

  fp = FormantPoint_create (duration, 2);
  fp -> formant [1] = 500.0;
  fp -> bandwidth [1] = 50.0;
  fp -> formant [2] = 1500.0;
  fp -> bandwidth [2] = 150.0;
  me -> formantTier -> points. addItem_move (fp.move());
  RealTier_addPoint (me -> pitchTier.get(), duration, 140.0);
  return me;
 } catch (MelderError) {
  do { Melder_appendError (U"Schwa Vowel not created"); throw MelderError (); } while (false);
 }
}

static autoFormantGrid FormantTier_to_FormantGrid (FormantTier me) {
 try {
  const integer numberOfFormants = FormantTier_getMaxNumFormants (me);
  autoFormantGrid thee = FormantGrid_createEmpty (me -> xmin, me -> xmax, numberOfFormants);
  for (integer ipoint = 1; ipoint <= me -> points.size; ipoint ++) {
   const FormantPoint fp = me -> points.at [ipoint];
   const double t = fp -> number;
   for (integer iformant = 1; iformant <= fp -> numberOfFormants; iformant ++) {
    FormantGrid_addFormantPoint (thee.get(), iformant, t, fp -> formant [iformant]);
    FormantGrid_addBandwidthPoint (thee.get(), iformant, t, fp -> bandwidth [iformant]);
   }
  }
  return thee;
 } catch (MelderError) {
  do { Melder_appendError (me, U": no FormantGrid created."); throw MelderError (); } while (false);
 }
}

static inline double VowelEditor_getXFromF2 (VowelEditor me, double f2) {
 return log (f2 / me -> p_window_f2max) / log (me -> p_window_f2min / me -> p_window_f2max);
}

static inline double VowelEditor_getYFromF1 (VowelEditor me, double f1) {
 return log (f1 / me -> p_window_f1max) / log (me -> p_window_f1min / me -> p_window_f1max);
}

static void VowelEditor_getXYFromF1F2 (VowelEditor me, double f1, double f2, double *x, double *y) {
 *y = VowelEditor_getYFromF1 (me, f1);
 *x = VowelEditor_getXFromF2 (me, f2);
}

static void VowelEditor_getF1F2FromXY (VowelEditor me, double x, double y, double *f1, double *f2) {
 *f2 = me -> p_window_f2min * pow (me -> p_window_f2max / me -> p_window_f2min, 1.0 - x);
 *f1 = me -> p_window_f1min * pow (me -> p_window_f1max / me -> p_window_f1min, 1.0 - y);
}


static void appendF1F2F0 (MelderString *statusInfo, conststring32 intro, double f1, double f2, double f0, conststring32 ending) {
 MelderString_append (statusInfo, intro, (isundef (f1) ? U" undef" : Melder_pad (6, Melder_fixed (f1, 1))), U", ", (isundef (f2) ? U" undef" : Melder_pad (6, Melder_fixed (f2, 1))), U", ", (isundef (f0) ? U" undef" : Melder_pad (6, Melder_fixed (f0, 1))), ending);
}

static double getRealFromTextWidget (GuiText me) {
 double value = undefined;
 autostring32 dirty = GuiText_getString (me);
 try {
  Interpreter_numericExpression (nullptr, dirty.get(), & value);
 } catch (MelderError) {
  Melder_clearError ();
  value = undefined;
 }
 return value;
}

static void clipF1F2 (VowelEditor me, double *f1, double *f2) {
 Melder_clip (me -> p_window_f1min, f1, me -> p_window_f1max);
 Melder_clip (me -> p_window_f2min, f2, me -> p_window_f2max);
}

static void clipXY (double *x, double *y) {
 Melder_clip (0.0, x, 1.0);
 Melder_clip (0.0, y, 1.0);
}

static void VowelEditor_updateFromF0StartAndSlopeTextWidgets (VowelEditor me) {
 double f0 = getRealFromTextWidget (me -> f0TextField);
 Melder_clip (me -> p_f0_minimum, & f0, me -> p_f0_maximum);
 GuiText_setString (me -> f0TextField, Melder_double (f0));
 me -> pref_f0_start () = me -> p_f0_start = f0;
 double slope = getRealFromTextWidget (me -> f0SlopeTextField);
 if (isundef (slope))
  slope = 0.0;
 me -> pref_f0_slope () = me -> p_f0_slope = slope;
 GuiText_setString (me -> f0SlopeTextField, Melder_double (slope));
}

static void VowelEditor_updateFromExtendDurationTextWidget (VowelEditor me) {
 double extend = getRealFromTextWidget (me -> extendTextField);
 if (isundef (extend) || extend <= me -> p_trajectory_minimumDuration || extend > me -> p_trajectory_maximumDuration)
  extend = me -> p_trajectory_minimumDuration;
 GuiText_setString (me -> extendTextField, Melder_double (extend));
 me -> pref_trajectory_extendDuration () = me -> p_trajectory_extendDuration = extend;
}

static double VowelEditor_updateFromDurationTextWidget (VowelEditor me) {
 double duration = getRealFromTextWidget (me -> durationTextField);
 if (isundef (duration) || duration < me -> p_trajectory_minimumDuration)
  duration = me -> p_trajectory_minimumDuration;
 me -> pref_trajectory_duration () = me -> p_trajectory_duration = duration;
 GuiText_setString (me -> durationTextField, Melder_double ((round((duration)*1000000)/1000000)));
 return duration;
}

static void Sound_fadeIn (Sound me, double duration, bool fromFirstNonZeroSample) {
 integer istart = 1, numberOfSamples = Melder_iroundDown (duration / me -> dx);
 if (numberOfSamples < 2)
  return;
 if (fromFirstNonZeroSample) {
# 267 "VowelEditor.cpp"
  const double zmin = 0.5 / pow (2.0, 16.0);
  while (fabs (me -> z [1] [istart]) < zmin && istart < me -> nx) {
   me -> z [1] [istart] = 0.0;
   istart ++;
  }
 }
 if (numberOfSamples > me -> nx - istart + 1)
  numberOfSamples = me -> nx - istart + 1;

 for (integer i = 1; i <= numberOfSamples; i ++) {
  const double phase = NUMpi * (i - 1) / (numberOfSamples - 1);
  me -> z [1] [istart + i - 1] *= 0.5 * (1.0 - cos (phase));
 }
}

static void Sound_fadeOut (Sound me, double duration) {
 integer numberOfSamples = Melder_iroundDown (duration / me -> dx);

 if (numberOfSamples > me -> nx)
  numberOfSamples = me -> nx;
 if (numberOfSamples < 2)
  return;
 const integer istart = me -> nx - numberOfSamples;



 for (integer i = 1; i <= numberOfSamples; i ++) {
  const double phase = NUMpi * (i - 1) / (numberOfSamples - 1);
  me -> z [1] [istart + i] *= 0.5 * (1.0 + cos (phase));
 }
}

static double VowelEditor_getF0AtTime (VowelEditor me, double time) {
 double f0 = me -> p_f0_start * pow (2.0, me -> p_f0_slope * time);
 Melder_clip (me -> p_f0_minimum, & f0, me -> p_f0_maximum);
 return f0;
}

static void VowelEditor_reverseFormantTier (VowelEditor me) {
 const FormantTier ft = me -> vowel -> formantTier.get();
 const double duration = ft -> xmax;
 const integer np = ft -> points.size, np_2 = np / 2;

 for (integer i = 1; i <= np_2; i ++) {
  FormantPoint fpt = ft -> points.at [i];
  ft -> points.at [i] = ft -> points.at [np - i + 1];
  ft -> points.at [np - i + 1] = fpt;
  fpt = ft -> points.at [i];
  fpt -> number = duration - fpt -> number;
  fpt = ft -> points.at [np - i + 1];
  fpt -> number = duration - fpt -> number;
 }
 if (np % 2 == 1) {
  const FormantPoint fpt = ft -> points.at [np_2 + 1];
  fpt -> number = duration - fpt -> number;
 }
}

static void VowelEditor_shiftF1F2 (VowelEditor me, double f1_st, double f2_st) {
 FormantTier ft = me -> vowel -> formantTier.get();
 for (integer i = 1; i <= ft -> points.size; i ++) {
  const FormantPoint fp = ft -> points.at [i];
  double f1 = fp -> formant [1], f2 = fp -> formant [2];

  f1 *= pow (2, f1_st / 12.0);
  Melder_clip (me -> p_window_f1min, & f1, me -> p_window_f1max);
  fp -> formant [1] = f1;
  fp -> bandwidth [1] = f1 / me -> p_synthesis_q1;

  f2 *= pow (2, f2_st / 12.0);
  Melder_clip (me -> p_window_f2min, & f2, me -> p_window_f2max);
  fp -> formant [2] = f2;
  fp -> bandwidth [2] = f2 / me -> p_synthesis_q2;
 }
}

static void FormantTier_newDuration (FormantTier me, double newDuration) {
 if (newDuration != me -> xmax) {
  const double multiplier = newDuration / me -> xmax;
  for (integer i = 1; i <= me -> points.size; i ++) {
   const FormantPoint fp = me -> points.at [i];
   fp -> number *= multiplier;
  }
  me -> xmax *= multiplier;
 }
}

static void VowelEditor_updateVowelSpecification (VowelEditor me) {



 const double newDuration = VowelEditor_updateFromDurationTextWidget (me);
 VowelEditor_updateFromF0StartAndSlopeTextWidgets (me);
 const VowelSpecification thee = me -> vowel.get();
 if (newDuration != thee -> xmax) {
  const double multiplier = newDuration / thee -> xmax;
  FormantTier_newDuration (thee -> formantTier.get(), newDuration);
  thee -> xmax *= multiplier;
 }
 const PitchTier him = me -> vowel -> pitchTier.get();
 const double multiplier = newDuration / him -> xmax;
 for (integer i = 1; i <= him -> points.size; i ++) {
  const RealPoint pp = him -> points.at [i];
  pp -> number *= multiplier;
  pp -> value = VowelEditor_getF0AtTime (me, pp -> number);
 }
 him -> xmax *= multiplier;
}

static autoSound VowelEditor_createTargetSound (VowelEditor me) {
 try {
  VowelEditor_updateVowelSpecification (me);
  const autoFormantTier formantTier = Data_copy (me -> vowel -> formantTier.get());
                       autoSound thee = PitchTier_to_Sound_pulseTrain (me -> vowel -> pitchTier.get(), me -> p_synthesis_samplingFrequency, 0.7, 0.05, 30, false);



  const integer numberOfExtraFormants = me -> p_synthesis_numberOfFormants - 2;
  for (integer ipoint = 1; ipoint <= formantTier -> points.size; ipoint ++) {
   const FormantPoint point = formantTier -> points.at [ipoint];
   Melder_clipRight (& point -> numberOfFormants, me -> p_synthesis_numberOfFormants);
   point -> formant. resize (point -> numberOfFormants);






   point -> bandwidth [1] = point -> formant [1] / me -> p_synthesis_q1;
   if (point -> numberOfFormants < 2)
    continue;
   point -> bandwidth [2] = point -> formant [2] / me -> p_synthesis_q2;
   for (integer ifor = 1; ifor <= numberOfExtraFormants; ifor ++) {
    if (point -> numberOfFormants < 2 + ifor)
     break;
    point -> formant [2 + ifor] = me -> extraFrequencyBandwidthPairs [2 * ifor - 1];
    point -> bandwidth [2 + ifor] = me -> extraFrequencyBandwidthPairs [2 * ifor];
   }
  }
  Sound_FormantTier_filter_inplace (thee.get(), formantTier.get());
  Vector_scale (thee.get(), 0.99);
  Sound_fadeIn (thee.get(), 0.005, true);
  Sound_fadeOut (thee.get(), 0.005);
  return thee;
 } catch (MelderError) {
  do { Melder_appendError (U"Target Sound not created."); throw MelderError (); } while (false);
 }
}

static void VowelEditor_VowelSpecification_addPoint (VowelEditor me, double time, double x, double y, bool transFromXYToFrequencies) {
 const VowelSpecification thee = me -> vowel.get();
 if (time > thee -> xmax) {
  thee -> xmax = time;
  thee -> formantTier -> xmax = time;
  thee -> pitchTier -> xmax = time;
 }
 const double f0 = VowelEditor_getF0AtTime (me, time);



 const integer numberOfExtraFormants = me -> extraFrequencyBandwidthPairs.size / 2;
                    autoFormantPoint point = FormantPoint_create (time, 2 + numberOfExtraFormants);
 double f1 = x, f2 = y;
 if (transFromXYToFrequencies)
  VowelEditor_getF1F2FromXY (me, x, y, & f1, & f2);

 point -> formant [1] = f1;
 point -> bandwidth [1] = f1 / me -> p_synthesis_q1;
 point -> formant [2] = f2;
 point -> bandwidth [2] = f2 / me -> p_synthesis_q2;
 for (integer ifor = 1; ifor <= numberOfExtraFormants; ifor ++) {
  point -> formant [2 + ifor] = me -> extraFrequencyBandwidthPairs [2 * ifor - 1];
  point -> bandwidth [2 + ifor] = me -> extraFrequencyBandwidthPairs [2 * ifor];
 }
 thee -> formantTier -> points. addItem_move (point.move());
 RealTier_addPoint (thee -> pitchTier.get(), time, f0);
}

static void VowelEditor_drawF1F2Trajectory (VowelEditor me, Graphics g) {

 const FormantTier thee = me -> vowel -> formantTier.get();
 ((thee -> points.size >= 2) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 448, "thy points.size >= 2"), abort ()));

 const integer glt = Graphics_inqLineType (g);
 const double glw = Graphics_inqLineWidth (g);
 const MelderColour colour = Graphics_inqColour (g);
 const integer nfp = thee -> points.size;
 (! Melder_isTracing ? (void) 0 : Melder_trace ("VowelEditor.cpp", 454, __FUNCTION__, U"number of points ", nfp));
 const FormantPoint fp1 = thee -> points.at [1];
 const double markLength = 0.01;

 Graphics_setInner (g);
 Graphics_setWindow (g, 0.0, 1.0, 0.0, 1.0);
 Graphics_setLineType (g, 0);
 Graphics_setColour (g, MelderColour_fromColourName (me -> p_trajectory_colour));
 if (thee -> xmax - thee -> xmin < 0.005)
  Graphics_setColour (g, Melder_RED);

 auto getx = [=](double f) { return log (f / me -> p_window_f2max) / log (me -> p_window_f2min / me -> p_window_f2max); };
 auto gety = [=](double f) { return log (f / me -> p_window_f1max) / log (me -> p_window_f1min / me -> p_window_f1max); };

 double x1 = getx (fp1 -> formant [2]);
 double y1 = gety (fp1 -> formant [1]);
 double x1p = x1, y1p = y1;
 double t1 = fp1 -> number;
 integer imark = 1;
 for (integer it = 2; it <= nfp; it ++) {
  const FormantPoint fp = thee -> points.at [it];
  const double x2 = getx (fp -> formant [2]);
  const double y2 = gety (fp -> formant [1]);
  const double t2 = fp -> number;
  Graphics_setLineWidth (g, 3);
  if (x1 == x2 && y1 == y2) {
   x1 = x1p;
   y1 = y1p;
  } else {
   Graphics_line (g, x1, y1, x2, y2);
  }
  double tm;
  while (me -> p_trajectory_markEvery > 0 && (tm = me -> p_trajectory_markEvery * imark) < t2) {

   const double fraction = (tm - t1) / (t2 - t1);
   const double dx = x2 - x1, dy = y2 - y1;
   const double xm = x1 + fraction * dx;
   const double ym = y1 + fraction * dy;
   const double d = sqrt (dx * dx + dy * dy);
   if (d > 0.0) {
    double xl1 = dy * markLength / d, xl2 = - xl1;
    double yl1 = dx * markLength / d, yl2 = - yl1;

    if (dx * dy > 0.0) {
     xl1 = -fabs (xl1);
     yl1 = fabs (yl1);
     xl2 = fabs (xl1);
     yl2 = -fabs (yl1);
    } else if (dx * dy < 0.0) {
     xl1 = -fabs (xl1);
     yl1 = -fabs (yl1);
     xl2 = fabs (xl1);
     yl2 = fabs (yl1);
    }
    Graphics_setLineWidth (g, 1);
    (! Melder_isTracing ? (void) 0 : Melder_trace ("VowelEditor.cpp", 509, __FUNCTION__, xm, U" ", ym, U" ", xl1, U" ", xl2, U" ", yl1, U" ", yl2));
    Graphics_line (g, xm + xl1, ym + yl1, xm + xl2, ym + yl2);
   }
   imark ++;
  }
  x1p = x1;
  y1p = y1;
  x1 = x2;
  y1 = y2;
  t1 = t2;
 }

 {
  const double gas = Graphics_inqArrowSize (g), arrowSize = 1.0;
  const double size = 10.0 * arrowSize * Graphics_getResolution (g) / 75.0 / me -> width;
  const double sizeSquared = size * size;
  Graphics_setArrowSize (g, arrowSize);
  integer it = 1;
  const FormantPoint fpn = thee -> points.at [nfp];
  FormantPoint fpi;
  while (it <= nfp - 1) {
   fpi = thee -> points.at [nfp - it];
   const double dx = getx (fpn -> formant [2]) - getx (fpi -> formant [2]);
   const double dy = gety (fpn -> formant [1]) - gety (fpi -> formant [1]);
   const double d2 = dx * dx + dy * dy;
   if (d2 > sizeSquared)
    break;
   it ++;
  }
  Graphics_arrow (g, getx (fpi -> formant [2]), gety (fpi -> formant [1]), getx (fpn -> formant [2]), gety (fpn -> formant [1]));
  Graphics_setArrowSize (g, gas);
 }
 Graphics_unsetInner (g);
 Graphics_setColour (g, colour);
 Graphics_setLineType (g, glt);
 Graphics_setLineWidth (g, glw);
}

static void Table_addColumnIfNotExists_size (Table me, double size) {
 const integer col_size = Table_findColumnIndexFromColumnLabel (me, U"Size");
 if (col_size == 0) {
  Table_appendColumn (me, U"Size");
  for (integer irow = 1; irow <= me -> rows.size; irow ++)
   Table_setNumericValue (me, irow, me -> numberOfColumns, size);
 }
}

static void Table_addColumnIfNotExists_colour (Table me, conststring32 colour) {
 integer col_colour = Table_findColumnIndexFromColumnLabel (me, U"Colour");
 if (col_colour == 0) {
  Table_appendColumn (me, U"Colour");
  for (integer irow = 1; irow <= me -> rows.size; irow ++)
   Table_setStringValue (me, irow, me -> numberOfColumns, colour);
 }
}

static void VowelEditor_getVowelMarksFromFile (VowelEditor me) {
 try {
  do { if (! (str32len (me -> p_marks_fileName) > 0)) do { Melder_appendError (U"There is no file defined with vowel marks."); throw MelderError (); } while (false); } while (false)
                                                 ;
  structMelderFile file { };
  Melder_pathToFile (me -> p_marks_fileName, & file);
  autoDaata data = Data_readFromFile (& file);
  do { if (! (Thing_isa (data.get(), classTable))) do { Melder_appendError (U"\"", MelderFile_name (& file), U"\" is not a Table file"); throw MelderError (); } while (false); } while (false)
                                                              ;

  autoTable newMarks = data.static_cast_move <structTable> ();



  Table_getColumnIndexFromColumnLabel (newMarks.get(), U"Vowel");
  Table_getColumnIndexFromColumnLabel (newMarks.get(), U"F1");
  Table_getColumnIndexFromColumnLabel (newMarks.get(), U"F2");
  Table_addColumnIfNotExists_size (newMarks.get(), me -> p_marks_fontSize);
  me -> marks = newMarks.move();
 } catch (MelderError) {
  do { Melder_appendError (U"Vowel marks from file cannot be shown."); throw MelderError (); } while (false);
 }
}

static void VowelEditor_getMarks (VowelEditor me) {
 autoTable te;
 const char32 *speaker = ( me -> p_marks_speakerType == kVowelEditor_speakerType::MAN ? U"m" :
  me -> p_marks_speakerType == kVowelEditor_speakerType::WOMAN ? U"w" :
  me -> p_marks_speakerType == kVowelEditor_speakerType::CHILD ? U"c": U"m" );
 if (me -> p_marks_dataSet == kVowelEditor_marksDataSet::AMERICAN_ENGLISH) {
  const autoTable thee = Table_create_petersonBarney1952 ();
  te = Table_extractRowsWhereColumn_string (thee.get(), 1, kMelder_string::EQUAL_TO, speaker);
 } else if (me -> p_marks_dataSet == kVowelEditor_marksDataSet::DUTCH) {
  if (me -> p_marks_speakerType == kVowelEditor_speakerType::CHILD) {
   const autoTable thee = Table_create_weenink1983 ();
   te = Table_extractRowsWhereColumn_string (thee.get(), 1, kMelder_string::EQUAL_TO, speaker);
  }
  else {
   const autoTable thee = Table_create_polsVanNierop1973 ();
   te = Table_extractRowsWhereColumn_string (thee.get(), 1, kMelder_string::EQUAL_TO, speaker);
  }
 } else if (me -> p_marks_dataSet == kVowelEditor_marksDataSet::NONE) {
  me -> marks.reset();
  return;
 } else {
  VowelEditor_getVowelMarksFromFile (me);
  return;
 }
                    autoTable newMarks = Table_collapseRows (te.get(), U"IPA", U"", U"F1 F2", U"", U"", U"");
 const integer col_ipa = Table_findColumnIndexFromColumnLabel (newMarks.get(), U"IPA");
 Table_setColumnLabel (newMarks.get(), col_ipa, U"Vowel");

 Table_addColumnIfNotExists_size (newMarks.get(), me -> p_marks_fontSize);
 Table_addColumnIfNotExists_colour (newMarks.get(), me -> p_marks_colour);
 me -> marks = newMarks.move();
}

static void VowelEditor_drawBackground (VowelEditor me, Graphics g) {
 Graphics_setInner (g);
 Graphics_setWindow (g, 0.0, 1.0, 0.0, 1.0);
 Graphics_setGrey (g, 0.0);
 Graphics_setLineType (g, 0);
 Graphics_setLineWidth (g, 1.0);
 Graphics_setGrey (g, 0.5);
 const double fontSize = Graphics_inqFontSize (g);



 if (me -> marks) {
  const integer col_vowel = Table_getColumnIndexFromColumnLabel (me -> marks.get(), U"Vowel");
  const integer col_f1 = Table_getColumnIndexFromColumnLabel (me -> marks.get(), U"F1");
  const integer col_f2 = Table_getColumnIndexFromColumnLabel (me -> marks.get(), U"F2");
  const integer col_size = Table_findColumnIndexFromColumnLabel (me -> marks.get(), U"Size");
  const integer col_colour = Table_findColumnIndexFromColumnLabel (me -> marks.get(), U"Colour");
  for (integer irow = 1; irow <= me -> marks -> rows.size; irow ++) {
   const conststring32 label = Table_getStringValue_Assert (me -> marks.get(), irow, col_vowel);
   const double f1 = Table_getNumericValue_Assert (me -> marks.get(), irow, col_f1);
   const double f2 = Table_getNumericValue_Assert (me -> marks.get(), irow, col_f2);
   if (f1 >= me -> p_window_f1min && f1 <= me -> p_window_f1max && f2 >= me -> p_window_f2min && f2 <= me -> p_window_f2max) {
    double x1, y1;
    VowelEditor_getXYFromF1F2 (me, f1, f2, & x1, & y1);
    double size = me -> p_marks_fontSize;
    if (col_size != 0)
     size = Table_getNumericValue_Assert (me -> marks.get(), irow, col_size);
    if (col_colour != 0) {
     conststring32 colourString = Table_getStringValue_Assert (me -> marks.get(), irow, col_colour);
     MelderColour colour = MelderColour_fromColourNameOrNumberStringOrRGBString (colourString);
     if (! colour. valid())
      colour = MelderColour_fromColourName (me -> p_marks_colour);
     Graphics_setColour (g, colour);
    }
    Graphics_setFontSize (g, size);
    Graphics_setTextAlignment (g, kGraphics_horizontalAlignment::CENTRE, 1);
    Graphics_text (g, x1, y1, label);
   }
  }
 }
 Graphics_setFontSize (g, fontSize);
 Graphics_setGrey (g, 0.0);



 double xl1, yl1, xl2, yl2;
 VowelEditor_getXYFromF1F2 (me, me -> p_window_f2min, me -> p_window_f2min, & xl1, & yl1);
 if (yl1 >= 0.0 && yl1 <= 1.0) {
  VowelEditor_getXYFromF1F2 (me, me -> p_window_f1max, me -> p_window_f1max, & xl2, & yl2);
  if (xl2 >= 0.0 && xl2 <= 1.0) {
   double x [] = { xl1, xl2, 1.0 };
   double y [] = { yl1, yl2, 0.0 };
   Graphics_setGrey (g, 0.6);
   Graphics_fillArea (g, 3, x , y);
   Graphics_setGrey (g, 0.0);
   Graphics_line (g, xl1, yl1, xl2, yl2);
  }
 }



 if (me -> p_grid_df1 < (me -> p_window_f1max - me -> p_window_f1min)) {
  integer iline = Melder_iroundDown ((me -> p_window_f1min + me -> p_grid_df1) / me -> p_grid_df1);
  Graphics_setGrey (g, 0.5);
  Graphics_setLineType (g, 1);
  double f1_gridLine, xg1, yg1, xg2, yg2;
  while ( (f1_gridLine = iline * me -> p_grid_df1) < me -> p_window_f1max) {
   if (f1_gridLine > me -> p_window_f1min) {
    VowelEditor_getXYFromF1F2 (me, f1_gridLine, me -> p_window_f2min, & xg1, & yg1);
    VowelEditor_getXYFromF1F2 (me, f1_gridLine, me -> p_window_f2max, & xg2, & yg2);
    Graphics_line (g, xg1, yg1, xg2, yg2);
   }
   iline ++;
  }
  Graphics_setLineType (g, 0);
  Graphics_setGrey (g, 0.0);
 }



 if (me -> p_grid_df2 < (me -> p_window_f2max - me -> p_window_f2min)) {
  integer iline = Melder_iroundDown ((me -> p_window_f2min + me -> p_grid_df2) / me -> p_grid_df2);
  Graphics_setGrey (g, 0.5);
  Graphics_setLineType (g, 1);
  double f2_gridLine, xg1, yg1, xg2, yg2;
  while ( (f2_gridLine = iline * me -> p_grid_df2) < me -> p_window_f2max) {
   if (f2_gridLine > me -> p_window_f2min) {
    VowelEditor_getXYFromF1F2 (me, me -> p_window_f1min, f2_gridLine, & xg1, & yg1);
    VowelEditor_getXYFromF1F2 (me, me -> p_window_f1max, f2_gridLine, & xg2, & yg2);
    Graphics_line (g, xg1, yg1, xg2, yg2);
   }
   iline ++;
  }
  Graphics_setLineType (g, 0);
  Graphics_setGrey (g, 0.0);
 }
 Graphics_setLineWidth (g, 2.0);
 Graphics_rectangle (g, 0.0, 1.0, 0.0, 1.0);
 Graphics_unsetInner (g);
 Graphics_setGrey (g, 0.0);
 Graphics_markLeft (g, 0.0, false, true, false, Melder_double (me -> p_window_f1max));
 Graphics_markLeft (g, 1.0, false, true, false, Melder_double (me -> p_window_f1min));
 Graphics_markTop (g, 0.0, false, true, false, Melder_double (me -> p_window_f2max));
 Graphics_markTop (g, 1.0, false, true, false, Melder_double (me -> p_window_f2min));

}

#pragma mark - menu methods

static void menu_cb_help (VowelEditor , EditorCommand, UiForm, integer, Stackel, conststring32, Interpreter) {
 Melder_help (U"VowelEditor");
}

static void menu_cb_prefs (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Preferences", cmd -> itemTitle.get(), nullptr);;
  static bool soundFollowsMouse; UiForm_addBoolean (cmd -> d_uiform.get(), & soundFollowsMouse, nullptr, U"Sound follows mouse", me -> default_soundFollowsMouse ());
  UiForm_addLabel (cmd -> d_uiform.get(), nullptr, U"F1 and F2 frequencies are specified by the trajectory.");
  UiForm_addLabel (cmd -> d_uiform.get(), nullptr, U"The bandwidths of a formant can be specified by its Q-value");
  UiForm_addLabel (cmd -> d_uiform.get(), nullptr, U"which defines the sharpness of the peak: Q = frequency / bandwidth. ");
  static double q1; UiForm_addPositive (cmd -> d_uiform.get(), & q1, nullptr, U"F1 sharpness", me -> default_synthesis_q1 ());
  static double q2; UiForm_addPositive (cmd -> d_uiform.get(), & q2, nullptr, U"F2 sharpness", me -> default_synthesis_q2 ());
  UiForm_addLabel (cmd -> d_uiform.get(), nullptr, U"You can define extra fixed formants for the synthesis by supplying");
  UiForm_addLabel (cmd -> d_uiform.get(), nullptr, U"formant frequency bandwidth pairs.");
  static conststring32 fbpairs; UiForm_addSentence (cmd -> d_uiform.get(), & fbpairs, nullptr, U"Frequency bandwidth pairs", me -> default_synthesis_extraFBPairs ());
  UiForm_addLabel (cmd -> d_uiform.get(), nullptr, U"The total number of formants used for synthesis");
  static integer numberOfFormants; UiForm_addNatural (cmd -> d_uiform.get(), & numberOfFormants, nullptr, U"Number of formants for synthesis", me -> default_synthesis_numberOfFormants ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  UiForm_setBoolean (cmd -> d_uiform.get(), & soundFollowsMouse, me -> p_soundFollowsMouse);
  UiForm_setReal (cmd -> d_uiform.get(), & q1, me -> p_synthesis_q1);
  UiForm_setReal (cmd -> d_uiform.get(), & q2, me -> p_synthesis_q2);
  UiForm_setString (cmd -> d_uiform.get(), & fbpairs, me -> p_synthesis_extraFBPairs);
  UiForm_setInteger (cmd -> d_uiform.get(), & numberOfFormants, me -> p_synthesis_numberOfFormants);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  me -> pref_soundFollowsMouse () = me -> p_soundFollowsMouse = soundFollowsMouse;
  me -> pref_synthesis_q1 () = me -> p_synthesis_q1 = q1;
  me -> pref_synthesis_q2 () = me -> p_synthesis_q2 = q2;
  autoVEC extraFrequencyBandwidthPairs = newVECfromString (fbpairs);

  do { if (! (extraFrequencyBandwidthPairs.size % 2 == 0)) do { Melder_appendError (U"There should be an even number of values in the \"Frequencies and bandwidths pairs\" list."); throw MelderError (); } while (false); } while (false)
                                                                                                 ;




  for (integer item = 1; item <= extraFrequencyBandwidthPairs.size; item ++) {
   do { if (! (extraFrequencyBandwidthPairs [item] > 0)) do { Melder_appendError (U"All values frequency bandwidth values should be positive."); throw MelderError (); } while (false); } while (false)
                                                                 ;
   if (item % 2 == 1)
    do { if (! (extraFrequencyBandwidthPairs [item] < 0.5 * me -> p_synthesis_samplingFrequency)) do { Melder_appendError (U"All formant frequencies should be below the Nyquist frequency (", 0.5 * me -> p_synthesis_samplingFrequency, U" Hz."); throw MelderError (); } while (false); } while (false)

                                                     ;
  }
  const integer numberOfPairs = extraFrequencyBandwidthPairs.size / 2;
  do { if (! (numberOfFormants <= numberOfPairs + 2)) do { Melder_appendError (U"The \"Number of formants for synthesis\" should not exceed the number of formants specified (", numberOfPairs + 2, U"). Either lower the number of formants for synthesis or specify more " "frequency bandwidth pairs."); throw MelderError (); } while (false); } while (false)


                                ;



  str32ncpy (me -> p_synthesis_extraFBPairs, fbpairs, 1+1023); me -> p_synthesis_extraFBPairs [1+1023 - 1] = U'\0'; str32cpy (me -> pref_synthesis_extraFBPairs (), me -> p_synthesis_extraFBPairs);;
  me -> pref_synthesis_numberOfFormants () = me -> p_synthesis_numberOfFormants = numberOfFormants;
  me -> extraFrequencyBandwidthPairs = extraFrequencyBandwidthPairs.move();
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_ranges_f1f2 (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"F1 (vert) and F2 (hor) view ranges", cmd -> itemTitle.get(), nullptr);;
  static double f1min; UiForm_addPositive (cmd -> d_uiform.get(), & f1min, nullptr, U"left F1 range (Hz)", me -> default_window_f1min ());
  static double f1max; UiForm_addPositive (cmd -> d_uiform.get(), & f1max, nullptr, U"right F1 range (Hz)", me -> default_window_f1max ());
  static double f2min; UiForm_addPositive (cmd -> d_uiform.get(), & f2min, nullptr, U"left F2 range (Hz)", me -> default_window_f2min ());
  static double f2max; UiForm_addPositive (cmd -> d_uiform.get(), & f2max, nullptr, U"right F2 range (Hz)", me -> default_window_f2max ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  UiForm_setReal (cmd -> d_uiform.get(), & f1min, me -> p_window_f1min);
  UiForm_setReal (cmd -> d_uiform.get(), & f1max, me -> p_window_f1max);
  UiForm_setReal (cmd -> d_uiform.get(), & f2min, me -> p_window_f2min);
  UiForm_setReal (cmd -> d_uiform.get(), & f2max, me -> p_window_f2max);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  me -> pref_window_f1min () = me -> p_window_f1min = f1min;
  me -> pref_window_f1max () = me -> p_window_f1max = f1max;
  me -> pref_window_f2min () = me -> p_window_f2min = f2min;
  me -> pref_window_f2max () = me -> p_window_f2max = f2max;
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_publishSound (VowelEditor me, EditorCommand, UiForm, integer, Stackel, conststring32, Interpreter) {
 autoSound publish = VowelEditor_createTargetSound (me);
 Editor_broadcastPublication (me, publish.move());
}

static void menu_cb_extract_FormantGrid (VowelEditor me, EditorCommand, UiForm, integer, Stackel, conststring32, Interpreter) {
 VowelEditor_updateVowelSpecification (me);
 autoFormantGrid publish = FormantTier_to_FormantGrid (me -> vowel -> formantTier.get());
 Editor_broadcastPublication (me, publish.move());
}

static void menu_cb_extract_KlattGrid (VowelEditor me, EditorCommand, UiForm, integer, Stackel, conststring32, Interpreter) {
 VowelEditor_updateVowelSpecification (me);
 autoFormantGrid fg = FormantTier_to_FormantGrid (me -> vowel -> formantTier.get());
 autoKlattGrid publish = KlattGrid_create (fg -> xmin, fg -> xmax, fg -> formants.size, 0, 0, 0, 0, 0, 0);
 KlattGrid_addVoicingAmplitudePoint (publish.get(), fg -> xmin, 90.0);
 KlattGrid_replacePitchTier (publish.get(), me -> vowel -> pitchTier.get());
 KlattGrid_replaceFormantGrid (publish.get(), kKlattGridFormantType::ORAL, fg.get());
 Editor_broadcastPublication (me, publish.move());
}

static void menu_cb_extract_PitchTier (VowelEditor me, EditorCommand, UiForm, integer, Stackel, conststring32, Interpreter) {
 VowelEditor_updateVowelSpecification (me);
 autoPitchTier publish = Data_copy (me -> vowel -> pitchTier.get());
 Editor_broadcastPublication (me, publish.move());
}

static void menu_cb_drawTrajectory (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Draw trajectory", cmd -> itemTitle.get(), nullptr);
  me -> v_form_pictureWindow (cmd);
  static bool garnish; UiForm_addBoolean (cmd -> d_uiform.get(), & garnish, nullptr, U"Garnish", true);
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  me -> v_ok_pictureWindow (cmd);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  me -> v_do_pictureWindow (cmd);
  Editor_openPraatPicture (me);
  if (garnish)
   VowelEditor_drawBackground (me, me -> pictureGraphics);
  VowelEditor_drawF1F2Trajectory (me, me -> pictureGraphics);
  Editor_closePraatPicture (me);
 }
}

static void menu_cb_showOneVowelMark (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Show one vowel mark", cmd -> itemTitle.get(), nullptr);;
  static conststring32 mark; UiForm_addWord (cmd -> d_uiform.get(), & mark, nullptr, U"Mark", U"u");
  static double f1; UiForm_addPositive (cmd -> d_uiform.get(), & f1, nullptr, U"F1 (Hz)", U"300.0");
  static double f2; UiForm_addPositive (cmd -> d_uiform.get(), & f2, nullptr, U"F2 (Hz)", U"600.0");
  static double fontSize; UiForm_addPositive (cmd -> d_uiform.get(), & fontSize, nullptr, U"Font size", U"14.0");
  static MelderColour colour; UiForm_addColour (cmd -> d_uiform.get(), & colour, nullptr, U"Colour", U"Green");
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  do { if (! (f1 >= me -> p_window_f1min && f1 <= me -> p_window_f1max)) do { Melder_appendError (U"The first formant should be in the range from ", me -> p_window_f1min, U" to ", me -> p_window_f1max, U" Hz."); throw MelderError (); } while (false); } while (false)
                                                                                                             ;
  do { if (! (f2 >= me -> p_window_f2min && f2 <= me -> p_window_f1max)) do { Melder_appendError (U"The second formant should be in the range from ", me -> p_window_f2min, U" to ", me -> p_window_f2max, U" Hz."); throw MelderError (); } while (false); } while (false)
                                                                                                              ;
  if (! me -> marks)
   me -> marks = Table_createWithColumnNames (1, U"IPA F1 F2 Size Colour");
  else
   Table_appendRow (me -> marks.get());
  integer irow = me -> marks -> rows.size;
  Table_setStringValue (me -> marks.get(), irow, 1, mark);
  Table_setNumericValue (me -> marks.get(), irow, 2, f1);
  Table_setNumericValue (me -> marks.get(), irow, 3, f2);
  Table_setNumericValue (me -> marks.get(), irow, 4, fontSize);
  Table_setStringValue (me -> marks.get(), irow, 5, MelderColour_name (colour));
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_showVowelMarks (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Show vowel marks", cmd -> itemTitle.get(), nullptr);;
  static enum kVowelEditor_marksDataSet dataSet; { enum kVowelEditor_marksDataSet _compilerTypeCheckDummy = me -> default_marks_dataSet (); _compilerTypeCheckDummy = dataSet; (void) _compilerTypeCheckDummy; } { UiField _radio = UiForm_addOptionMenu (cmd -> d_uiform.get(), (int *) & dataSet, nullptr, nullptr, U"Data set", (int) me -> default_marks_dataSet () - (int) kVowelEditor_marksDataSet::MIN + 1, (int) kVowelEditor_marksDataSet::MIN); for (int _ienum = (int) kVowelEditor_marksDataSet::MIN; _ienum <= (int) kVowelEditor_marksDataSet::MAX; _ienum ++) UiOptionMenu_addButton (_radio, kVowelEditor_marksDataSet_getText ((enum kVowelEditor_marksDataSet) _ienum)); }
  static enum kVowelEditor_speakerType speaker; { enum kVowelEditor_speakerType _compilerTypeCheckDummy = me -> default_marks_speakerType (); _compilerTypeCheckDummy = speaker; (void) _compilerTypeCheckDummy; } { UiField _radio = UiForm_addOptionMenu (cmd -> d_uiform.get(), (int *) & speaker, nullptr, nullptr, U"Speaker", (int) me -> default_marks_speakerType () - (int) kVowelEditor_speakerType::MIN + 1, (int) kVowelEditor_speakerType::MIN); for (int _ienum = (int) kVowelEditor_speakerType::MIN; _ienum <= (int) kVowelEditor_speakerType::MAX; _ienum ++) UiOptionMenu_addButton (_radio, kVowelEditor_speakerType_getText ((enum kVowelEditor_speakerType) _ienum)); }
  static double fontSize; UiForm_addPositive (cmd -> d_uiform.get(), & fontSize, nullptr, U"Font size (points)", me -> default_marks_fontSize ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  dataSet = me -> p_marks_dataSet ; UiForm_setOption (cmd -> d_uiform.get(), (int *) & dataSet, (int) me -> p_marks_dataSet - (int) kVowelEditor_marksDataSet::MIN + 1);
  speaker = me -> p_marks_speakerType ; UiForm_setOption (cmd -> d_uiform.get(), (int *) & speaker, (int) me -> p_marks_speakerType - (int) kVowelEditor_speakerType::MIN + 1);
  UiForm_setReal (cmd -> d_uiform.get(), & fontSize, me -> p_marks_fontSize);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  me -> pref_marks_dataSet () = me -> p_marks_dataSet = dataSet;
  me -> pref_marks_speakerType () = me -> p_marks_speakerType = speaker;
  me -> pref_marks_fontSize () = me -> p_marks_fontSize = fontSize;
  VowelEditor_getMarks (me);
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_showVowelMarksFromTableFile (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 if (! cmd -> d_uiform) { cmd -> d_uiform = UiInfile_createE (cmd, U"VowelEditor: Show vowel marks from Table file", cmd -> itemTitle.get(), U"VowelEditor: Show vowel marks from Table file..."); } if (! _args_ && ! _sendingForm_ && ! _sendingString_) {;
 (void) interpreter; UiInfile_do (cmd -> d_uiform.get()); } else { MelderFile file; structMelderFile _file2 { }; if (_args_) { do { if (! (_narg_ == 1)) do { Melder_appendError (U"Command requires exactly 1 argument, the name of the file to read, instead of the given ", _narg_, U" arguments."); throw MelderError (); } while (false); } while (false); do { if (! (_args_ [1]. which == 1)) do { Melder_appendError (U"The file name argument should be a string, not ", _args_ [1]. whichText(), U"."); throw MelderError (); } while (false); } while (false); Melder_relativePathToFile (_args_ [1]. getString(), & _file2); file = & _file2; } else if (_sendingString_) { Melder_relativePathToFile (_sendingString_, & _file2); file = & _file2; } else { file = UiFile_getFile (cmd -> d_uiform.get()); }
  str32ncpy (me -> p_marks_fileName, Melder_fileToPath (file), 1+1023); me -> p_marks_fileName [1+1023 - 1] = U'\0'; str32cpy (me -> pref_marks_fileName (), me -> p_marks_fileName);;
  me -> pref_marks_speakerType () = me -> p_marks_speakerType = kVowelEditor_speakerType::UNKNOWN;
  me -> pref_marks_dataSet () = me -> p_marks_dataSet = kVowelEditor_marksDataSet::OTHER;
  VowelEditor_getVowelMarksFromFile (me);
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_setF0 (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Set f0", cmd -> itemTitle.get(), nullptr);;
  static double f0Start; UiForm_addPositive (cmd -> d_uiform.get(), & f0Start, nullptr, U"Start f0 (Hz)", me -> default_f0_start ());
  static double f0Slope; UiForm_addReal (cmd -> d_uiform.get(), & f0Slope, nullptr, U"Slope (oct/s)", me -> default_f0_slope ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  UiForm_setReal (cmd -> d_uiform.get(), & f0Start, me -> p_f0_start);
  UiForm_setReal (cmd -> d_uiform.get(), & f0Slope, me -> p_f0_slope);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  Melder_clip (me -> p_f0_minimum, & f0Start, me -> p_f0_maximum);
  me -> pref_f0_start () = me -> p_f0_start = f0Start;
  me -> pref_f0_slope () = me -> p_f0_slope = f0Slope;
  GuiText_setString (me -> f0TextField, Melder_double (f0Start));
  GuiText_setString (me -> f0SlopeTextField, Melder_double (f0Slope));
 }
}

static void menu_cb_setF3F4 (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Set F3 & F4", cmd -> itemTitle.get(), nullptr);;
  static double f3; UiForm_addPositive (cmd -> d_uiform.get(), & f3, nullptr, U"F3 (Hz)", U"2500.0");
  static double b3; UiForm_addPositive (cmd -> d_uiform.get(), & b3, nullptr, U"B3 (Hz)", U"250.0");
  static double f4; UiForm_addPositive (cmd -> d_uiform.get(), & f4, nullptr, U"F4 (Hz)", U"3500.0");
  static double b4; UiForm_addPositive (cmd -> d_uiform.get(), & b4, nullptr, U"B4 (Hz)", U"350.0");
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  do { if (! (f3 < f4)) do { Melder_appendError (U"F4 should be larger than F3."); throw MelderError (); } while (false); } while (false)
                                   ;
  me -> pref_synthesis_numberOfFormants () = me -> p_synthesis_numberOfFormants = 4;
  me -> extraFrequencyBandwidthPairs [1] = f3;
  me -> extraFrequencyBandwidthPairs [2] = b3;
  me -> extraFrequencyBandwidthPairs [3] = f4;
  me -> extraFrequencyBandwidthPairs [4] = b4;
 }
}

static void menu_cb_reverseTrajectory (VowelEditor me, EditorCommand, UiForm, integer, Stackel, conststring32, Interpreter) {
 VowelEditor_reverseFormantTier (me);
 Graphics_updateWs (me -> graphics.get());
}

static void menu_cb_newTrajectory (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"New Trajectory", cmd -> itemTitle.get(), nullptr);;
  static double startF1; UiForm_addPositive (cmd -> d_uiform.get(), & startF1, nullptr, U"Start F1 (Hz)", U"700.0");
  static double startF2; UiForm_addPositive (cmd -> d_uiform.get(), & startF2, nullptr, U"Start F2 (Hz)", U"1200.0");
  static double endF1; UiForm_addPositive (cmd -> d_uiform.get(), & endF1, nullptr, U"End F1 (Hz)", U"350.0");
  static double endF2; UiForm_addPositive (cmd -> d_uiform.get(), & endF2, nullptr, U"End F2 (Hz)", U"800.0");
  static double duration; UiForm_addPositive (cmd -> d_uiform.get(), & duration, nullptr, U"Duration (s)", me -> default_trajectory_duration ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  UiForm_setReal (cmd -> d_uiform.get(), & duration, me -> p_trajectory_duration);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  me -> vowel = VowelSpecification_create (duration);
  clipF1F2 (me, & startF1, & startF2);
  VowelEditor_VowelSpecification_addPoint (me, 0.0, startF1, startF2, false);
  clipF1F2 (me, & endF1, & endF2);
  VowelEditor_VowelSpecification_addPoint (me, duration, endF1, endF2, false);
  GuiText_setString (me -> durationTextField, Melder_double ((round((duration)*1000000)/1000000)));
  me -> pref_trajectory_duration () = me -> p_trajectory_duration = duration;
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_extendTrajectory (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Extend Trajectory", cmd -> itemTitle.get(), nullptr);;
  static double toF1; UiForm_addPositive (cmd -> d_uiform.get(), & toF1, nullptr, U"To F1 (Hz)", U"500.0");
  static double toF2; UiForm_addPositive (cmd -> d_uiform.get(), & toF2, nullptr, U"To F2 (Hz)", U"1500.0");
  static double extendDuration; UiForm_addPositive (cmd -> d_uiform.get(), & extendDuration, nullptr, U"Extend duration (s)", me -> default_trajectory_extendDuration ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  UiForm_setReal (cmd -> d_uiform.get(), & extendDuration, me -> p_trajectory_extendDuration);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  const double endTime = me -> vowel -> xmax + extendDuration;
  clipF1F2 (me, & toF1, & toF2);
  VowelEditor_VowelSpecification_addPoint (me, endTime, toF1, toF2, false);
  GuiText_setString (me -> durationTextField, Melder_double ((round((endTime)*1000000)/1000000)));
  GuiText_setString (me -> extendTextField, Melder_double ((round((extendDuration)*1000000)/1000000)));
  me -> pref_trajectory_extendDuration () = me -> p_trajectory_extendDuration = extendDuration;
  me -> pref_trajectory_duration () = me -> p_trajectory_duration = endTime;
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_modifyTrajectoryDuration (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Modify duration", cmd -> itemTitle.get(), nullptr);;
  static double newDuration; UiForm_addPositive (cmd -> d_uiform.get(), & newDuration, nullptr, U"New duration (s)", me -> default_trajectory_duration ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  UiForm_setReal (cmd -> d_uiform.get(), & newDuration, me -> p_trajectory_duration);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  do { if (! (newDuration > me -> p_trajectory_minimumDuration)) do { Melder_appendError (U"The duration should be larger than ", me -> p_trajectory_minimumDuration, U" s."); throw MelderError (); } while (false); } while (false)
                                                                                   ;
  me -> pref_trajectory_duration () = me -> p_trajectory_duration = newDuration;
  GuiText_setString (me -> durationTextField, Melder_double ((round((newDuration)*1000000)/1000000)));
 }
}

static void menu_cb_shiftTrajectory (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Shift trajectory", cmd -> itemTitle.get(), nullptr);;
  static double f1; UiForm_addReal (cmd -> d_uiform.get(), & f1, nullptr, U"F1 (semitones)", U"0.5");
  static double f2; UiForm_addReal (cmd -> d_uiform.get(), & f2, nullptr, U"F2 (semitones)", U"0.5");
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  VowelEditor_shiftF1F2 (me, f1, f2);
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_showTrajectoryTimeMarksEvery (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Show trajectory time marks every", cmd -> itemTitle.get(), nullptr);;
  static double distance; UiForm_addPositive (cmd -> d_uiform.get(), & distance, nullptr, U"Distance (s)", me -> default_trajectory_markEvery ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  UiForm_setReal (cmd -> d_uiform.get(), & distance, me -> p_trajectory_markEvery);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  me -> pref_trajectory_markEvery () = me -> p_trajectory_markEvery = distance;
  Graphics_updateWs (me -> graphics.get());
 }
}

static void menu_cb_trajectory_settings (VowelEditor me, EditorCommand cmd, UiForm _sendingForm_, integer _narg_, Stackel _args_, conststring32 _sendingString_, Interpreter interpreter) {
 UiField _radio_ = nullptr; (void) _radio_; if (cmd -> d_uiform) goto _form_inited_; cmd -> d_uiform = UiForm_createE (cmd, U"Trajectory settings", cmd -> itemTitle.get(), nullptr);;
  static double distance; UiForm_addPositive (cmd -> d_uiform.get(), & distance, nullptr, U"Distance between time marks (s)", me -> default_trajectory_markEvery ());
  static conststring32 colour; UiForm_addWord (cmd -> d_uiform.get(), & colour, nullptr, U"Trajectory coulour", me -> default_trajectory_colour ());
 UiForm_finish (cmd -> d_uiform.get()); _form_inited_: if (! _args_ && ! _sendingForm_ && ! _sendingString_) {
  UiForm_setReal (cmd -> d_uiform.get(), & distance, me -> p_trajectory_markEvery);
  UiForm_setString (cmd -> d_uiform.get(), & colour, me -> p_trajectory_colour);
 UiForm_do (cmd -> d_uiform.get(), false); } else if (! _sendingForm_) { UiForm_parseStringE (cmd, _narg_, _args_, _sendingString_, interpreter); } else {
  me -> pref_trajectory_markEvery () = me -> p_trajectory_markEvery = distance;
  str32ncpy (me -> p_trajectory_colour, colour, 1+1023); me -> p_trajectory_colour [1+1023 - 1] = U'\0'; str32cpy (me -> pref_trajectory_colour (), me -> p_trajectory_colour);;
  Graphics_updateWs (me -> graphics.get());
 }

}

#pragma mark - button methods

static void gui_button_cb_play (VowelEditor me, GuiButtonEvent ) {
 autoSound thee = VowelEditor_createTargetSound (me);
 Sound_play (thee.get(), nullptr, nullptr);
 Graphics_updateWs (me -> graphics.get());
}

static void gui_button_cb_publish (VowelEditor me, GuiButtonEvent ) {
 autoSound publish = VowelEditor_createTargetSound (me);
 Editor_broadcastPublication (me, publish.move());
}

static void gui_button_cb_reverse (VowelEditor me, GuiButtonEvent ) {
 VowelEditor_reverseFormantTier (me);
 structGuiButtonEvent play_event { };
 gui_button_cb_play (me, & play_event);
}

static void gui_drawingarea_cb_expose (VowelEditor me, GuiDrawingArea_ExposeEvent ) {
 ((me) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1057, "me"), abort ()));
 ((me -> vowel) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1058, "my vowel"), abort ()));
 double ts = me -> vowel -> xmin, te = me -> vowel -> xmax;
 const FormantTier ft = me -> vowel -> formantTier.get();
 ((ft) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1061, "ft"), abort ()));
 static MelderString statusInfo;
 if (! me -> graphics)
  return;
 Graphics_clearWs (me -> graphics.get());

 appendF1F2F0 (& statusInfo, U"Start (F1,F2,f0) = (", FormantTier_getValueAtTime (ft, 1, ts),
  FormantTier_getValueAtTime (ft, 2, ts), VowelEditor_getF0AtTime (me, ts), U")");
 GuiLabel_setText (me -> startInfo, statusInfo.string);
 MelderString_empty (& statusInfo);

 appendF1F2F0 (& statusInfo, U"End (F1,F2,f0) = (", FormantTier_getValueAtTime (ft, 1, te),
  FormantTier_getValueAtTime (ft, 2, te), VowelEditor_getF0AtTime (me, te), U")");
 GuiLabel_setText (me -> endInfo, statusInfo.string);
 MelderString_empty (& statusInfo);

 Graphics_setGrey (me -> graphics.get(), 0.9);
 Graphics_fillRectangle (me -> graphics.get(), 0.0, 1.0, 0.0, 1.0);
 Graphics_setInner (me -> graphics.get());
 Graphics_setWindow (me -> graphics.get(), 0.0, 1.0, 0.0, 1.0);
 Graphics_setGrey (me -> graphics.get(), 1.0);
 Graphics_fillRectangle (me -> graphics.get(), 0.0, 1.0, 0.0, 1.0);
 Graphics_unsetInner (me -> graphics.get());
 Graphics_setGrey (me -> graphics.get(), 0.0);

 VowelEditor_drawBackground (me, me -> graphics.get());
 ((me) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1087, "me"), abort ()));
 ((me -> vowel) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1088, "my vowel"), abort ()));
 ((me -> vowel -> formantTier) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1089, "my vowel -> formantTier"), abort ()));
 VowelEditor_drawF1F2Trajectory (me, me -> graphics.get());
}

static void gui_drawingarea_cb_resize (VowelEditor me, GuiDrawingArea_ResizeEvent event) {
 ((me) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1094, "me"), abort ()));
 if (! me -> graphics)
  return;
 me -> width = event -> width;
 me -> height = event -> height;
 Graphics_setWsViewport (me -> graphics.get(), 0.0, me -> width, 0.0, me -> height);
 Graphics_setWsWindow (me -> graphics.get(), 0.0, me -> width, 0.0, me -> height);
 Graphics_setViewport (me -> graphics.get(), 0.0, me -> width, 0.0, me -> height);
 Graphics_updateWs (me -> graphics.get());



 me -> pref_shell_width () = me -> p_shell_width = GuiShell_getShellWidth (me -> windowForm);
 me -> pref_shell_height () = me -> p_shell_height = GuiShell_getShellHeight (me -> windowForm);
}



static void gui_drawingarea_cb_click (VowelEditor me, GuiDrawingArea_ClickEvent event) {
 const double t0 = Melder_clock ();
 integer iskipped = 0;
 struct structGuiButtonEvent gb_event { 0 };
 Graphics_setInner (me -> graphics.get());

 double x, y, t, dt = 0.0;
 Graphics_getMouseLocation (me -> graphics.get(), & x, & y);
 clipXY (& x, & y);

 if (event -> shiftKeyPressed) {
  VowelEditor_updateFromExtendDurationTextWidget (me);
  (me -> shiftKeyPressed) ++;
  dt = me -> vowel -> xmax + me -> p_trajectory_extendDuration;
  t = 0.0 + dt;
  VowelEditor_VowelSpecification_addPoint (me, t, x, y, true);
  GuiText_setString (me -> durationTextField, Melder_double (t));
  goto end;
 } else {
  t = 0.0;
  me -> shiftKeyPressed = 0;
  me -> vowel = VowelSpecification_create (me -> p_trajectory_minimumDuration);
  VowelEditor_VowelSpecification_addPoint (me, t, x, y, true);
  GuiText_setString (me -> durationTextField, Melder_double (t));
  if (! me -> p_soundFollowsMouse) {
   VowelEditor_VowelSpecification_addPoint (me, me -> p_trajectory_minimumDuration, x, y, true);
   goto end;
  }
 }

 Graphics_xorOn (me -> graphics.get(), Melder_BLUE);
 while (Graphics_mouseStillDown (me -> graphics.get())) {
  const double xb = x, yb = y, tb = t;
  t = Melder_clock () - t0 + dt;
  Graphics_getMouseLocation (me -> graphics.get(), & x, & y);
  clipXY (& x, & y);



  if (xb == x && yb == y) {
   iskipped ++;
   continue;
  }



  if (iskipped > 0)
   VowelEditor_VowelSpecification_addPoint (me, tb, xb, yb, true);
  iskipped = 0;
  Graphics_line (me -> graphics.get(), xb, yb, x, y);

  VowelEditor_VowelSpecification_addPoint (me, t, x, y, true);
  GuiText_setString (me -> durationTextField, Melder_double ((round((t)*1000000)/1000000)));
 }
 t = Melder_clock () - t0;



 Melder_clipLeft (me -> p_trajectory_minimumDuration, & t);
 t += dt;
 GuiText_setString (me -> durationTextField, Melder_double ((round((t)*1000000)/1000000)));
 VowelEditor_VowelSpecification_addPoint (me, t, x, y, true);

 Graphics_xorOff (me -> graphics.get());

end:
 Graphics_unsetInner (me -> graphics.get());




 gui_button_cb_play (me, & gb_event);
}






static void updateWidgets (void *void_me) {
 VowelEditor me = (VowelEditor) void_me;
 (void) me;
}

void structVowelEditor :: v_destroy () noexcept {
 VowelEditor_Parent :: v_destroy ();
}

void structVowelEditor :: v_createMenus () {
 VowelEditor_Parent :: v_createMenus ();

 Editor_addMenu (this, U"View", 0);
 Editor_addCommand (this, U"File", U"Preferences...", 0, menu_cb_prefs);
 Editor_addCommand (this, U"File", U"-- publish data --", 0, nullptr);
 Editor_addCommand (this, U"File", U"Publish Sound", 0, menu_cb_publishSound);
 Editor_addCommand (this, U"File", U"Extract KlattGrid", 0, menu_cb_extract_KlattGrid);
 Editor_addCommand (this, U"File", U"Extract FormantGrid", 0, menu_cb_extract_FormantGrid);
 Editor_addCommand (this, U"File", U"Extract PitchTier", 0, menu_cb_extract_PitchTier);
 Editor_addCommand (this, U"File", U"-- drawing --", 0, nullptr);
 Editor_addCommand (this, U"File", U"Draw trajectory...", 0, menu_cb_drawTrajectory);
 Editor_addCommand (this, U"File", U"-- scripting --", 0, nullptr);
 Editor_addCommand (this, U"Edit", U"-- f0 --", 0, nullptr);
 Editor_addCommand (this, U"Edit", U"Set f0...", 0, menu_cb_setF0);
 Editor_addCommand (this, U"Edit", U"Set F3 & F4...", (1 << 14), menu_cb_setF3F4);
 Editor_addCommand (this, U"Edit", U"-- trajectory commands --", 0, nullptr);
 Editor_addCommand (this, U"Edit", U"Reverse trajectory", 0, menu_cb_reverseTrajectory);
 Editor_addCommand (this, U"Edit", U"Modify trajectory duration...", 0, menu_cb_modifyTrajectoryDuration);
 Editor_addCommand (this, U"Edit", U"New trajectory...", 0, menu_cb_newTrajectory);
 Editor_addCommand (this, U"Edit", U"Extend trajectory...", 0, menu_cb_extendTrajectory);
 Editor_addCommand (this, U"Edit", U"Shift trajectory...", 0, menu_cb_shiftTrajectory);
 Editor_addCommand (this, U"View", U"F1 & F2 range...", 0, menu_cb_ranges_f1f2);
 Editor_addCommand (this, U"View", U"--show vowel marks--", 0, nullptr);
 Editor_addCommand (this, U"View", U"Show one vowel mark...", (1 << 14), menu_cb_showOneVowelMark);
 Editor_addCommand (this, U"View", U"Show vowel marks...", (1 << 14), menu_cb_showVowelMarks);
 Editor_addCommand (this, U"View", U"Show vowel marks from fixed set...", 0, menu_cb_showVowelMarks);
 Editor_addCommand (this, U"View", U"Show vowel marks from Table file...", 0, menu_cb_showVowelMarksFromTableFile);
 Editor_addCommand (this, U"View", U"--show trajectory settings--", 0, nullptr);
 Editor_addCommand (this, U"View", U"Trajectory settings...", 0, menu_cb_trajectory_settings);
 Editor_addCommand (this, U"View", U"Show trajectory time marks every...", (1 << 14), menu_cb_showTrajectoryTimeMarksEvery);
}

void structVowelEditor :: v_createHelpMenuItems (EditorMenu menu) {
 VowelEditor_Parent :: v_createHelpMenuItems (menu);
 EditorMenu_addCommand (menu, U"VowelEditor help", '?', menu_cb_help);
}

void structVowelEditor :: v_createChildren ()
{
 const int button_width = 90, text_width = 95, status_info_width = 330;
 int top, bottom, bottom_widgets_top, bottom_widgets_bottom, bottom_widgets_halfway;


 int left = 10, right = left + button_width;
 bottom_widgets_top = top = -(60+(3*16/2)) + 10;
 bottom_widgets_bottom = bottom = -(3*16/2);
 playButton = GuiButton_createShown (this -> windowForm, left, right, top, bottom, U"Play", gui_button_cb_play, this, 0);
 left = right + 10;
 right = left + button_width;
 reverseButton = GuiButton_createShown (this -> windowForm, left, right, top, bottom, U"Reverse", gui_button_cb_reverse, this, 0);
 left = right + 10;
 right = left + button_width;
 publishButton = GuiButton_createShown (this -> windowForm, left, right, top, bottom, U"Publish", gui_button_cb_publish, this, 0);






 left = right + 10;
 right = left + text_width;
 bottom_widgets_halfway = bottom = (top + bottom) / 2;
 top = bottom_widgets_top;
 GuiLabel_createShown (this -> windowForm, left, right, top , bottom, U"Duration (s):", 0);
 top = bottom;
 bottom = bottom_widgets_bottom;
 durationTextField = GuiText_createShown (this -> windowForm, left, right, top, bottom, 0);

 left = right + 10;
 right = left + text_width;
 top = bottom_widgets_top;
 bottom = bottom_widgets_halfway;
 GuiLabel_createShown (this -> windowForm, left, right, top, bottom, U"Extend (s):", 0);
 top = bottom;
 bottom = bottom_widgets_bottom;
 extendTextField = GuiText_createShown (this -> windowForm, left, right, top, bottom, 0);

 left = right + 10;
 right = left + text_width;
 top = bottom_widgets_top;
 bottom = bottom_widgets_halfway;
 GuiLabel_createShown (this -> windowForm, left, right, top, bottom, U"Start f0 (Hz):", 0);
 top = bottom;
 bottom = bottom_widgets_bottom;
 f0TextField = GuiText_createShown (this -> windowForm, left, right, top, bottom, 0);

 left = right + 10;
 right = left + text_width + 10;
 top = bottom_widgets_top;
 bottom = bottom_widgets_halfway;
 GuiLabel_createShown (this -> windowForm, left, right, top, bottom, U"Slope f0 (oct/s):", 0);
 top = bottom;
 bottom = bottom_widgets_bottom;
 f0SlopeTextField = GuiText_createShown (this -> windowForm, left, right, top, bottom, 0);



 bottom = - ((3*16/2) - 16) / 2;
 top = bottom - 16;
 left = 50;
 right = left + status_info_width;
 startInfo = GuiLabel_createShown (this -> windowForm, left, right, top, bottom, U"", 0);

 left = right;
 right = left + status_info_width;
 endInfo = GuiLabel_createShown (this -> windowForm, left, right, top, bottom, U"", 0);







 drawingArea = GuiDrawingArea_createShown (this -> windowForm, 0, 0, Machine_getMenuBarHeight (), -(60+(3*16/2)),
  gui_drawingarea_cb_expose, gui_drawingarea_cb_click, nullptr, gui_drawingarea_cb_resize, this, 0);
 width = GuiControl_getWidth (drawingArea);
 height = GuiControl_getHeight (drawingArea);
}

autoVowelEditor VowelEditor_create (conststring32 title, Daata data) {
 try {
  (! Melder_isTracing ? (void) 0 : Melder_trace ("VowelEditor.cpp", 1322, __FUNCTION__, U"enter"));
  autoVowelEditor me = Thing_newFromClass (classVowelEditor).static_cast_move<structVowelEditor>();
  ((me.get()) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1324, "me.get()"), abort ()));
  if (me -> p_shell_width <= 0 || me -> p_shell_height <= 0) {
   me -> p_shell_width = Melder_atof (me -> default_shell_width ());
   me -> p_shell_height = Melder_atof (me -> default_shell_height ());
  }
  Editor_init (me.get(), 0, 0, me -> p_shell_width, me -> p_shell_height, title, data);



  me -> graphics = Graphics_create_xmdrawingarea (me -> drawingArea);
  ((me -> graphics) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1334, "my graphics"), abort ()));
  Graphics_setFontSize (me -> graphics.get(), 12);

  if (me -> p_window_f1min >= me -> p_window_f1max) {
   me -> p_window_f1min = Melder_atof (me -> default_window_f1min ());
   me -> p_window_f1max = Melder_atof (me -> default_window_f1max ());
  }
  if (me -> p_window_f2min >= me -> p_window_f2max) {
   me -> p_window_f2min = Melder_atof (me -> default_window_f2min ());
   me -> p_window_f2max = Melder_atof (me -> default_window_f2max ());
  }
  if (me -> p_marks_fontSize <= 0)
   me -> p_marks_fontSize = Melder_atof (me -> default_marks_fontSize ());
  if (! Melder_cmp (me -> p_marks_fileName, U"") && me -> p_marks_dataSet < kVowelEditor_marksDataSet::MIN) {
   me -> p_marks_dataSet = me -> default_marks_dataSet ();
   me -> p_marks_speakerType = me -> default_marks_speakerType ();
  }
  VowelEditor_getMarks (me.get());
  if (me -> p_synthesis_numberOfFormants <= 0)
   me -> p_synthesis_numberOfFormants = Melder_atoi (me -> default_synthesis_numberOfFormants ());
  if (me -> p_synthesis_q1 <= 0 || me -> p_synthesis_q2 <= 0) {
   me -> p_synthesis_q1 = Melder_atof (me -> default_synthesis_q1 ());
   me -> p_synthesis_q2 = Melder_atof (me -> default_synthesis_q2 ());
  }
  if (str32len (me -> p_synthesis_extraFBPairs) == 0)
   str32ncpy (me -> p_synthesis_extraFBPairs, me -> default_synthesis_extraFBPairs (), 1+1023); me -> p_synthesis_extraFBPairs [1+1023 - 1] = U'\0';;
  me -> extraFrequencyBandwidthPairs = newVECfromString (me -> p_synthesis_extraFBPairs);
  ((me -> extraFrequencyBandwidthPairs.size >= 4) ? (void) (0) : (Melder_assert_ ("VowelEditor.cpp", 1361, "my extraFrequencyBandwidthPairs.size >= 4"), abort ()));
  me -> p_soundFollowsMouse = true;
  if (me -> p_synthesis_samplingFrequency <= 0.0)
   me -> p_synthesis_samplingFrequency = Melder_atof (me -> default_synthesis_samplingFrequency ());
  if (me -> p_trajectory_minimumDuration <= 0.0 || me -> p_trajectory_maximumDuration <= 0.0) {
   me -> p_trajectory_minimumDuration = Melder_atof (me -> default_trajectory_minimumDuration ());
   me -> p_trajectory_maximumDuration = Melder_atof (me -> default_trajectory_maximumDuration ());
  }
  if (me -> p_trajectory_extendDuration <= 0.0 || me -> p_trajectory_markEvery <= 0.0) {
   me -> p_trajectory_extendDuration = Melder_atof (me -> default_trajectory_extendDuration ());
   me -> p_trajectory_markEvery = Melder_atof (me -> default_trajectory_markEvery ());
  }
  if (me -> data)
   me -> vowel = Data_copy (static_cast<VowelSpecification> (data));
  else
   me -> vowel = VowelSpecification_create_twoFormantSchwa (0.2);
  if (me -> p_f0_start <= 0)
   me -> p_f0_start = Melder_atof (me -> default_f0_start ());
  GuiText_setString (me -> f0TextField, Melder_double (me -> p_f0_start));
  if (me -> p_f0_slope <= 0)
   me -> p_f0_slope = Melder_atof (me -> default_f0_slope ());
  if (me -> p_f0_minimum <= 0 || me -> p_f0_maximum <= 0) {
   me -> p_f0_minimum = Melder_atof (me -> default_f0_minimum ());
   me -> p_f0_maximum = Melder_atof (me -> default_f0_maximum ());
  }
  GuiText_setString (me -> f0SlopeTextField, Melder_double (me -> p_f0_slope));
  GuiText_setString (me -> durationTextField, U"0.2");
  GuiText_setString (me -> extendTextField, Melder_double (me -> p_trajectory_extendDuration));
  if (me -> p_grid_df1 <= 0)
   me -> p_grid_df1 = Melder_atof (me -> default_grid_df1 ());
  if (me -> p_grid_df2 <= 0)
   me -> p_grid_df2 = Melder_atof (me -> default_grid_df2 ());
{



 struct structGuiDrawingArea_ResizeEvent event { me -> drawingArea, 0 };
 event. width = GuiControl_getWidth (me -> drawingArea);
 event. height = GuiControl_getHeight (me -> drawingArea);
 gui_drawingarea_cb_resize (me.get(), & event);
}
  updateWidgets (me.get());
  (! Melder_isTracing ? (void) 0 : Melder_trace ("VowelEditor.cpp", 1403, __FUNCTION__, U"exit"));
  return me;
 } catch (MelderError) {
  do { Melder_appendError (U"VowelEditor not created."); throw MelderError (); } while (false);
 }
}
